<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>局部系统</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="局部系统"><header><h1><span class="taxon">Wiki. </span>局部系统 <a class="slug" href="./局部系统.html">[局部系统]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>生象上</h3>
<p><span class="link local"><a href="./生象.html" title="生象, ∞-群胚 [生象]">生象</a></span> $A$ 上的局部系统就是 $A$ (视为 $\infty$-范畴) 出发的函子. 其它一些种类的几何对象上的局部系统有时可化为其对应的生象上的局部系统.</p>
<h3>拓扑空间上</h3>
<p>拓扑空间 $X$ 上的<strong>局部系统</strong> (local system), 又称<strong>局部常值层</strong> $\mathcal L$ 是满足如下条件的层: 每个点 $x$ 都有一个邻域 $U$ 使得 $\mathcal L|_U$ 是<span class="link local"><a href="./常值层.html" title="常值层 [常值层]">常值层</a></span>.</p>
<p><strong>命题</strong>. 对于道路连通空间, 局部常值的每个点上的茎都 (在同构意义下) 是 $L$. 局部系统一一对应于同态
$$
\rho\colon \pi_1(X)\to \operatorname{Aut}L,
$$
称为<strong>单值表示</strong> (monodromy representation).</p>
<p><strong>证明</strong>. 首先, $[0,1]$ 上的局部系统都是常值层, 所以 $X$ 上的环路给出 $L$ 的自同构, 这定义了同态 $\rho\colon \pi_1(X)\to\operatorname{Aut}L$.</p>
<p>反之, 给定 $\rho$, 考虑万有覆盖 $\widetilde X$ 上的常值层 $\underline{L}$, 其中叠变换 (deck transform) 下与 $\rho$ 等变的截面给出 $X$ 上的局部系统 $\mathcal L(\rho)$,
$$
\mathcal L(\rho)(U) =\left\{s\in \underline{L}(\pi^{-1}(U)): \theta \circ s = \rho(\theta) s \forall \theta\in \operatorname{Deck}(\widetilde X / X)\right\}.
$$
其中 $\operatorname{Deck}(\widetilde X/X)\simeq\pi_1(X)$.</p>
<p>由此亦可见, 局部常值等价于拉回到万有覆盖上是常值层.</p>
<h2>例</h2>
<p>设 $V$ 为光滑流形 $X$ 上的向量丛, 配有<span class="link local"><a href="./平坦联络.html" title=" [平坦联络]">可积联络</a></span>
$$
\nabla\colon V\to V\otimes \Omega_X,
$$
则 $V$ 的<strong>平坦截面</strong>构成局部系统.</p>
<p>进一步, $X$ 上带平坦联络的向量丛的范畴等价于 $X$ 上向量空间局部系统的范畴, 这是 <span class="link local"><a href="./Riemann--Hilbert对应.html" title="“Riemann–Hilbert 对应” [Riemann--Hilbert对应]">Riemann–Hilbert 对应</a></span>的例子.</p>
<p>向量丛的联络有纯代数的版本. 然而, 由带平坦联络的向量丛到局部系统的对应在本质上是<strong>超越</strong> (transcendental) 的: $X$ 上两点 $x$ 与 $y$ 之间的<strong>道路</strong>没有纯代数的对应概念.</p>
<p>反思流形上带联络的向量丛, 我们发现 (不严谨地说) 对于<strong>足够接近的</strong>两点 $x,y$, 有<strong>典范的</strong>同构 $V_x\simeq V_y$. 而对于代数簇, Grothendieck 的概形理论可以描述<span class="link local"><a href="./无穷接近的点.html" title="无穷接近的点 [无穷接近的点]">无穷接近的点</a></span>.</p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Riemann--Hilbert对应"><header><h1><span class="taxon">Wiki. </span>“Riemann–Hilbert 对应” <a class="slug" href="./Riemann--Hilbert对应.html">[Riemann--Hilbert对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Riemann–Hilbert 对应是 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>理论的基本定理, 解答了 <span class="link local"><a href="./Hilbert第21问题.html" title="“Hilbert 第 21 问题” [Hilbert第21问题]">Hilbert 第 21 问题</a></span>.</p>
<p>Riemann–Hilbert 对应的最简单版本是: 一个空间上的<span class="link local"><a href="./平坦向量丛.html" title=" [平坦向量丛]">可积联络</a></span>范畴对应<span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span>的范畴.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="几何Langlands对应"><header><h1><span class="taxon">Wiki. </span>几何 Langlands 对应 <a class="slug" href="./几何Langlands对应.html">[几何Langlands对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<blockquote>
<p>Recently, in a groundbreaking advance, Kapustin and Witten have linked the geometric Langlands correspondence and the S-duality of 4D supersymmetric gauge theories. This and subsequent works have already led to striking new insights into the geometric Langlands Program, which in particular involve the Homological Mirror Symmetry of the Hitchin moduli spaces of Higgs bundles on algebraic curves associated to two Langlands dual Lie groups.</p>
</blockquote>
<p><span class="link local"><a href="./Hitchin模叠.html" title="“Hitchin 模叠” [Hitchin模叠]">Hitchin 模叠</a></span></p>
<p><span class="link local"><a href="./Galois表示.html" title=" [Galois表示]">Galois 表示</a></span>理解为 <span class="link local"><a href="./l-进局部系统.html" title=" [l-进局部系统]">l-进层</a></span>.</p>
<p>非分歧<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span>给出 $\mathrm{GL}_n(F) \backslash \mathrm{GL}_n(\mathbb A) / \mathrm{GL}_n(\mathcal O)$ 上的函数 $f_\pi$ (差一个常数), 它是 <span class="link local"><a href="./Hecke代数.html" title=" [Hecke代数]">Hecke 代数</a></span> $\mathcal H_x, x\in X$ 的特征函数. 使用 <span class="link local"><a href="./Grothendieck函数–层字典.html" title="“Grothendieck 函数–层字典” [Grothendieck函数–层字典]">Grothendieck 函数–层字典</a></span>,</p>
<h2>范畴式几何 Langlands 对应</h2>
<p>范畴式几何 Langlands 对应的主旨是两个 <span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">DG 范畴</a></span>的比较:</p>
<ul>
<li>几何 (“自守”) 侧, 即 $X$ 上 $G$-丛的<span class="link local"><a href="./模叠.html" title=" [模叠]">模空间</a></span>上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>;</li>
<li>谱 (“Galois”) 侧, 即 $X$ 上 $\check G$-<span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span>的叠上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>.</li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="函数域类比"><header><h1><span class="taxon">Wiki. </span>函数域类比 <a class="slug" href="./函数域类比.html">[函数域类比]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<table><thead><tr><th><span class="link local"><a href="./数域.html" title="数域 [数域]">数域</a></span> (“<span class="link local"><a href="./F1.html" title="F1 [F1]">F1</a></span> 上曲线的函数域”)</th><th>$\mathbb F_q$ 上曲线的<span class="link local"><a href="./函数域.html" title="“函数域” [函数域]">函数域</a></span></th><th>复曲线</th></tr></thead><tbody>
<tr><td>$\mathbb{Z}$</td><td>多项式环 $\mathbb F_q[z]$</td><td>复平面上的全纯函数 $\mathcal O$</td></tr>
<tr><td>$\mathbb{Q}$</td><td>分式域 $\mathbb F_q(z)$</td><td>复平面上的亚纯函数</td></tr>
<tr><td>素数 $p$</td><td>$x\in\mathbb F_p$</td><td>$x\in\mathbb{C}$</td></tr>
<tr><td>$\operatorname{Spec}\mathbb{Z}$</td><td>$\operatorname{Spec}\mathbb F_q[z]\simeq\mathbb A^1_{\mathbb F_q}$</td><td>复平面 $\mathbb{C}$</td></tr>
<tr><td>$\operatorname{Spec}\mathbb{Z} \cup \infty$</td><td>$\mathbb P^1_{\mathbb F_q}$</td><td>Riemann 球面 $\mathbb{C}P^1$</td></tr>
<tr><td>$\dfrac{(-)^p-(-)}{p}$</td><td>$\dfrac{\partial}{\partial z}$</td><td>$\dfrac{\partial}{\partial z}$</td></tr>
<tr><td>$\mathbb{Z}/p^n$</td><td>$\mathbb F_q[z]/(z-x)^n$</td><td>$\mathbb{C}[z]/(z-x)^n$</td></tr>
<tr><td><span class="link local"><a href="./p-进整数.html" title="p-进整数 [p-进整数]">$p$-进整数</a></span> $\mathbb{Z}_p$</td><td>形式幂级数 $\mathbb F_q[[z-x]]$</td><td>$\mathbb{C}[[z-x]]$</td></tr>
<tr><td>$p$-进数 $\mathbb{Q}_p$</td><td>Laurent 级数 $\mathbb F_q((z-x))$</td><td>去心邻域上的全纯函数 $\mathbb{C}((z-x))$</td></tr>
<tr><td><span class="link local"><a href="./Adèle.html" title="Adèle [Adèle]">Adèle</a></span> $\mathbb A_{\mathbb{Q}}$</td><td>$\mathbb A_{\mathbb F_q}$</td><td>$\prod'_{x\in\mathbb{C}}\mathbb{C}((z-x))$</td></tr>
<tr><td><span class="link local"><a href="./Idèle.html" title="Idèle [Idèle]">Idèle</a></span> $\mathbb I_{\mathbb{Q}}$</td><td>$\mathbb I_{\mathbb F_q}$</td><td>$\prod'_{x\in\mathbb{C}}\mathrm {GL}_1\mathbb{C}((z-x))$</td></tr>
<tr><td>Riemann <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td>Goss <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td></td></tr>
<tr><td>数域 $K$</td><td>代数曲线上的函数域 $K$</td><td><span class="link local"><a href="./Riemann面.html" title="“Riemann 面” [Riemann面]">Riemann 面</a></span> $\Sigma$ 上的有理函数层 $K_\Sigma$</td></tr>
<tr><td>整数环 $\mathcal O_K$</td><td></td><td>结构层 $\mathcal O_\Sigma$</td></tr>
<tr><td>带有 Archimedes <span class="link local"><a href="./位.html" title="“位” [位]">位</a></span>的谱 $\operatorname{Spec}_{\text{an}}(\mathcal O_K) \to \operatorname{Spec}\mathbb{Z}$</td><td>算术曲线 $\Sigma$</td><td>Riemann 面作为 Riemann 球面的<span class="link local"><a href="./分歧覆叠.html" title="分歧覆叠 [分歧覆叠]">分歧覆叠</a></span> $\Sigma \to \mathbb{C}P^1$</td></tr>
<tr><td>Frobenius 的提升 (<span class="link local"><a href="./λ-环.html" title="“λ-环” [λ-环]">λ-环</a></span>结构)</td><td>$\dfrac{\partial}{\partial z}$</td><td>$\dfrac{\partial}{\partial z}$</td></tr>
<tr><td>数域的亏格</td><td>代数曲线的亏格</td><td>Riemann 面的亏格</td></tr>
<tr><td>素理想 $v\in\mathcal O_K$</td><td>$x\in\Sigma$</td><td>$x\in\Sigma$</td></tr>
<tr><td><span class="link local"><a href="./Adèle.html" title="Adèle [Adèle]">Adèle</a></span> $\mathbb A_{\mathbb{K}}$</td><td></td><td>$\prod'_{x\in\Sigma}\mathbb{C}((z_x))$</td></tr>
<tr><td><span class="link local"><a href="./Idèle.html" title="Idèle [Idèle]">Idèle</a></span> $\mathbb I_{K}$</td><td></td><td>$\prod'_{x\in\Sigma}\mathrm {GL}_1\mathbb{C}((z_x))$</td></tr>
<tr><td>Galois 群</td><td></td><td>基本群</td></tr>
<tr><td>Galois 表示</td><td></td><td><span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span></td></tr>
<tr><td>$\mathrm {GL}_1(K)\backslash \mathrm {GL}_1(\mathbb A_K) / \mathrm {GL}_1(\mathcal O)$</td><td>$\mathrm {GL}_1(K)\backslash \mathrm {GL}_1(\mathbb A_K) / \mathrm {GL}_1(\mathcal O)$</td><td>线丛的模叠 $\mathrm {Bun}_{\mathrm {GL}_1}(\Sigma)$</td></tr>
<tr><td>数域 <span class="link local"><a href="./Langlands对应.html" title="“Langlands 对应” [Langlands对应]">Langlands 对应</a></span></td><td></td><td><span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span></td></tr>
<tr><td>Dedekind <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td>Weil <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td>Riemann 面 (Laplace 算子) 的 <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p><span class="link local"><a href="./Weil罗塞塔石碑.html" title="“Weil 罗塞塔石碑” [Weil罗塞塔石碑]">Weil 罗塞塔石碑</a></span></p>
</details></section></details></section></footer></article></div></body></html>