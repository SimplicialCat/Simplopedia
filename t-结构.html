<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>t-结构</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="t-结构"><header><h1><span class="taxon">Wiki. </span>t-结构 <a class="slug" href="./t-结构.html">[t-结构]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $\mathcal C$ 为<span class="link local"><a href="./三角范畴.html" title="“三角范畴” [三角范畴]">三角范畴</a></span>或<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定无穷范畴</a></span>, 其上的一个 t-结构是一对子范畴 $(\mathcal C_{\geq 0},\mathcal C_{\leq 0})$, 记 $\mathcal C_{\geq n}=\mathcal C_{\geq 0}[n]$, $\mathcal C_{\leq n}=\mathcal C_{\leq 0}[n]$, 满足</p>
<ul>
<li>对任意 $X\in\mathcal C_{\geq 0}$, $Y\in\mathcal C_{\leq -1}$, $\operatorname{Hom}(X,Y)=0$.</li>
<li>$\mathcal C_{\geq 1}\subset\mathcal C_{\geq 0}$, $\mathcal C_{\leq -1}\subset\mathcal C_{\leq 0}$.</li>
<li>对任意 $X\in\mathcal C$ 存在<span class="link local"><a href="./纤维列.html" title="纤维列 [纤维列]">纤维列</a></span> $X'\to X\to X''$, $X'\in\mathcal C_{\geq 0}$, $X''\in\mathcal C_{\leq -1}$.</li>
</ul>
<p>$\mathcal C_{\geq 0}$ 的对象又称连合 (connective) 对象.</p>
<p>注意另一种记号 “上同调记号”, $\mathcal C^{\geq n}$, 对应此处的 $\mathcal C_{\leq -n}$.</p>
<p><span class="link local"><a href="./稳定∞-范畴.html" title=" [稳定∞-范畴]">稳定无穷范畴</a></span>上的 t-结构等同于其<span class="link local"><a href="./链复形范畴的同伦范畴.html" title="“链复形范畴的同伦范畴” [链复形范畴的同伦范畴]">链复形范畴的同伦范畴</a></span>上的 t-结构.</p>
<p>t-结构的<strong>心</strong> (heart) 是 $\mathcal C_{\leq 0}\cap\mathcal C_{\geq 0}$.</p>
<p>t-结构之间的正合函子是保持两个子范畴 $\mathcal C_{\geq 0},\mathcal C_{\leq 0}$ 的函子.</p>
<h2>性质</h2>
<p>对于 $m&lt;n$, 容易证明
$$
\mathcal C_{\leq m} \cap \mathcal C_{\geq n} \simeq \{0\}.
$$
在<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定无穷范畴</a></span>的 t-结构中, 对于 $X\in\mathcal C_{\geq 0}$ 与 $Y\in\mathcal C_{\leq n}$, $\operatorname{Hom}(X,Y)$ 为 $n$-类型. 这是因为
$$
\Omega \operatorname{Hom}(X,Y)\simeq \operatorname{Hom}(X,\Omega Y).
$$
特别地, 对于 $X\in\mathcal C_{\geq 0}$ 与 $Y\in\mathcal C_{\leq 0}$, $\operatorname{Hom}(X,Y)$ 为集合 ($0$-类型).</p>
<p>由此可知 t-结构的心为 $1$-范畴. 事实上, 它是 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span>, 其中的短正合列正是 $\mathcal C$ 中的纤维列.</p>
<p>注意 t-结构的心不能反过来决定 t-结构. 稳定无穷范畴一般也不等价于其上 t-结构的心的<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>. 不是所有的 t-结构都来自导出范畴. 例如<span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>的范畴不同于 $\mathsf {Ab}$ 的导出范畴 (否则稳定同伦论就没有意义了).</p>
<h3>截断</h3>
<p>嵌入 $\mathcal C_{\leq n}\to \mathcal C$ 有左伴随 $\tau_{\leq n}$, 嵌入 $\mathcal C_{\geq n}\to\mathcal C$ 有右伴随 $\tau_{\geq n}$.</p>
<p>$X\in\mathcal C_{\geq 0}$ 当且仅当 $\operatorname{Hom}(X,Y)\simeq\operatorname{Hom}(\tau_{\leq -1}X,Y)\{0\}$ 对任意 $Y\in\mathcal C_{\leq -1}$ 成立.</p>
<p>$X\in\mathcal C_{\leq 0}$ 当且仅当 $\operatorname{Hom}(Y,X)\simeq\operatorname{Hom}(Y,\tau_{\geq 1}X)\{0\}$ 对任意 $Y\in\mathcal C_{\geq 1}$ 成立.</p>
<p>$\tau_{\leq m}\tau_{\leq n}\simeq\tau_{\leq\operatorname{min}(m,n)}$.</p>
<p>$\tau_{\geq m}\tau_{\geq n}\simeq\tau_{\leq\operatorname{max}(m,n)}$.</p>
<p>由 $\mathcal C$ 到 $\mathcal C_{\leq m}\cap\mathcal C_{\geq n}$ 的两种截断方式是等价的.</p>
<p>对任意 $n$, $\mathcal C_{\leq n}\cap\mathcal C_{\geq n}\simeq \mathcal C^{\heartsuit}$. 一个对象截断到这个范畴中的像又称为它的第 $n$ 阶同调, 对于所有的 $n$ 这些同调形成长正合列.</p>
<p>注意所有同调为 $0$ 不能推出这个对象为 $0$, 这个现象在许多场合是有趣的, 如无穷维表示论, 无限型代数几何.</p>
<h3>(余) 极限封闭性</h3>
<p>$\mathcal C_{\geq 0}$ 关于余极限封闭, $\mathcal C_{\leq 0}$ 关于极限封闭.</p>
<h3>扩张封闭性</h3>
<p>设 $X'\to X\to X''$ 为纤维列,</p>
<ul>
<li>若 $X',X''\in\mathcal C_{\geq 0}$, 则 $X\in\mathcal C_{\geq 0}$.</li>
<li>若 $X\in\mathcal C_{\geq 0}$, $X''\in\mathcal C_{\geq 1}$, 则 $X'\in\mathcal C_{\geq 0}$.</li>
<li>若 $X\in\mathcal C_{\geq 0}$, $X'\in\mathcal C_{\geq -1}$, 则 $X''\in\mathcal C_{\geq 0}$.</li>
</ul>
<p>(后两条可通过第一条旋转三角形得到.)</p>
<h3>分离性</h3>
<p>称 t-结构右分离 (因为给我讲这个概念的人使用上同调记号) 是指 $\mathcal C_{\leq-\infty}=\bigcap_n\mathcal C_{\leq n}\simeq\{0\}$, 左分离是指 $\mathcal C_{\geq \infty}=\bigcap_n\mathcal C_{\geq n}\simeq\{0\}$.</p>
<h3>完备性与完备化</h3>
<p>t-结构的完备化为
$$
\widehat {\mathcal C} =\operatorname{lim} (\cdots \overset{\tau_{\leq 2}}{\to}\mathcal C_{\leq 2}\overset{\tau_{\leq 1}}{\to}\mathcal C_{\leq 1}\overset{\tau_{\leq 0}}{\to}\mathcal C_{\leq 0}\overset{\tau_{\leq -1}}{\to}\cdots).
$$
注意此图的右边是不重要的, 可从任意一处截断只保留其左边. 这个极限的一个对象是一个 <span class="link local"><a href="./Postnikov塔.html" title="Postnikov 塔 [Postnikov塔]">Postnikov 塔</a></span>. 由定义有自然的函子 $\mathcal C\to\widehat {\mathcal C}$, 当这个函子为同构时, 称 $\mathcal C$ 左完备.</p>
<p>左完备 t-结构是左分离的, 反之不一定.</p>
<h2>例</h2>
<h3>谱范畴</h3>
<p>无穷范畴的<span class="link local"><a href="./稳定化.html" title="稳定化 [稳定化]">稳定化</a></span>上有典范的 t-结构:</p>
<ul>
<li>$\operatorname{Sp}(\mathcal C)_{\geq 0}$ 是 $\Sigma^{\infty}$ 的像在扩张和余极限之下生成的子范畴.</li>
<li>$\operatorname{Sp}(\mathcal C)_{\leq -1}$ 是 $\Omega^{\infty}$ 为 $0$ 的子范畴.</li>
</ul>
<p><span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>范畴的心与 $\mathsf {Ab}$ 的同构由 <span class="link local"><a href="./Eilenberg–MacLane谱.html" title="Eilenberg–MacLane 谱 [Eilenberg–MacLane谱]">Eilenberg–MacLane 谱</a></span>给出. 此时同调是谱的同伦群.</p>
<p><span class="link local"><a href="./偏屈t-结构.html" title="偏屈 t-结构 [偏屈t-结构]">偏屈 t-结构</a></span></p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Eilenberg–MacLane谱"><header><h1><span class="taxon">Wiki. </span>Eilenberg–MacLane 谱 <a class="slug" href="./Eilenberg–MacLane谱.html">[Eilenberg–MacLane谱]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>对于 Abel 群 $A$, 其 Eilenberg–MacLane 谱 $HA$ 为表示 $A$-系数上同调的谱.</p>
<p><span class="link local"><a href="./连合谱.html" title="连合谱 [连合谱]">连合谱</a></span>等同于 <span class="link local"><a href="./Abel∞-群.html" title="E∞-群 [Abel∞-群]">Abel ∞-群</a></span>, 在此对应下 $HA$ 对应 Abel 群 $A$ 自身.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Leray谱序列"><header><h1><span class="taxon">Wiki. </span>Leray 谱序列 <a class="slug" href="./Leray谱序列.html">[Leray谱序列]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>设
$$
f = (f^*\dashv f_*)\colon \mathcal Y \to \mathcal X
$$
为 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">$\infty$-意象</a></span>之间的<span class="link local"><a href="./几何态射.html" title="几何态射 [几何态射]">几何态射</a></span>, 记 $\Gamma_{\mathcal X}$ 为 $\mathcal X \to\mathsf{Ani}$ 的直像部分, 即<span class="link local"><a href="./整体截面.html" title="“整体截面” [整体截面]">整体截面</a></span>. 那么
$$
    \Gamma_{\mathcal Y} = \Gamma_{\mathcal X}\circ f_*.
$$</p>
<p>设 $F\in\mathsf{Sp}(\mathcal Y)$ 为 $\mathcal Y$ 的<span class="link local"><a href="./稳定化.html" title="稳定化 [稳定化]">稳定化</a></span>的对象. 考虑 $\mathsf{Sp}(\mathcal X)$ 的标准 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span>给出的 $f_* F$ 的 <span class="link local"><a href="./Postnikov塔.html" title="Postnikov 塔 [Postnikov塔]">Postnikov 滤</a></span>, 再以 $\Gamma_{\mathcal X}$ 作用得到一个<span class="link local"><a href="./滤过.html" title="滤对象 [滤过]">滤过</a></span><span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>
$$
\cdots\to
\Gamma_{\mathcal X}(\tau_{\leq q-1}f_*F)
\to
\Gamma_{\mathcal X}(\tau_{\leq q}f_*F)
\to\cdots.
$$
这个滤过谱对应的<span class="link local"><a href="./滤对象的谱序列.html" title="滤对象的谱序列 [滤对象的谱序列]">谱序列</a></span>称为 <strong>Leray 谱序列</strong>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="佐武等价"><header><h1><span class="taxon">Wiki. </span>“佐武等价” <a class="slug" href="./佐武等价.html">[佐武等价]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>几何佐武等价</h2>
<p>固定有限整体维数的 Noether 交换环 $k$. 取定连通约化代数群 $G$ 与<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span> $T\subset G$. 考虑<span class="link local"><a href="./环路群.html" title="环路群 [环路群]">环路群</a></span> $LG$ 以及<span class="link local"><a href="./弧群.html" title=" [弧群]">弧群</a></span> $L^+G$, <span class="link local"><a href="./仿射Grassmann空间.html" title="仿射 Grassmann 空间 [仿射Grassmann空间]">仿射 Grassmann 空间</a></span> $\mathrm{Gr}_G$ 定义为 $LG/L^+G$.</p>
<p>$\mathrm{Gr}_G$ 上的 $L^+G$-等变<span class="link local"><a href="./偏屈层.html" title="偏屈层 [偏屈层]">偏屈层</a></span>的 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span> $\mathsf{Perv}_{L^+G}(\mathrm{Gr}_G)$ 是等变导出范畴上某个偏屈 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span>的心, 且继承了导出范畴上的卷积, 构成<span class="link local"><a href="./幺半范畴.html" title="幺半范畴 [幺半范畴]">幺半范畴</a></span>. 几何佐武等价指出这个幺半范畴等价于 <span class="link local"><a href="./Langlands对偶.html" title="“Langlands 对偶” [Langlands对偶]">Langlands 对偶</a></span>群 $G^\vee$ 的表示范畴,
$$
\mathsf{Perv}_{L^+G}(\mathrm{Gr}_G) \simeq \mathsf{Rep}(G^\vee).
$$</p>
<blockquote>
<p>Under the Satake isomorphism the classes of irreducible representations of $^LG$ go not to functions which correspond to constant sheaves on the orbits but to the irreducible perverse sheaves. This suggests that the Satake isomorphism itself may be elevated from the level of Grothendieck groups to the level of categories. — Frenkel, Recent Advances in the Langlands Program</p>
</blockquote>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="偏屈t-结构"><header><h1><span class="taxon">Wiki. </span>偏屈 t-结构 <a class="slug" href="./偏屈t-结构.html">[偏屈t-结构]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>偏屈 t-结构是<span class="link local"><a href="./可构造层.html" title="可构造层 [可构造层]">可构造</a></span>复形范畴 $D_c^b(X)$ 上的 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span>,</p>
<p>$$
{^p D_c ^{\leq 0}} (X) = \{F \in D_c^b(X) \mid \forall j \in\mathbb{Z}, \dim \operatorname{supp} H^j(F)\leq j\},
$$</p>
<p>$$
{^p D_c ^{\geq 0}} (X) = \{F \in D_c^b(X) \mid \forall j \in\mathbb{Z},\dim \operatorname{supp} H^j(\mathbb D F)\leq - j\}.
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="同伦群(稳定同伦论)"><header><h1><span class="taxon">Wiki. </span>同伦群 (稳定同伦论) <a class="slug" href="./同伦群(稳定同伦论).html">[同伦群(稳定同伦论)]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./稳定同伦论.html" title="稳定同伦论 [稳定同伦论]">稳定同伦论</a></span></li><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>在<span class="link local"><a href="./稳定同伦论.html" title="稳定同伦论 [稳定同伦论]">稳定同伦论</a></span>中, 由于每个对象都是任意阶的环路空间, 对象的 “<span class="link local"><a href="./同伦群.html" title="同伦群 [同伦群]">同伦群</a></span>” 都是 $\mathbb E_\infty$-代数 (<span class="link local"><a href="./交换代数.html" title="交换代数 [交换代数]">交换群</a></span>); 对整个<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 $\infty$-范畴</a></span>而言, 各阶同伦群的地位相同, 仅相差平移.</p>
<h2>定义</h2>
<h3>通过 t-结构</h3>
<p>设<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 $\infty$-范畴</a></span> $\mathcal C$ 带有 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span> $(\mathcal C_{\geq 0},\mathcal C_{\leq 0})$, 其心为 $\mathcal C^\heartsuit = \mathcal C_{\geq 0}\cap\mathcal C_{\leq 0}$. 定义函子
$\pi_0\colon \mathcal C\to\mathcal C$ 为 $\tau_{\geq 0}\tau_{\leq 0} = \tau_{\leq 0}\tau_{\geq 0}$. 对整数 $n$ 定义 $\pi_n (X) = \pi_0 (X[-n])$.</p>
<h3>通过余极限</h3>
<p>对于来自<span class="link local"><a href="./稳定化.html" title="稳定化 [稳定化]">稳定化</a></span>过程的<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 $\infty$-范畴</a></span>, 例如<span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>的范畴 <span class="link local"><a href="./Sp.html" title="Sp [Sp]">$\mathsf{Sp}$</a></span>, 其中对象的同伦群可定义为逼近它的一列对象的同伦群的<span class="link local"><a href="./余极限.html" title="余极限 [余极限]">余极限</a></span>: 若
$$
X = \operatorname{colim}_k \Sigma^{\infty-k} X_k,
$$
则
$$
\pi_n(X) = \operatorname{colim}_k \pi_{n+k} X_k.
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="导出范畴"><header><h1><span class="taxon">Wiki. </span>导出范畴 <a class="slug" href="./导出范畴.html">[导出范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span> $\mathcal A$ 的<strong>导出范畴</strong>是万有的以 $\mathcal A$ 为<span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">心</a></span>的<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 $\infty$-范畴</a></span>.</p>
<p>导出范畴的一个<span class="link local"><a href="./数学对象的表现.html" title="数学对象的表现 [数学对象的表现]">模型</a></span>是将链复形之间的<span class="link local"><a href="./拟同构.html" title="拟同构 [拟同构]">拟同构</a></span>视为同构, 即对拟同构作<span class="link local"><a href="./局部化.html" title="局部化 (环) [局部化]">局部化</a></span>.
此时 $\mathcal A$ 中的对象可视为聚集在 $0$ 位置的链复形.</p>
<h2>定义</h2>
<h3>泛性质</h3>
<p>参考 <span class="link local"><a href="./LurieHA.html" title="Higher Algebra [LurieHA]">HA</a></span> 1.3.3 节.</p>
<h3>模型</h3>
<p>设 $\mathcal A$ 为 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span>. 记 $W$ 为 $\mathcal A$ 中<span class="link local"><a href="./拟同构.html" title="拟同构 [拟同构]">拟同构</a></span>的全体, 定义导出范畴 $\mathsf{D}(\mathcal A)$ 为局部化
$$
\mathsf D(\mathcal A) := \mathsf {Ch}(\mathcal A)[W^{-1}].
$$</p>
<h2>性质</h2>
<p>在 $\mathcal A$ 为 <span class="link local"><a href="./GrothendieckAbel范畴.html" title=" [GrothendieckAbel范畴]">Grothendieck Abel 范畴</a></span>的前提下, $\mathsf {D}(\mathcal A)$ 是<span class="link local"><a href="./稳定∞-范畴.html" title=" [稳定∞-范畴]">稳定无穷范畴</a></span>.</p>
<h2>相关概念</h2>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="滤对象的谱序列"><header><h1><span class="taxon">Wiki. </span>滤对象的谱序列 <a class="slug" href="./滤对象的谱序列.html">[滤对象的谱序列]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>设 $\mathcal C$ 为<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定范畴</a></span>, 带有 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t 结构</a></span>且其心为 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span> $\mathcal A$. 那么对 $\mathcal C$ 中的<span class="link local"><a href="./滤过.html" title="滤对象 [滤过]">滤对象</a></span> $X$ 可构造 $\mathcal A$ 中的<span class="link local"><a href="./谱序列.html" title="谱序列 [谱序列]">谱序列</a></span>.</p>
<h2>例</h2>
<h3>Leray 谱序列</h3>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="滤过"><header><h1><span class="taxon">Wiki. </span>滤对象 <a class="slug" href="./滤过.html">[滤过]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>本页讨论一般 $(\infty,1)$-范畴中的滤对象. 另见 <span class="link local"><a href="./滤对象(1-范畴).html" title="1-范畴中的滤对象 [滤对象(1-范畴)]">$1$-范畴中的滤对象</a></span>.</p>
<h2>定义</h2>
<p>范畴 $\mathcal C$ 中的<strong>滤对象</strong> (filtered object) 是一个序列
$$
X_\bullet = (\cdots\to X_{-1}\to X_0 \to X_1\to \cdots),
$$
即偏序集 $(\mathbb Z,\leq)$ 到范畴 $\mathcal C$ 的函子.
另一种形式的滤对象是
$$
X^\bullet = (\cdots \to X_{1} \to X_0 \to X_{-1}\to\cdots),
$$
即 $\mathbb Z^{\mathrm{op}}$ 到 $\mathcal C$ 的函子.
为了区分两种形式的滤对象, 可分别称之为上升滤对象和下降滤对象.</p>
<p>有时我们想象滤对象中的态射为单射 (含入映射), 但一般 (尤其在 <span class="link local"><a href="./无穷范畴.html" title="无穷范畴 [无穷范畴]">∞-范畴</a></span>语境中) 不需要这个条件.</p>
<p>范畴 $\mathcal C$ 中一个对象 $X$ 的<strong>滤过</strong> (filtration) 是指一个滤对象 $X_\bullet$, 满足 $X\simeq\operatorname{colim}X_\bullet$.</p>
<h2>例</h2>
<p>对于 CW 复形 $X$, 有滤过
$$
\operatorname{sk}_0X \to \operatorname{sk}_1X \to \cdots.
$$</p>
<p>Lie 代数 $\mathfrak g$ 的<span class="link local"><a href="./泛包络代数.html" title="泛包络代数 (Lie 代数) [泛包络代数]">泛包络代数</a></span> $U\mathfrak g$ 有自然的滤过
$$
(U\mathfrak g)_0 \hookrightarrow (U\mathfrak g)_1 \hookrightarrow (U\mathfrak g)_2\hookrightarrow\cdots.
$$</p>
<p>流形 (概形) $X$ 上的<span class="link local"><a href="./微分层.html" title="微分算子层 [微分层]">微分算子层</a></span> $\mathcal D_X$ 有自然的滤过
$$
(\mathcal D_X)_0 \hookrightarrow (\mathcal D_X)_1 \hookrightarrow (\mathcal D_X)_2 \hookrightarrow\cdots.
$$</p>
<h3>典范滤过</h3>
<p><span class="link local"><a href="./链复形无穷范畴.html" title="链复形无穷范畴 [链复形无穷范畴]">链复形范畴</a></span>或<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>的对象, 即链复形
$$
X = (\cdots\to X_1\to X_0 \to X_{-1}\to\cdots)
$$
具有典范的上升滤过 (todo: 方向合理吗)
$$
\tau_{\leq i} X= (\cdots\to 0 \to \operatorname{cofib}(X_{i+1}\to X_i) \to X_{i-1}\to X_{i-2}\to \cdots).
$$
以及典范的下降滤过
$$
\tau_{\geq i} X= (\cdots\to X_{i+2}\to X_{i+1} \to \operatorname{fib}(X_{i}\to X_{i-1}) \to 0\to \cdots).
$$</p>
<h2>性质</h2>
<h3>谱序列</h3>
<p>设 $\mathcal C$ 为<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定范畴</a></span>, 带有 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t 结构</a></span>且其心为 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span> $\mathcal A$. 那么对 $\mathcal C$ 中的滤对象 $X$ 可构造 $\mathcal A$ 中的<span class="link local"><a href="./谱序列.html" title="谱序列 [谱序列]">谱序列</a></span>. 见<span class="link local"><a href="./滤对象的谱序列.html" title="滤对象的谱序列 [滤对象的谱序列]">滤对象的谱序列</a></span>.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./关联分次代数.html" title="关联分次对象 [关联分次代数]">关联分次对象</a></span></p>
<p><span class="link local"><a href="./同伦纤维塔.html" title="“同伦纤维塔” [同伦纤维塔]">同伦纤维塔</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="稳定无穷范畴"><header><h1><span class="taxon">Wiki. </span>稳定范畴 <a class="slug" href="./稳定无穷范畴.html">[稳定无穷范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>以下的范畴均默认为 $(\infty,1)$-范畴.</p>
<p>稳定范畴是类似于<span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>范畴 <span class="link local"><a href="./Sp.html" title="Sp [Sp]">$\mathsf{Sp}$</a></span> 的, 具有一对互逆的<span class="link local"><a href="./环路空间.html" title="环路空间 [环路空间]">环路空间</a></span>和<span class="link local"><a href="./逆环路空间.html" title="逆环路空间 [逆环路空间]">逆环路空间</a></span> (<span class="link local"><a href="./纬悬.html" title="纬悬 [纬悬]">纬悬</a></span>) 函子的范畴.</p>
<h2>定义</h2>
<p><strong>稳定范畴</strong>是满足如下条件的范畴 $\mathcal C$:</p>
<ul>
<li>$\mathcal C$ 具有有限极限和有限余极限; 特别地, 具有零对象 $0$, 以及态射的纤维, 余纤维;</li>
<li>$\mathcal C$ 中的拉回方块等同于推出方块; 特别地, <span class="link local"><a href="./纤维列.html" title="纤维列 [纤维列]">纤维列</a></span>等同于<span class="link local"><a href="./余纤维列.html" title="“余纤维列” [余纤维列]">余纤维列</a></span>;</li>
<li><span class="link local"><a href="./纬悬.html" title="纬悬 [纬悬]">纬悬</a></span>函子 $\Sigma\colon \mathcal C\to\mathcal C$ 与<span class="link local"><a href="./环路空间.html" title="环路空间 [环路空间]">环路空间</a></span>函子 $\Omega\colon \mathcal C\to \mathcal C$ 构成一对互逆的范畴等价.</li>
</ul>
<p><strong>记号</strong>. 对稳定范畴的对象 $X$ 以及整数 $n$, 记
$$
    X[n] = \Sigma^n X,
$$
$$
    X[-n] = \Omega^n X.
$$</p>
<h2>性质</h2>
<h3>稳定化</h3>
<p>具有有限极限的范畴都有<span class="link local"><a href="./稳定化.html" title="稳定化 [稳定化]">稳定化</a></span>.</p>
<h3>谱充实</h3>
<p>稳定范畴自然地<span class="link local"><a href="./充实.html" title=" [充实]">充实</a></span>于<span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>的范畴. 对于稳定范畴 $\mathcal C$ 中的对象 $X,Y$, 映射谱 $\underline{\operatorname{Hom}}(X,Y)$ 可如下定义:
$$
\underline{\operatorname{Hom}}(X,Y)_n = \operatorname{Hom}(X,Y[n]).
$$</p>
<h3>同伦范畴</h3>
<p>稳定范畴的<span class="link local"><a href="./同伦范畴.html" title="“同伦范畴” [同伦范畴]">同伦范畴</a></span>是<span class="link local"><a href="./三角范畴.html" title="“三角范畴” [三角范畴]">三角范畴</a></span>. 例如两个对象 $X,Y$ 的直和 $X\oplus Y$ 既为范畴论和 $X+Y$, 又为范畴论积 $X\times Y$, 两者同构.</p>
<h3>对偶对称性</h3>
<p>稳定范畴的对偶仍是稳定范畴.</p>
<h2>例</h2>
<p>$1$-范畴不可能是稳定范畴, 除非它是平凡的 (等价于终范畴 $1$).</p>
<p><span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span>的范畴是最基本的稳定范畴, 它是<span class="link local"><a href="./∞Grpd.html" title=" [∞Grpd]">生象</a></span>范畴的<span class="link local"><a href="./稳定化.html" title="稳定化 [稳定化]">稳定化</a></span>.</p>
<p>对于 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span> $\mathcal A$, 其上的有界链复形范畴 $\operatorname{Ch}^{\text{b}}(\mathcal A)$ 构成稳定无穷范畴. 见<span class="link local"><a href="./链复形无穷范畴.html" title="链复形无穷范畴 [链复形无穷范畴]">链复形无穷范畴</a></span>.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./K-理论.html" title="“K-理论” [K-理论]">K-理论</a></span>, <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="谱序列"><header><h1><span class="taxon">Wiki. </span>谱序列 <a class="slug" href="./谱序列.html">[谱序列]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>谱序列是计算<span class="link local"><a href="./同伦群.html" title="同伦群 [同伦群]">同伦群</a></span>的一种算法.</p>
<h2>定义</h2>
<p>$$
d_r^{p,q}\colon  E_r^{p,q} \to E_r^{p+r,q-r+1}
$$
第 $(r+1)$ 页是第 $r$ 页的上同调.</p>
<h2>Grothendieck 谱序列</h2>
<p>对于函子
$$
A \overset{F}{\to} B \overset{G}{\to} C,
$$
其导出函子满足
$$
R(G\circ F) \simeq RG \circ RF.
$$</p>
<h2>稳定 ∞-范畴中的滤对象的谱序列</h2>
<p>设 $\mathcal C$ 为带有 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span>的<span class="link local"><a href="./稳定∞-范畴.html" title=" [稳定∞-范畴]">稳定无穷范畴</a></span>. 对于其中的 $\mathbb{Z}$-滤对象 $D_\bullet$, 可构造 $\mathcal C^{\heartsuit}$ 中的谱序列使得
$$
E_1^{p,q}=H_{p+q}\operatorname{cofib}(D_p\to D_{p+1}),
$$
在某些条件下收敛到 $H_n(\operatorname{colim}_m D_m)$.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./正合偶.html" title="“正合偶” [正合偶]">正合偶</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="链复形无穷范畴"><header><h1><span class="taxon">Wiki. </span>链复形无穷范畴 <a class="slug" href="./链复形无穷范畴.html">[链复形无穷范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $\mathcal A$ 为<span class="link local"><a href="./加性范畴.html" title="加性范畴 [加性范畴]">加性范畴</a></span>, 记 $\mathsf {Ch}(\mathcal A)$ 为其中<span class="link local"><a href="./链复形.html" title="链复形 [链复形]">链复形</a></span>的范畴 ($1$-范畴).</p>
<p>记 $S$ 为 $\mathcal A$ 中<span class="link local"><a href="./链同伦等价.html" title="链同伦等价 [链同伦等价]">链同伦等价</a></span>的全体, 定义<strong>链复形 ∞-范畴</strong>为<span class="link local"><a href="./局部化(范畴论).html" title="局部化 (范畴论) [局部化(范畴论)]">局部化</a></span>
$$
\mathsf K(\mathcal A) := \mathsf {Ch}(\mathcal A)[S^{-1}].
$$
它是一个<span class="link local"><a href="./稳定∞-范畴.html" title=" [稳定∞-范畴]">稳定无穷范畴</a></span>. (它也是 $\mathsf {Ch}(\mathcal A)$ 作为<span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">微分分次范畴</a></span>的<span class="link local"><a href="./微分分次脉.html" title="“微分分次脉” [微分分次脉]">微分分次脉</a></span>.)</p>
<p>注意与<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>的区别.</p>
<h2>性质</h2>
<p><strong>例</strong>. 拓扑空间映射的同伦诱导奇异链复形态射的同伦, 链同伦的两个态射诱导相同的同调群同态; 这就是说同调群 $H_*\colon \mathsf{Top} \to \mathsf{Ab}^{\mathbb{Z}}$ 有如下分解:
$$
\mathsf{Top} \overset{\operatorname{Sing}}{\to} \mathsf{K}(\mathsf{Ab}) \overset{H_*}{\to} \mathsf{Ab}^{\mathbb{Z}}.
$$</p>
<p><strong>命题</strong>. $\mathsf {Ch}(\mathcal A)$ 上存在一个<span class="link local"><a href="./模型范畴.html" title="“模型范畴” [模型范畴]">模型范畴</a></span>结构使得</p>
<ul>
<li>弱等价恰为拟同构;</li>
<li>余纤维化恰为逐项的单射.</li>
</ul>
<p>在这种模型结构中, 纤维性对象与内射对象有关. (k-injectivity?)</p>
<p><strong>命题</strong>. 存在正合的伴随函子
$$
\mathsf K(\mathcal A) \rightleftarrows \mathsf D(\mathcal A),
$$
其中右伴随 $\mathsf D(\mathcal A)\to\mathsf K(\mathcal A)$ 全忠实, 左伴随 $\mathsf K(\mathcal A)\to\mathsf D(\mathcal A)$ 是一种纤维性替换, 其核为 $\mathsf K(\mathcal A)$ 中的零调复形.</p>
<h2>t-结构</h2>
<p>$\mathsf D(\mathcal A)$ 上有明显的 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span> $(\mathsf D(\mathcal A)^{\leq 0},\mathsf D(\mathcal A)^{\geq 0})$, 且 $H^0$ 诱导等价 $\mathsf D(\mathcal A)^\heartsuit \to \mathcal A$.</p>
<h3>有界导出范畴</h3>
<p>设 Abel 范畴 $\mathcal A$ 具有足够多内射对象. 定义 $\mathsf D^+(\mathcal A) = N_{\text{dg}}(\mathsf {Ch}^+(\mathcal A_{\text{inj}}))$.</p>
<p>设 Abel 范畴 $\mathcal A$ 具有足够多投射对象. 定义 $\mathsf D^-(\mathcal A) = N_{\text{dg}}(\mathsf {Ch}^-(\mathcal A_{\text{proj}}))\simeq\mathsf D^{+}(\mathcal A^{\text{op}})^{\text{op}}$.</p>
<p>$\mathsf D^-(\mathcal A)$ 具有如下泛性质. 对任意带有左完备 t-结构的<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定无穷范畴</a></span> $\mathcal C$, 如下资料等价:</p>
<ul>
<li>t-右正合函子 $\mathsf D^-(\mathcal A)\to\mathcal C$, 将 $\mathcal A_{\text{proj}}$ 映射到 $\mathcal C^\heartsuit$;</li>
<li>右正合函子 $\mathcal A\to\mathcal C^\heartsuit$.</li>
</ul>
<p>对于右正合函子 $\mathcal A\to\mathcal C^\heartsuit$, 称对应的函子 $\mathsf D^-(\mathcal A)\to\mathcal C$ 为其<span class="link local"><a href="./导出函子.html" title="导出函子 [导出函子]">导出函子</a></span>.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">微分分次范畴</a></span>: 充实于 $1$-范畴 $\mathsf {Ch}(\mathsf {Ab})$ 的范畴.</p>
</details></section></details></section></footer></article></div></body></html>