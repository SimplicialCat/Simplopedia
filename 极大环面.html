<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>极大环面</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="极大环面"><header><h1><span class="taxon">Wiki. </span>极大环面 <a class="slug" href="./极大环面.html">[极大环面]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>#代数</p>
<h2>定义</h2>
<p>设 $G$ 为紧 Lie 群, 称 $G$ 的紧连通 Abel 子群为环面. 极大环面就是包含关系下极大的环面.</p>
<h2>性质</h2>
<p>对于给定的极大环面 $T\hookrightarrow G$, $G$ 的任何元素都共轭于 $T$ 的某个元素.</p>
<h2>例</h2>
<p>$U(n)$ 的极大环面为 $U(1)^n$, 即对角矩阵构成的子群. 类似地, $SO(2n),SO(2n+1)$ 的极大环面为 $SO(2)^n$, 即分块对角矩阵构成的子群, 每一块形如 $\begin{pmatrix}	\cos\theta &amp; -\sin\theta \\ \sin\theta &amp; \cos\theta\end{pmatrix}$.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./Cartan子代数.html" title="“Cartan 子代数” [Cartan子代数]">Cartan 子代数</a></span>, <span class="link local"><a href="./Weyl群.html" title="Weyl 群 [Weyl群]">Weyl 群</a></span></p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Borel子群"><header><h1><span class="taxon">Wiki. </span>Borel 子群 <a class="slug" href="./Borel子群.html">[Borel子群]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Borel 子群是 Lie 群 (或代数群) 极大的<span class="link local"><a href="./可解群.html" title="可解 Lie 群 [可解群]">可解</a></span>闭子群.</p>
<h2>性质</h2>
<p>Borel 子群两两共轭.</p>
<p>每个 Borel 子群 $B \subset G$ 都等于其<span class="link local"><a href="./正规化子.html" title="正规化子 [正规化子]">正规化子</a></span> $N_G(B)$.</p>
<p>任何两个 Borel 子群的交都包含一个<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span>.</p>
<p>(特征 $0$) Borel 子群的 Lie 代数是 <span class="link local"><a href="./Borel子代数.html" title="“Borel 子代数” [Borel子代数]">Borel 子代数</a></span>.</p>
<h2>例</h2>
<p>$\mathrm {GL}_n$ 的一个 Borel 子群是上三角矩阵的子群.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Cartan子代数"><header><h1><span class="taxon">Wiki. </span>“Cartan 子代数” <a class="slug" href="./Cartan子代数.html">[Cartan子代数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $\mathfrak g$ 为 <span class="link local"><a href="./Lie代数.html" title="Lie 代数 [Lie代数]">Lie 代数</a></span>. 定义 $\mathfrak g$ 的 Cartan 子代数为满足如下条件的子代数 $\mathfrak h\leq \mathfrak g$:</p>
<ul>
<li>$\mathfrak h$ 是<span class="link local"><a href="./幂零Lie代数.html" title="“幂零 Lie 代数” [幂零Lie代数]">幂零 Lie 代数</a></span>;</li>
<li>$\mathfrak h$ 的正规化子是自身.</li>
</ul>
<h2>例</h2>
<h3>紧 Lie 群的 Lie 代数</h3>
<p>设 $G$ 为紧 Lie 群, $\mathfrak g$ 为 $G$ 的 Lie 代数, 则 $\mathfrak g$ 的 Cartan 子代数对应 $G$ 的<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span>.</p>
<h2>性质</h2>
<h3>三角分解</h3>
<p>对于 Lie 代数 $\mathfrak g$ 的 Cartan 子代数 $\mathfrak h$, 有<span class="link local"><a href="./三角分解.html" title="“三角分解” [三角分解]">三角分解</a></span>
$$
\mathfrak g = \mathfrak n_- \oplus \mathfrak h \oplus \mathfrak n_+.
$$
其<span class="link local"><a href="./泛包络代数.html" title="泛包络代数 (Lie 代数) [泛包络代数]">泛包络代数</a></span>具有 (线性空间) 同构
$$
U\mathfrak g\simeq U\mathfrak n_- \otimes U\mathfrak h\otimes U\mathfrak n_+.
$$</p>
<h3>Borel 子代数</h3>
<p>固定 Cartan 子代数以及 <span class="link local"><a href="./Borel子代数.html" title="“Borel 子代数” [Borel子代数]">Borel 子代数</a></span>
$$
\mathfrak h\subset \mathfrak b \subset \mathfrak g
$$
相当于固定 $\mathfrak g$ 的一个<span class="link local"><a href="./根系.html" title=" [根系]">根</a></span>, 以及其中的正根系.</p>
<p>$\mathfrak b = \mathfrak h\oplus \mathfrak n$, $\mathfrak n=[\mathfrak b,\mathfrak b]$.</p>
<h2>权</h2>
<p>设 $M$ 是 $\mathfrak g$ 的表示. 对于 $\lambda\in \mathfrak h^*$, 定义权空间 (weight space)
$$
M_\lambda = \{m\in M: hm=\lambda(h)m\forall h\in\mathfrak h\}.
$$
若 $M$ 等于所有 $M_\lambda$ 的直和, 则称其为<span class="link local"><a href="./权模.html" title="“权模” [权模]">权模</a></span> (weight module).</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./半单Lie代数的表示.html" title="“半单 Lie 代数的表示” [半单Lie代数的表示]">半单 Lie 代数的表示</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="SU(2)"><header><h1><span class="taxon">Wiki. </span>“SU(2)” <a class="slug" href="./SU(2).html">[SU(2)]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>$SU(2)$ 是行列式为 $1$ 的二阶酉矩阵的乘法群, 其元素形如
$$
\begin{pmatrix}
\alpha &amp; \beta \\
-\bar\beta &amp; \bar\alpha
\end{pmatrix},
|\alpha|^2 + |\beta|^2 = 1
$$
它也同构于单位四元数的乘法群; 有 Lie 群的同构 $SU(2)\simeq \text{Spin}(3)$ (见 <span class="link local"><a href="./自旋群.html" title="自旋群 [自旋群]">自旋群</a></span>).</p>
<p>$SU(2)$ 的一个<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span>是由对角矩阵 $\begin{pmatrix}	\alpha&amp;\\&amp;\bar\alpha\end{pmatrix} (|\alpha|=1)$ 构成的同构于 $U(1)$ 的子群.</p>
<h2>Lie 代数</h2>
<p>$\mathfrak {su}(2)$ 的元素形如
$$
\begin{pmatrix}
	iz &amp; x+iy \\
	-x+iy &amp; -iz
\end{pmatrix},
x,y,z\in\mathbb{R}.
$$</p>
<p>有 Lie 代数的同构 $\mathfrak {sl}(2,\mathbb{C})\simeq\mathfrak {su}(2)\otimes_{\mathbb{R}}\mathbb{C}$.</p>
<h2>表示</h2>
<p>$SU(2)$ 的表示以自旋 $0,\dfrac{1}{2},1,\cdots$ 标记.</p>
<p>见 <span class="link local"><a href="./sl2的表示.html" title="“sl2的表示” [sl2的表示]">sl2的表示</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Weyl群"><header><h1><span class="taxon">Wiki. </span>Weyl 群 <a class="slug" href="./Weyl群.html">[Weyl群]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>极大环面的 Weyl 群</h3>
<p>紧 Lie 群的 Weyl 群是其<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span> $H$ 的<span class="link local"><a href="./正规化子.html" title="正规化子 [正规化子]">正规化子</a></span> $N(H)$ 的商群
$$
W = N(H)/H.
$$</p>
<p>一个重要的观察是 Weyl 群共轭作用在极大环面 $T$ 上, 且这个作用有效 (effective), 即单位元素外每个元素的作用非平凡.</p>
<h3>一般子群的 Weyl 群</h3>
<p>对任意的子群 $H\subset G$ 也可以定义 Weyl 群 $W_GH := N(H)/H$.
那么 Weyl group 是能够典范地作用于一个 $G$-作用的 $H$-不动点的最大群. Weyl 群也是陪集空间 $G/H$ 在 $G$ 的轨道范畴中的自同构群.</p>
<h3>Lie 代数 Cartan 子代数的 Weyl 群</h3>
<p>设 $\mathfrak g$ 为 Lie 代数, $\mathfrak h$ 为 <span class="link local"><a href="./Cartan子代数.html" title="“Cartan 子代数” [Cartan子代数]">Cartan 子代数</a></span>, Weyl 群 $W\subset GL(\mathfrak h^*)$ 由 $\{s_\alpha: \alpha\in\Phi\}$ 生成, 其中 $s_\alpha$ 是关于<span class="link local"><a href="./根.html" title="根 [根]">根</a></span> $\alpha$ 的正交补空间的反射.</p>
<h2>例</h2>
<p>$\mathrm {U}(n)$ 的极大环面是 $T=\{\operatorname{diag}(e^{i\theta_1},\cdots,e^{i\theta_n})\}$, 其 Weyl 群通过置换特征值作用在 $T$ 上, 故 Weyl 群为置换群 $S_n$.</p>
<p>$\mathrm {SU}(n)$ 的 Weyl 群亦为置换群 $S_n$.</p>
<p>$\mathrm {SO}(2n+1)$ 的 Weyl 群为 $(\mathbb{Z}/2)^n \rtimes S_n$.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="佐武等价"><header><h1><span class="taxon">Wiki. </span>“佐武等价” <a class="slug" href="./佐武等价.html">[佐武等价]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>几何佐武等价</h2>
<p>固定有限整体维数的 Noether 交换环 $k$. 取定连通约化代数群 $G$ 与<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span> $T\subset G$. 考虑<span class="link local"><a href="./环路群.html" title="环路群 [环路群]">环路群</a></span> $LG$ 以及<span class="link local"><a href="./弧群.html" title=" [弧群]">弧群</a></span> $L^+G$, <span class="link local"><a href="./仿射Grassmann空间.html" title="仿射 Grassmann 空间 [仿射Grassmann空间]">仿射 Grassmann 空间</a></span> $\mathrm{Gr}_G$ 定义为 $LG/L^+G$.</p>
<p>$\mathrm{Gr}_G$ 上的 $L^+G$-等变<span class="link local"><a href="./偏屈层.html" title="偏屈层 [偏屈层]">偏屈层</a></span>的 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span> $\mathsf{Perv}_{L^+G}(\mathrm{Gr}_G)$ 是等变导出范畴上某个偏屈 <span class="link local"><a href="./t-结构.html" title="t-结构 [t-结构]">t-结构</a></span>的心, 且继承了导出范畴上的卷积, 构成<span class="link local"><a href="./幺半范畴.html" title="幺半范畴 [幺半范畴]">幺半范畴</a></span>. 几何佐武等价指出这个幺半范畴等价于 <span class="link local"><a href="./Langlands对偶.html" title="“Langlands 对偶” [Langlands对偶]">Langlands 对偶</a></span>群 $G^\vee$ 的表示范畴,
$$
\mathsf{Perv}_{L^+G}(\mathrm{Gr}_G) \simeq \mathsf{Rep}(G^\vee).
$$</p>
<blockquote>
<p>Under the Satake isomorphism the classes of irreducible representations of $^LG$ go not to functions which correspond to constant sheaves on the orbits but to the irreducible perverse sheaves. This suggests that the Satake isomorphism itself may be elevated from the level of Grothendieck groups to the level of categories. — Frenkel, Recent Advances in the Langlands Program</p>
</blockquote>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="特征"><header><h1><span class="taxon">Wiki. </span>特征, 余特征 <a class="slug" href="./特征.html">[特征]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>Lie 群</h3>
<p>Lie 群 $G$ 的<strong>特征</strong> (character) 是 $G$ 到 $S^1$ (或 $\mathbb{C}^\times$) 的同态, <strong>余特征</strong> (cocharacter) 是 $S^1$ 到 $G$ 的同态.</p>
<p>紧 Lie 群 $G$ 的特征 $G \to U(1)$ 由其在任意一个<span class="link local"><a href="./极大环面.html" title="极大环面 [极大环面]">极大环面</a></span> $T\subset G$ 上的取值完全决定. 因此也称极大环面 $T$ 的特征为 $G$ 的特征.</p>
<p><span class="link local"><a href="./Weyl群.html" title="Weyl 群 [Weyl群]">Weyl 群</a></span> $W$ 作用于特征晶格上, 由关于<span class="link local"><a href="./根.html" title="根 [根]">根</a></span>的反射生成.</p>
<h3>代数群</h3>
<p>代数群 $G$ 的<strong>特征</strong>是 $G$ 到 <span class="link local"><a href="./乘法群概形.html" title="乘法群概形 [乘法群概形]">$\mathbb G_m$</a></span> 的同态, 余特征是 $\mathbb{G}_m$ 到 $G$ 的同态..</p>
<h2>例</h2>
<p>$\mathrm{SL}_3$ 的特征晶格是秩为 $2$ 的自由 $\mathbb{Z}$-模.</p>
</details></section></details></section></footer></article></div></body></html>