<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>Morita 范畴</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="Morita范畴"><header><h1><span class="taxon">Wiki. </span>Morita 范畴 <a class="slug" href="./Morita范畴.html">[Morita范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>一般而言, 以某种<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span> $A$ 代表其上的模范畴 $\operatorname{Mod}(A)$, 代数之间的态射 $A\to B$ 是模范畴之间的 (加性, 余连续) 函子 $\mathsf{Mod}(A)\to\mathsf{Mod}(B)$, 也等同于 $(A,B)$-双模 (即<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实</a></span>的单对象范畴之间的<span class="link local"><a href="./代函子.html" title="代函子 [代函子]">代函子</a></span>), 所得的 $2$-范畴称为 Morita 范畴, 该范畴中的等价为 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>.</p>
<p>更一般地, <span class="link local"><a href="./En-代数.html" title="En-代数 [En-代数]">$\mathbb E_n$-代数</a></span>构成<span class="link local"><a href="./高阶Morita范畴.html" title="高阶 Morita 范畴 [高阶Morita范畴]">高阶 Morita 范畴</a></span>.</p>
<h2>性质</h2>
<h3>与线性范畴的关系</h3>
<p><strong>定理</strong> (Eilenberg–Watts). 设 $F\colon \mathsf{RMod}(R) \to \mathsf{RMod}(S)$ 为加性余连续函子, 则存在 $(R,S)$-双模 $N$ 使得
$$
F \simeq (-)\otimes_R N.
$$</p>
<h2>例</h2>
<p>幺半 <span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">DG 范畴</a></span>的 Morita 范畴是一个 $3$-范畴, 其对象为 $\mathcal A\text{-}\mathrm{Mod}(\mathsf{DGCat})$, 态射 $\mathcal A\text{-}\mathrm{Mod}(\mathsf{DGCat}) \to \mathcal B\text{-}\mathrm{Mod}(\mathsf{DGCat})$ 构成的 $2$-范畴为双模范畴
$$
(\mathcal A^{\text{rev}}\otimes\mathcal B)\text{-}\mathrm{Mod}(\mathsf{DGCat}),
$$
其中 $\mathcal A^{\text{rev}}$ 表示将 $\mathcal A$ 的乘法 (幺半结构) 反转.</p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Brauer群"><header><h1><span class="taxon">Wiki. </span>Brauer 群 <a class="slug" href="./Brauer群.html">[Brauer群]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>概形的 <strong>Brauer 群</strong>是其上 <span class="link local"><a href="./Azumaya代数.html" title="Azumaya 代数 [Azumaya代数]">Azumaya 代数</a></span>的相似类在张量积下构成的群; Azumaya 代数 $A$ 在 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中可逆; 因此其上的模范畴 $\mathsf{Mod}(A)$ 是可逆线性范畴.</p>
<p><span class="link local"><a href="./向量丛.html" title="向量丛 [向量丛]">向量丛</a></span>的自同态丛是 Azumaya 代数, 其对应的 Brauer 类平凡.</p>
<blockquote>
<p>Brauer groups and Azumaya algebras play an important role in many areas of mathematics, but especially in arithmetic geometry, algebraic geometry, and applications to mathematical physics. In arithmetic geometry, they are closely related to Tate’s conjecture on l-adic cohomology of schemes over finite fields, and they play a critical role in studying rational points of varieties through, for example, the Brauer Manin obstructions to the Hasse principle. In algebraic geometry, Azumaya algebras arise naturally when studying moduli spaces of vector bundles, and Brauer classes appear when considering certain constructions motivated from physics in homological mirror symmetry. The Brauer group was also used by Artin-Mumford (AM72) to construct one of the first examples of a non-rational unirational complex variety.</p>
</blockquote>
<h2>定义</h2>
<h3>域</h3>
<p>域 $K$ 的 Brauer 群 $\mathrm{Br}(K)$ 是其上的<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>的相似类关于张量积构成的群, 也即上同调
$$
H^2(\operatorname{Gal}(K_{\mathrm{sep}}/K),K^*_{\mathrm{sep}}) = H^2(\operatorname{Spec}K_{\mathrm{et}},\mathbb G_{\mathrm{m}}).
$$</p>
<p>设 $A,B$ 为 $K$ 上的有限维中心单代数, 若存在 $n,m\in\mathbb{Z}_+$ 使得 $M_n(A)\simeq M_m(B)$ (作为 $K$-代数), 则称 $A$ 与 $B$ 相似.</p>
<p>$A$ 与 $B$ 相似当且仅当存在可除代数 $D$ 使得 $A,B$ 均为 $D$ 上的矩阵代数.</p>
<p><strong>例</strong>. $\mathrm{Br}(\mathbb{R})\simeq \{[\mathbb{R}],[\mathbb H]\}$. $\mathbb H\otimes\mathbb H\simeq M_4(\mathbb{R})$.</p>
<p><strong>例</strong>. 有限域的 Brauer 群平凡, 因为有限除环都是域.</p>
<h3>环</h3>
<h4>与模范畴的关系</h4>
<p>设 $R$ 为交换环, 考虑 $2$-范畴 $\mathsf{Alg}_R$, 其对象为 $R$-代数 (即 $R$-模范畴中的幺半群), 态射为双模, 态射的复合为张量积, $2$-态射为双模的同态.</p>
<p>考虑 $\mathsf{Alg}_R$ 的<span class="link local"><a href="./对象的生象.html" title="对象的生象 [对象的生象]">核</a></span> $\mathrm{Core}(\mathsf{Alg}_R)$, 其对象为 $R$-代数, 态射为 Morita 等价, $2$-态射为双模的同构.</p>
<blockquote>
<p>This may be understood as the $2$-groupoid of (generalized) line $2$-bundles over $\operatorname{Spec}R$, inside that of all $2$-vector bundles.</p>
</blockquote>
<ul>
<li>$\pi_0(\mathbf{Br}(R))$ 为 $R$ 的 Brauer 群;</li>
<li>$\pi_1(\mathbf{Br}(R))$ 为 $R$ 的 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>;</li>
<li>$\pi_2(\mathbf{Br}(R))$ 为 $R$ 的乘法可逆元群.</li>
</ul>
<h3>平展上同调的定义</h3>
<p>在一些小的假设下, 概形 $X$ 的 Brauer 群 $\mathrm{Br}(X)$ 同构于<span class="link local"><a href="./平展上同调.html" title="平展上同调 [平展上同调]">平展上同调</a></span> $H^2_{\text{\'et}}(X,\mathbb G_m)$ 的挠部分. 见<span class="link local"><a href="./EC-H1-H2.html" title="平展上同调讨论班 : 非 Abel 上同调, 主齐性空间与 Brauer 群 [EC-H1-H2]">平展上同调讨论班讲义</a></span>.</p>
<h3>“范畴化” 的定义</h3>
<p>Brauer 群某种意义上是 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>的<span class="link local"><a href="./范畴化.html" title="范畴化 [范畴化]">范畴化</a></span>.</p>
<p>对于概形 $X$ 可以谈论 “$X$ 上的拟凝聚<span class="link local"><a href="./叠.html" title="叠 [叠]">叠</a></span>”, 又叫 “$X$-线性<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 ∞-范畴</a></span>”; 其构成的范畴记为 $\mathsf{Cat}_X$.
一个与 Brauer 群相关的群是所谓 “导出 Brauer 群”, 定义为 $\mathsf{Cat}_X$ 的 Picard 群
$$
\mathrm{Br}^{\mathrm{der}}(X) := \operatorname{Pic}(\mathsf{Cat}_X).
$$</p>
<h2>性质</h2>
<p>代数闭域的 Brauer 群是平凡群.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="En-代数"><header><h1><span class="taxon">Wiki. </span>En-代数 <a class="slug" href="./En-代数.html">[En-代数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>$\mathbb E_n$-代数是算畴 <span class="link local"><a href="./En-算畴.html" title="En-算畴 [En-算畴]">$\mathbb E_n$</a></span> 上的<span class="link local"><a href="./算畴上的代数.html" title="算畴上的代数 [算畴上的代数]">代数</a></span>, 一种直观是具有 $n$ 个相容的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合运算</a></span>的代数.</p>
<p>关于 $n=2$ 的特殊情形, 见 <span class="link local"><a href="./E2-代数.html" title="E2 代数 [E2-代数]">$\mathbb E_2$-代数</a></span>.</p>
<p>对于一个 $1$-范畴中的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span> (如幺半群), 它<strong>要么是</strong>交换的, <strong>要么不是</strong>交换的; 这是<span class="link local"><a href="./结构.html" title="结构, 性质 [结构]">性质而非结构</a></span>. 而对于<span class="link local"><a href="./无穷范畴.html" title="无穷范畴 [无穷范畴]">无穷范畴</a></span>中的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>, 有一列无穷多个概念, 称为 $\mathbb E_n$-代数. 当 $n$ 越来越大时, $\mathbb E_n$-代数接近于<span class="link local"><a href="./交换代数.html" title="交换代数 [交换代数]">交换代数</a></span>, 又称 $\mathbb E_\infty$-代数.</p>
<h2>性质</h2>
<p>如下事实体现了 “$\mathbb{E}_n$-代数是有 $n$ 个相容的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合运算</a></span>的代数” 的直观. 对于<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span> $\mathcal C$,
$$
\mathsf{Alg}_{\mathbb E_n}(\mathcal C)\simeq \underbrace{\mathsf{Alg}_{\mathbb E_1}\cdots \mathsf{Alg}_{\mathbb E_1}}_{\text{$n$}}(\mathcal C).
$$</p>
<h3>拓扑场论</h3>
<p>每个 $\mathbb E_n$-代数都作为 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>的对象通过<span class="link local"><a href="./分解同调.html" title="分解同调 [分解同调]">分解同调</a></span>给出<span class="link local"><a href="./拓扑场论.html" title="拓扑场论 [拓扑场论]">拓扑场论</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Skolem–Noether定理"><header><h1><span class="taxon">Wiki. </span>Skolem–Noether 定理 <a class="slug" href="./Skolem–Noether定理.html">[Skolem–Noether定理]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>陈述</h2>
<h3>局部环</h3>
<p>设 $A$ 是局部环 $R$ 上的 <span class="link local"><a href="./Azumaya代数.html" title="Azumaya 代数 [Azumaya代数]">Azumaya 代数</a></span>. 则 $A$ 作为 $R$-代数的自同构均为内自同构, 即形如 $a\mapsto uau^{-1}$, 其中 $u\in A$ 为可逆元.</p>
<h3>概形</h3>
<p>设 $A$ 是<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span> $X$ 上的 <span class="link local"><a href="./Azumaya代数.html" title="Azumaya 代数 [Azumaya代数]">Azumaya 代数</a></span>. 则 $A$ 作为 $\mathcal O_X$-代数的自同构在 <strong>Zariski 局部</strong>为内自同构.</p>
<h2>证明</h2>
<h3>局部环</h3>
<p>设 $A$ 是局部环 $R$ 上的 <span class="link local"><a href="./Azumaya代数.html" title="Azumaya 代数 [Azumaya代数]">Azumaya 代数</a></span>, $\phi$ 是 $A$ 的自同构.
那么 $A$ 以两种方式成为左 $A\otimes_R A^{\mathrm{op}}$-模 (即 $(A,A)$ 双模):</p>
<ul>
<li>$(a_1\otimes a_2^{\mathrm{op}}) a = a_1 a a_2$ (即正常的双模);</li>
<li>$(a_1\otimes a_2^{\mathrm{op}}) a = \phi(a_1) a a_2$ (即左模结构经过 $\phi$ 拉回).</li>
</ul>
<p>分别记上述两个左 $A\otimes_{R}A^{\mathrm{op}}$-模为 $A$, $A'$.</p>
<p><strong>注</strong>. 两个左 $A\otimes_{R}A^{\mathrm{op}}$-模 $A$, $A'$ 分别是 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中 $A$ 的自同构 $\mathrm{id}$ 与 $\phi$. 换言之, 它们分别是 $2$-范畴 <span class="link local"><a href="./高阶模.html" title="高阶模 [高阶模]">$\mathsf{Pr}_R$</a></span> 中 $\mathsf{Mod}(A)$ 的两个自同构 $\mathrm{id}$ 与 $\phi$, 也就是将左 $A$-模结构 “扭曲”.</p>
<p>用上划线表示 $-\otimes_R R/\mathfrak{m}$. 由于 $\bar A \otimes_{\bar R} \bar A ^{\mathrm{op}}$ 是<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span> (实际上是 $\bar R$ 上的矩阵代数), $\bar A$ 与 $\bar A'$ 是其上的<span class="link local"><a href="./单对象.html" title="单对象 [单对象]">单模</a></span>, 而一个中心单代数上的单模在同构意义下唯一; 故存在同构 $\psi\colon \bar A \to \bar A'$.</p>
<p>现在证明 $A$ 是投射 $A\otimes A^{\mathrm{op}}$-模.
由 $A\otimes A^{\mathrm{op}} \simeq \operatorname{End}(A)$,
只需证明 $A$ 是投射 $\operatorname{End}(A)$-模. 事实上 $A$ 是 $\operatorname{End}(A)$ 的直和项.
因为 $A$ 是自由 $R$-模, 故存在 $R$-模同态 $g\colon A\to R$ 使得 $g(r)=r\,(r\in R)$.
考虑映射
$$
    A\mapsto \operatorname{End}(A),
    a\mapsto g(-)a.
$$
它是 $\operatorname{End}(A)$-模同态, 且为投影映射
$$
    \operatorname{End}(A)\to A, f\mapsto f(1)
$$
的截面. 这说明 $A$ 是 $\operatorname{End}(A)$ 的直和项, 从而是投射 $\operatorname{End}(A)$-模.</p>
<p>由于 $A$ 投射, $A\to\bar A\overset{\psi}{\to}\bar A'$ 可提升为 $A\otimes_{R}A^{\mathrm{op}}$-模同态 $\psi\colon A\to A'$, 且由<span class="link local"><a href="./中山引理.html" title="中山引理 [中山引理]">中山引理</a></span>, $\psi$ 为满射.</p>
<p>又注意到</p>
<ul>
<li>$\psi(a) = \psi(1a) = \psi(1)a$;</li>
<li>$\psi(a) = \psi(a1) = \phi(a)\psi(1)$.</li>
</ul>
<p>因此 $\phi(a) \psi(1) = \psi(1) a$.</p>
<p>故存在 $a_0$ 使得 $\psi(a_0)=1$; 由上式知 $\psi(1)$ 可逆, 且 $\phi(a)=\psi(1)a\psi(1)^{-1}$, 即 $\phi$ 为内自同构.</p>
<h3>概形</h3>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="中心"><header><h1><span class="taxon">Wiki. </span>中心 <a class="slug" href="./中心.html">[中心]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>群</h3>
<p>$\mathsf{Set}$ 中的群 $G$ 的中心为
$$
Z(G) = \{g\in G | \forall h\in G, gh=hg\}.
$$</p>
<p>对更一般的<span class="link local"><a href="./群.html" title="群 [群]">群</a></span> (如<span class="link local"><a href="./生象.html" title="生象, ∞-群胚 [生象]">生象</a></span>群) $G$,
定义
$$
Z(G) := \operatorname{Aut}_{\operatorname{Aut}_{\mathsf{Ani}}(\mathbf{B}G)}(\mathrm{id}).
$$
换言之, $\mathbf{B}Z(G)$ 是 $\operatorname{Aut}_{\mathsf{Ani}}(\mathbf{B}G)$ 在 $\mathrm{id}_{\mathbf{B}G}$ 处的连通分支. 一个生象 $A$ 的连通分支是 $A\to\tau_{\leq 0} A$ 的纤维.
因此该定义也可等价地陈述如下. 考虑群 $G$ 的<span class="link local"><a href="./群的外自同构.html" title="群的外自同构 [群的外自同构]">外自同构</a></span>群
$$
\begin{aligned}
    \operatorname{Out}(G)&amp;=
\tau_{\leq 0}
(\operatorname{Aut}_{\mathsf{Grp}}(G) /_{\mathrm{Ad}} G)\\
&amp; =\tau_{\leq 0}\operatorname{Aut}(\mathbf{B}G).
\end{aligned}
$$
那么有<span class="link local"><a href="./群短正合列.html" title="群的短正合列 [群短正合列]">短正合列</a></span>
$$
\mathbf{B}Z(G) \to \mathsf{Aut}(\mathbf{B}G) \to \operatorname{Out}(G)
$$
以及<span class="link local"><a href="./纤维列.html" title="纤维列 [纤维列]">纤维列</a></span>
$$
\begin{aligned}
    \mathbf{B}Z(G) &amp;\to \mathsf{Aut}(\mathbf{B}G) \to \operatorname{Out}(G)\\
\to \mathbf{B}^2Z(G) &amp;\to \mathbf{B}\mathsf{Aut}(\mathbf{B}G) \to \mathbf{B}\operatorname{Out}(G).
\end{aligned}
$$</p>
<h3>环</h3>
<p>固定交换环 $k$ 作为基环.
设 $A$ 为 $k$ 上的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>. $A$ 的<strong>中心</strong>是与所有元素交换的元素的集合
$$
Z(A) = \{a\in A | \forall b\in A, ab=ba\},
$$
也是 $A$ 作为 $(A,A)$-双模的自同态的集合
$$
Z(A) = \operatorname{End}_{\mathsf{BiMod}(A,A)}(A),
$$
也是<span class="link local"><a href="./等化子.html" title="等化子 [等化子]">等化子</a></span>
$$
Z(A) = \operatorname{eq}\big(
    A\rightrightarrows \operatorname{Hom}_k(A,A)
\big),
$$
其中两个映射分别为左乘与右乘.</p>
<p>回忆 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中, <span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span> $A$ 的恒等态射即是 $A$ 作为 $(A,A)$-双模. 因此, $A$ 的中心又可理解为
$$
Z(A) = \operatorname{End}_{\operatorname{End}_{\mathsf{Morita}}(A)}(\mathrm{id}).
$$</p>
<p>进一步, Morita 范畴嵌入线性范畴的范畴, 从而<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span> $A$ 的中心也可定义为
$$
Z(R) := \operatorname{End}_{\operatorname{End}_{\mathsf{Cat}}(\mathsf{Mod}(A))}(\mathrm{id}).
$$</p>
<h3>幺半范畴</h3>
<p>设 $\mathcal C$ 为 $k$-线性<span class="link local"><a href="./幺半范畴.html" title="幺半范畴 [幺半范畴]">幺半范畴</a></span>,
定义 $\mathcal C$ 的 <strong>Drinfeld 中心</strong> $Z(\mathcal C)$ 是一个<span class="link local"><a href="./辫幺半范畴.html" title="辫幺半范畴 [辫幺半范畴]">辫幺半范畴</a></span>, 可理解为两个函子 $\mathcal C \to \operatorname{Hom}_k(\mathcal C,\mathcal C)$ 的<span class="link local"><a href="./等化子.html" title="等化子 [等化子]">等化子</a></span>, 其对象为 $\mathcal C$ 的对象 $X$ 配备自然变换
$$
X\otimes (-) \to (-)\otimes X,
$$
满足两个自然变换 $X\otimes (Y\otimes Z)\to (Y\otimes Z)\otimes X$ 相等.</p>
<h3>2-范畴的对象</h3>
<p>定义 $2$-范畴 $\mathcal C$ 的对象 $X$ 的<strong>中心</strong>为<span class="link local"><a href="./幺半群.html" title="幺半群 [幺半群]">幺半群</a></span>
$$
Z(X) := \operatorname{End}_{\operatorname{End}_{\mathcal C}(X)}(\mathrm{id}_X).
$$
它类似于 $\mathcal C$ 在 $X$ 处的二阶<span class="link local"><a href="./环路空间.html" title="环路空间 [环路空间]">环路空间</a></span>.
由 <span class="link local"><a href="./Eckmann--Hilton论证.html" title="Eckmann–Hilton 论证 [Eckmann--Hilton论证]">Eckmann–Hilton 论证</a></span>, $Z(X)$ 为 <span class="link local"><a href="./E2-代数.html" title="E2 代数 [E2-代数]">$\mathbb E_2$</a></span> 幺半群 (辫幺半群).</p>
<p>这样定义的中心又称 <span class="link local"><a href="./Hochschild上同调.html" title="Hochschild 上同调 [Hochschild上同调]">Hochschild 上同调</a></span>.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./余中心.html" title="余中心 [余中心]">余中心</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="代函子"><header><h1><span class="taxon">Wiki. </span>代函子 <a class="slug" href="./代函子.html">[代函子]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><strong>代函子</strong> (profunctor) 是函子的推广, 类似于关系是函数的推广.</p>
<p><span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>之间的代函子又称为<span class="link local"><a href="./充实范畴上的模.html" title="充实范畴上的模 [充实范畴上的模]">充实范畴上的双模</a></span>.</p>
<p>单对象的<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>之间的代函子 (<span class="link local"><a href="./充实范畴上的模.html" title="充实范畴上的模 [充实范畴上的模]">双模</a></span>) 是代数同态的推广. 对于交换环 $R$, 全体单对象 $\mathsf{Mod}(R)$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span> (即 $R$-<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">代数</a></span>) 以及代函子 (即双模) 构成的 $2$-范畴正是 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>.</p>
<h2>定义</h2>
<p>范畴 $\mathcal C$ 到 $\mathcal D$ 的<strong>代函子</strong> (profunctor) 是指函子 $\mathcal C \times \mathcal D^{\mathrm{op}} \to \mathsf{Set}$, 也即 $\mathcal C$ 到<span class="link local"><a href="./预层.html" title="预层 [预层]">预层</a></span>范畴 $\mathsf{Psh}(\mathcal D)$ 的函子 $\mathcal C\to \mathsf{Psh}(\mathcal D)$. 代函子有时也记作 $\mathcal C$ ⇸ $\mathcal D$.</p>
<p>当然, <span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>也有类似的概念.</p>
<h3>复合</h3>
<p>代函子 $f\colon \mathcal C\times\mathcal D^{\mathrm{op}}\to\mathsf{Set}$ 与 $g\colon \mathcal D\times\mathcal E^{\mathrm{op}} \to\mathsf{Set}$ 的<strong>复合</strong>是代函子 $gf\colon \mathcal C\times\mathcal E^{\mathrm{op}}\to\mathsf{Set}$,
$$
gf(c,e) := \operatorname{colim}_{d\in \mathcal D} f(c,d)\times g(d,e).
$$</p>
<p>全体范畴以及代函子构成一个 $2$-范畴.</p>
<p><span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>之间的代函子又叫<span class="link local"><a href="./充实范畴上的模.html" title="充实范畴上的模 [充实范畴上的模]">双模</a></span>, 代函子的复合即是双模的张量积.</p>
<h3>同态集</h3>
<p>代函子 $f\colon \mathcal C\times\mathcal D^{\mathrm{op}} \to \mathsf{Set}$ 到 $g\colon \mathcal E\times\mathcal D^{\mathrm{op}}\to\mathsf{Set}$ 的<strong>同态集</strong>是代函子 $[f,g]\colon \mathcal E\times\mathcal C^{\mathrm{op}}\to\mathsf{Set}$,
$$
[f,g](e,c) := \operatorname{lim}_d \operatorname{Hom}(f(c,d),g(e,d)).
$$</p>
<p><span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>之间的代函子 (<span class="link local"><a href="./充实范畴上的模.html" title="充实范畴上的模 [充实范畴上的模]">双模</a></span>) 的同态集即是双模的同态集.</p>
<h2>性质</h2>
<h3>与普通函子的关系</h3>
<p>普通的函子 $f\colon \mathcal C\to\mathcal D$ 给出两个代函子:</p>
<ul>
<li>$\operatorname{Hom}_{\mathcal D}(f(-),-) \colon \mathcal D \otimes\mathcal C^{\mathrm{op}} \to \mathsf{Set}$;</li>
<li>$\operatorname{Hom}_{\mathcal D}(-,f(-)) \colon \mathcal C \otimes\mathcal D^{\mathrm{op}} \to \mathsf{Set}$.</li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="充实范畴上的模"><header><h1><span class="taxon">Wiki. </span>充实范畴上的模 <a class="slug" href="./充实范畴上的模.html">[充实范畴上的模]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>可视为单对象<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>. <strong>充实范畴上的模</strong>是结合代数上的模和<span class="link local"><a href="./预层.html" title="预层 [预层]">预层</a></span>的共同的推广.</p>
<p>充实范畴 $\mathcal A$ 上的模范畴 $\mathsf{LMod}(\mathcal A)$, $\mathsf{RMod}(\mathcal A)$ 是结合代数上的模范畴的推广, 其之间的等价是 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>的推广.</p>
<p><strong>注意</strong>. 这里所说的 “充实范畴上的模” 与 “<span class="link local"><a href="./幺半范畴.html" title="幺半范畴 [幺半范畴]">幺半范畴</a></span>上的模” 是<strong>不同</strong>的概念. 后者指的是将<span class="link local"><a href="./幺半范畴.html" title="幺半范畴 [幺半范畴]">幺半范畴</a></span>视为 $\mathsf{Cat}$ 中的结合代数, 然后考虑<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>上的模. 而前者中的充实范畴 $\mathcal A$ 甚至不一定是结合代数.</p>
<p>但是, $\mathcal V$-充实范畴与 $\mathcal V$ (作为<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>) 上的模是有关系的. 确切地说两者之间有一个自由-遗忘<span class="link local"><a href="./伴随.html" title="伴随 [伴随]">伴随</a></span>: $\mathcal V$-充实范畴 $\mathcal A$ 上的右模范畴 $[\mathcal A^{\mathrm{op}},\mathcal V]$ 是其自由生成的 $\mathcal V$-模.</p>
<h2>定义</h2>
<p>设 $\mathcal V$ 为余完备<span class="link local"><a href="./闭范畴.html" title="闭范畴 [闭范畴]">闭</a></span><span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>. 对于 $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span> $\mathcal A$, 定义 $\mathcal A$-<strong>左模</strong>的范畴为充实函子范畴
$$
    \mathsf{LMod}(\mathcal A) := [\mathcal A,\mathcal V],
$$
$\mathcal A$-<strong>右模</strong>的范畴为
$$
    \mathsf{RMod}(\mathcal A):=
    \mathsf{LMod}(\mathcal A^{\mathrm{op}})=
    [\mathcal A^{\mathrm{op}},\mathcal V].
$$</p>
<p>对于两个 $\mathcal V$-充实范畴 $\mathcal A,\mathcal B$, 定义 $(\mathcal A,\mathcal B)$-<strong>双模</strong>的范畴为
$$
    \mathsf{BMod}(\mathcal A,\mathcal B) := \mathsf{LMod}(\mathcal A\otimes\mathcal B^{\mathrm{op}}) = [\mathcal A\otimes\mathcal B^{\mathrm{op}},\mathcal V].
$$
双模又叫<span class="link local"><a href="./代函子.html" title="代函子 [代函子]">代函子</a></span> (profunctor).</p>
<p>$\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span> $\mathcal A$ 自身可作为 $(\mathcal A,\mathcal A)$-双模 $\mathcal A\otimes\mathcal A^{\mathrm{op}}\to\mathcal V$, $(a,a')\mapsto \operatorname{Hom}(a',a)$.</p>
<h2>性质</h2>
<h3>双模的张量积</h3>
<p>定义 $(\mathcal A,\mathcal B)$-双模 $M\colon \mathcal A\otimes\mathcal B^{\mathrm{op}}\to\mathcal V$ 和 $(\mathcal B,\mathcal C)$-双模 $N\colon \mathcal B\otimes\mathcal C^{\mathrm{op}}\to\mathcal V$ 在 $\mathcal B$ 上的<strong>张量积</strong> $M\otimes_{\mathcal B}N\colon \mathcal A\otimes\mathcal C^{\mathrm{op}} \to \mathcal V$ 为
$$
M\otimes_{\mathcal B} N (a,c):= \operatorname{colim}_{b\in\mathcal B} M(a,b)\otimes N(b,c).
$$
特别地, $(\mathcal A,\mathcal B)$-双模给出函子 $\mathsf{RMod}(\mathcal A) \to \mathsf{RMod}(\mathcal B)$.
若将双模视为 $\mathcal A$ 到 $\mathcal B$ 的<span class="link local"><a href="./代函子.html" title="代函子 [代函子]">代函子</a></span>, 则双模的张量积是<span class="link local"><a href="./代函子.html" title="代函子 [代函子]">代函子</a></span>的复合. 若将双模视为模范畴之间的函子, 则双模的张量积也是模范畴之间的函子的复合.</p>
<h3>中心</h3>
<p>回忆环 $R$ 上的代数 $A$ 的<span class="link local"><a href="./中心.html" title="中心 [中心]">中心</a></span>是 $R$, 意味着 $A$ 作为 $A\otimes A^{\mathrm{op}}$-模的自同态环为 $R$. 这推广为如下定义.</p>
<p><strong>定义</strong> (中心 $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>). 设 $\mathcal A$ 是 $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>. 若 $\mathcal A$ 作为 $\mathcal A\otimes\mathcal A^{\mathrm{op}}$-模的自同态对象为 $\mathcal V$ 的始对象 (换言之, 函子 $\mathcal I \to \mathsf{Mod}(\mathcal A\otimes\mathcal A^{\mathrm{op}})$, $*\mapsto\mathcal A$ 全忠实), 则称 $\mathcal A$ 为<strong>中心</strong> $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>.</p>
<h3>生成元</h3>
<p>回忆, 对环 $R$ 上的代数 $A$ 以及 $A$-模 $M$, 称 $M$ 为 $\mathsf{Mod}(A)$ 的<span class="link local"><a href="./生成元(范畴论).html" title="生成元 (范畴论) [生成元(范畴论)]">生成元</a></span>是指 $\operatorname{Hom}_A(M,-)$ 反映同构; 即 $A$-模同态 $f\colon X\to Y$ 为同构当且仅当 $\operatorname{Hom}(M,X) \to \operatorname{Hom}(M,Y)$ 为同构.</p>
<p>设 $M$ 为 $(A,B)$-双模, 则有函子 $\operatorname{Hom}(M,-) \colon \mathsf{RMod}(A) \to \mathsf{RMod}(B)$. 若该函子反映同构, 则称 $M$ 为<strong>强生成元</strong> (strong generator).</p>
<p><strong>定义</strong>. 设 $\mathcal A,\mathcal B$ 为 $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>, $M$ 为 $(\mathcal A,\mathcal B)$-<span class="link local"><a href="./充实范畴上的模.html" title="充实范畴上的模 [充实范畴上的模]">双模</a></span>. 若
$$
\mathsf{RMod}(B)\to\mathsf{RMod}(A),
$$
$$
(F\colon \mathcal B\to\mathcal V)\mapsto (A\mapsto \operatorname{Hom}_{\mathsf{Fun}(\mathcal B^{\mathrm{op}},\mathcal V)}(M(A,-),F))
$$
反映同构, 则称 $M$ 为<strong>强生成元</strong>.</p>
<h3>Morita 等价</h3>
<p><strong>命题-定义</strong>. 设 $\mathcal A,\mathcal B$ 为 $\mathcal V$-充实范畴. 若如下等价条件成立, 则称 $\mathcal A,\mathcal B$ <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>:</p>
<ul>
<li>$\mathsf{RMod}(\mathcal A)$ 与 $\mathsf{RMod}(\mathcal B)$ 作为 $\mathcal V$-充实范畴相等价;</li>
<li>存在 $(\mathcal A,\mathcal B)$-双模 $M$ 以及 $(\mathcal B,\mathcal A)$-双模 $N$ 使得
$$
M\otimes_{\mathcal B} N \simeq \mathcal A,\,N\otimes_{\mathcal A}M\simeq\mathcal B.
$$</li>
</ul>
<p>对于一个具体的双模, 如下命题刻画了其何时为 Morita 等价.</p>
<p><strong>命题</strong>. 对于 $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span> $\mathcal A,\mathcal B$ 以及 $(\mathcal A,\mathcal B)$-双模 $M$, 如下条件等价.</p>
<ol>
<li>$M$ 是 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中的可逆 $1$-态射, 即 $M$ 构成了 $\mathcal A$ 到 $\mathcal B$ 的 Morita 等价;</li>
<li>若将 $M$ 视为函子 $\mathcal A \to\mathsf{Fun}(\mathcal B^{\mathrm{op}},\mathcal V)$, 则其沿米田嵌入的左 <span class="link local"><a href="./Kan扩张.html" title="Kan 扩张 [Kan扩张]">Kan 扩张</a></span> $\operatorname{LKE}(M)\colon \mathsf{Fun}(\mathcal A^{\mathrm{op}},\mathcal V)\to \mathsf{Fun}(\mathcal B^{\mathrm{op}},\mathcal V)$ 为等价;</li>
<li>$M$ 为强生成元, 有右伴随, 且函子 $\mathcal A \to\mathsf{Fun}(\mathcal B^{\mathrm{op}},\mathcal V)$ 全忠实.</li>
</ol>
<h3>伴随</h3>
<p>双模的伴随即是 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span> (作为 $2$-范畴) 中的<span class="link local"><a href="./伴随.html" title="伴随 [伴随]">伴随</a></span>.</p>
<h3>小投射模</h3>
<p><strong>命题</strong>. 设 $R$ 为交换环, $A,B$ 为 $R$-代数, $M$ 为 $(A,B)$-双模. 那么 $M$ 有右<span class="link local"><a href="./伴随.html" title="伴随 [伴随]">伴随</a></span>当且仅当 $M$ 为有限生成投射 $B$-模.</p>
<p><strong>定义</strong>. 设 $\mathcal A,\mathcal B$ 为 $\mathcal V$-充实范畴, $M$ 为 $(\mathcal A,\mathcal B)$-双模. 若 $M$ 有右伴随, 则称其为<strong>小投射</strong> (small projective) $(\mathcal A,\mathcal B)$-双模.</p>
<h3>可分充实范畴</h3>
<p>可分充实范畴是<span class="link local"><a href="./可分代数.html" title="可分代数 [可分代数]">可分代数</a></span>的推广.</p>
<p>设 $\mathcal A$ 为 $\mathcal V$-充实范畴, 若 $\mathcal A$ 作为 $\mathcal A\otimes\mathcal A^{\mathrm{op}}$-模 $\mathcal A\otimes\mathcal A^{\mathrm{op}} \to \mathcal V$ 为小投射模, 则称 $\mathcal A$ <strong>可分</strong> (separable).</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="幺半维数"><header><h1><span class="taxon">Wiki. </span>对称幺半维数 <a class="slug" href="./幺半维数.html">[幺半维数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p><span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>中, 一个对象的幺半维数是其恒等映射的<span class="link local"><a href="./迹.html" title="迹 [迹]">迹</a></span>.</p>
<h2>例</h2>
<p><span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>在 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中的幺半维数是其 <span class="link local"><a href="./Hochschild同调.html" title="Hochschild 同调 [Hochschild同调]">Hochschild 同调</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="范畴代数"><header><h1><span class="taxon">Wiki. </span>Möbius 反演 <a class="slug" href="./范畴代数.html">[范畴代数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>固定一个环 $k$. 设 $\mathcal C$ 为<span class="link local"><a href="./严格1-范畴.html" title="严格 1-范畴 [严格1-范畴]">严格 $1$-范畴</a></span>, 满足如下有限性条件: 对任意态射 $f$, 至多存在有限组态射 $(g,h)$ 使得 $f=gh$. 那么 $\mathcal C$ 的态射集上的 (有限支集, 或者不要求有限支集) $k$ 值函数空间 $\operatorname{Fun}(\operatorname{Mor}(\mathcal C),k)$ 上有卷积
$$
(\varphi * \psi)(f) = \sum_{f=gh} \varphi(g) \psi(h).
$$
这样得到的代数称为<strong>范畴代数</strong> $k\mathcal{C}$, 它是群代数以及 incidence algebra (参考 <span class="link local"><a href="./AndrewKobinZeta.html" title="A Primer on Zeta Functions and Decomposition Spaces [AndrewKobinZeta]">Andrew Kobin</a></span>) 的推广.</p>
<p>用另一种视角, 有限支集的函数 $\operatorname{Mor}(\mathcal C) \to k$ 相当于以 $\operatorname{Mor}(\mathcal C)$ 为基的自由 $k$-模的元素. 此时卷积等同于
$$
\sum a_g g * \sum b_h h = \sum a_g b_h gh.
$$
(其中若 $g,h$ 不能复合则 $gh=0$.)</p>
<p><strong>注</strong>. 等价的 $1$-范畴不一定给出同构的代数; 所以范畴代数的概念的确是对<strong>严格 $1$-范畴</strong> (而不是 $1$-范畴) 定义的概念.</p>
<p>但是, 如果进一步取范畴代数的 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>类, 得到的概念又尊重范畴的等价; 即对于范畴等价 $\mathcal C\simeq\mathcal D$, 不一定有 $k\mathcal C\simeq k\mathcal D$, 但 $k\mathcal C$ 与 $k\mathcal D$ <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>.</p>
<p>范畴代数的构造不是到代数的范畴的函子 (注意到函子 $\mathcal C\to\mathcal D$ 给出线性映射 $k\mathcal C\to k\mathcal D$, 但它不一定保持乘法), 而是到 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>的函子.</p>
<h2>性质</h2>
<h3>单位元</h3>
<p>定义
$$
\delta(f) = \begin{cases}
    1 &amp; f=\mathrm{id}_c\\
    0 &amp; \text{其它},
\end{cases}
$$
那么 $\delta$ 是卷积的单位元.</p>
<h3>逆元</h3>
<p>(todo: 何时可逆)</p>
<h3>Morita 等价</h3>
<p><strong>命题</strong>. 若将 $k\mathcal{C}$ 视为仅有一个对象的 $\mathsf{Vect}_k$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>, 则有
$$
[\mathcal C,\mathsf{Vect}_k]\simeq [k\mathcal C,\mathsf{Vect}_k].
$$
换言之, $\mathcal C$ (生成的$\mathsf{Vect}_k$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span>) 与 $k\mathcal C$ 在充实范畴的意义下 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="高阶Morita范畴"><header><h1><span class="taxon">Wiki. </span>高阶 Morita 范畴 <a class="slug" href="./高阶Morita范畴.html">[高阶Morita范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>设 $n\in\mathbb{N}_{\geq 0}$ 为自然数, $\mathcal C$ 为对称幺半 $(\infty ,1)$-范畴 (或更一般的 <span class="link local"><a href="./En-代数.html" title="En-代数 [En-代数]">$\mathbb E_n$-幺半</a></span> $(\infty ,1)$-范畴), 可构造一个 $(\infty ,n+1)$-范畴 $\mathsf{Morita}_{n}(\mathcal C)$,</p>
<ul>
<li>$\mathsf{Morita}_{n}(\mathcal C)$ 的对象为 $\mathcal C$ 中的 <span class="link local"><a href="./En-代数.html" title="En-代数 [En-代数]">$\mathbb E_n$-代数</a></span>;</li>
<li>$\mathsf{Morita}_{n}(\mathcal C)$ 的对象为 $\mathcal C$ 中两个对象 $A,B$ 之间的态射范畴为双模范畴 $\mathsf{BiMod}(A,B)$ 的低一阶的 Morita 范畴
$$
\operatorname{Hom}_{\mathsf{Morita}_{n}(\mathcal C)}(A,B)=\mathsf{Morita}_{(n-1)}(\mathsf{BiMod}(A,B)).
$$</li>
</ul>
<p>作为归纳定义的起点, 定义 $\mathsf{Morita}_0(\mathcal C) = \mathcal C$.</p>
<p>当 $n=1$ 时这就是通常的 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>.</p>
<p>与通常的 Morita 范畴类似, 高阶 Morita 范畴也可视为由<span class="link local"><a href="./高阶模.html" title="高阶模 [高阶模]">高阶模范畴</a></span>构成的范畴, 其中 $\mathbb E_n$-代数 $A$ 代表的是它上面的 $n$ 阶模范畴 $\mathsf{Mod}(\mathsf{Mod}(\cdots\mathsf{Mod}(A)\cdots))$.</p>
<h2>性质</h2>
<h3>分解同调与拓扑场论</h3>
<p>对称幺半 $(\infty ,1)$-范畴 $\mathcal C$ 中的 <span class="link local"><a href="./En-代数.html" title="En-代数 [En-代数]">$\mathbb E_n$-代数</a></span> $A$ 给出一个取值于 Morita 范畴 $\mathsf{Morita}_{n}(\mathcal C)$ 的 $n$ 维<span class="link local"><a href="./拓扑场论.html" title="拓扑场论 [拓扑场论]">拓扑场论</a></span> $\mathsf{Bord}_n^{\mathrm{fr}} \to \mathsf{Morita}_{n}(\mathcal C)$. 对于自然数 $0\leq k\leq n$, 该函子将 $\mathsf{Bord}_n^{\mathrm{fr}}$ 中的 $k$-态射 ($k$ 维标架配边) $M$ 对应到<span class="link local"><a href="./分解同调.html" title="分解同调 [分解同调]">分解同调</a></span>
$$
M \mapsto \int_{M\times\mathbb{R}^{n-k}}A.
$$
注意 $\int_{M\times\mathbb{R}^{n-k}}A$ 具有 $\mathbb E_{n-k}$-结构.
特别地, 该函子将一个点 $\mathrm{pt}$ 对应到 $\mathbb E_n$-代数 $A$ 自身.</p>
</details></section></details></section></footer></article></div></body></html>