<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>几何 Langlands 对应</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="几何Langlands对应"><header><h1><span class="taxon">Wiki. </span>几何 Langlands 对应 <a class="slug" href="./几何Langlands对应.html">[几何Langlands对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<blockquote>
<p>Recently, in a groundbreaking advance, Kapustin and Witten have linked the geometric Langlands correspondence and the S-duality of 4D supersymmetric gauge theories. This and subsequent works have already led to striking new insights into the geometric Langlands Program, which in particular involve the Homological Mirror Symmetry of the Hitchin moduli spaces of Higgs bundles on algebraic curves associated to two Langlands dual Lie groups.</p>
</blockquote>
<p><span class="link local"><a href="./Hitchin模叠.html" title="“Hitchin 模叠” [Hitchin模叠]">Hitchin 模叠</a></span></p>
<p><span class="link local"><a href="./Galois表示.html" title=" [Galois表示]">Galois 表示</a></span>理解为 <span class="link local"><a href="./l-进局部系统.html" title=" [l-进局部系统]">l-进层</a></span>.</p>
<p>非分歧<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span>给出 $\mathrm{GL}_n(F) \backslash \mathrm{GL}_n(\mathbb A) / \mathrm{GL}_n(\mathcal O)$ 上的函数 $f_\pi$ (差一个常数), 它是 <span class="link local"><a href="./Hecke代数.html" title=" [Hecke代数]">Hecke 代数</a></span> $\mathcal H_x, x\in X$ 的特征函数. 使用 <span class="link local"><a href="./Grothendieck函数–层字典.html" title="“Grothendieck 函数–层字典” [Grothendieck函数–层字典]">Grothendieck 函数–层字典</a></span>,</p>
<h2>范畴式几何 Langlands 对应</h2>
<p>范畴式几何 Langlands 对应的主旨是两个 <span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">DG 范畴</a></span>的比较:</p>
<ul>
<li>几何 (“自守”) 侧, 即 $X$ 上 $G$-丛的<span class="link local"><a href="./模叠.html" title=" [模叠]">模空间</a></span>上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>;</li>
<li>谱 (“Galois”) 侧, 即 $X$ 上 $\check G$-<span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span>的叠上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>.</li>
</ul>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Langlands对应"><header><h1><span class="taxon">Wiki. </span>“Langlands 对应” <a class="slug" href="./Langlands对应.html">[Langlands对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>本页介绍<span class="link local"><a href="./数域.html" title="数域 [数域]">数域</a></span>上的 Langlands 对应. 另见<span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span>, <span class="link local"><a href="./Langlands纲领.html" title="“Langlands 纲领” [Langlands纲领]">Langlands 纲领</a></span>.</p>
<blockquote>
<p>Frenkel, Lectures on the Langlands Program and Conformal Field Theory</p>
</blockquote>
<h2>一维</h2>
<p>数论中一个重要的问题是<span class="link local"><a href="./绝对Galois群.html" title="绝对 Galois 群 [绝对Galois群]">绝对 Galois 群</a></span>. 对于有理数域, 我们不能很好地描述其绝对 Galois 群 $\mathrm{Gal}(\overline{\mathbb{Q}}/\mathbb{Q})$, 但可以描述它的极大 Abel 商. 这对应于有理数域的极大 Abel 扩张 $\mathbb{Q}^{\mathrm{ab}}$, 它是 $\mathbb{Q}$ 添加所有单位根所得的扩张.
$$
\operatorname{Gal}(\mathbb{Q}^{\mathrm{ab}}/\mathbb{Q}) \simeq \widehat {\mathbb{Z}}^\times \simeq \prod_{p}\mathbb Z_p^\times.
$$
<span class="link local"><a href="./Abel类域论.html" title="“Abel 类域论” [Abel类域论]">Abel 类域论</a></span>的结论是 $\operatorname{Gal}(F^{\mathrm{ab}}/F)$ 等同于 $F^{\times}\backslash \mathbb A_F^\times$ 的连通分支的群. 在 $F=\mathbb{Q}$ 的情形它是
$$
\mathbb{Q}^{\times}\backslash \mathbb A_{\mathbb{Q}}^\times\simeq \prod_p \mathbb{Z}_p^\times \times \mathbb{R}_{&gt;0}.
$$</p>
<h2>$n$ 维</h2>
<ul>
<li>$\operatorname{Gal}(\overline{F}/F)$ 的 $n$ 维表示 - $\mathrm{GL}_n(\mathbb A_F)$ 的<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span></li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Langlands纲领"><header><h1><span class="taxon">Wiki. </span>“Langlands 纲领” <a class="slug" href="./Langlands纲领.html">[Langlands纲领]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li><li class="meta-item">[]</li></ul></div></header></summary>

<table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><span class="link local"><a href="./椭圆曲线.html" title="“椭圆曲线” [椭圆曲线]">椭圆曲线</a></span></td><td>←</td><td>Ramanujan</td><td>→</td><td><span class="link local"><a href="./自守形式.html" title="“自守形式” [自守形式]">自守形式</a></span></td></tr>
<tr><td>↓</td><td></td><td></td><td></td><td>↓</td></tr>
<tr><td>$\operatorname{Gal}(\overline{F}/F) \to {^LG}$, Frobenius</td><td>←</td><td>原始 <span class="link local"><a href="./Langlands对应.html" title="“Langlands 对应” [Langlands对应]">Langlands 对应</a></span></td><td>→</td><td>$\mathbb G(\mathbb A_F)$ 的<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span>, Hecke</td></tr>
<tr><td>↓</td><td></td><td></td><td></td><td>↓</td></tr>
<tr><td>曲线上的平坦 ${^LG}$-丛</td><td>←</td><td><span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span></td><td>→</td><td><span class="link local"><a href="./主丛的模空间.html" title="“主丛的模空间” [主丛的模空间]">主丛的模空间</a></span> $\mathrm {Bun}_G$ 上的 Hecke 特征层</td></tr>
<tr><td>↓</td><td></td><td></td><td></td><td>↓</td></tr>
<tr><td>$\mathrm {Loc}_{^LG}$ 上的导出范畴</td><td>←</td><td>范畴 Langlands 对应</td><td>→</td><td>$\mathrm {Bun}_G$ 上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>导出范畴</td></tr>
</tbody></table>
<p>故事从 Euler 开始. Euler 用不严格的方法算出了自然数的 $s$ 次方的倒数和 ($s\geq 2$ 为自然数), 这个数后来叫做 <span class="link local"><a href="./Riemannζ-函数.html" title="Riemann ζ-函数 [Riemannζ-函数]">Riemann ζ-函数</a></span> $\zeta(s)$. 除此之外, Euler 还指出 $\zeta(s)$ 可写成所谓 “<strong>Euler 因子</strong>” $1/(1-p^{-s})$ 对素数 $p$ 的乘积, 由此可以推出素数分布的一些信息. Riemann 发现 $\zeta(s)$ 是全纯函数, 从而自然地寻求其解析延拓. 这件事可以用 Euler 的乘积公式以及 $\zeta(s)$ 满足的<strong>函数方程</strong>
$$
\Lambda(1-s)=\Lambda(s),\ \Lambda(s)=\pi^{-s/2}\Gamma(s/2)\zeta(s)
$$
来做到. (奇妙的是, Euler 使用他的发散级数发现了 $\zeta(s)$ 的函数方程.) 这个函数方程中的 $\Gamma$ 项直到 Tate 才获得完全的理解: 它是 $\mathbb{Q}$ 的 Archimedes <span class="link local"><a href="./位.html" title="“位” [位]">位</a></span>的 Euler 因子.</p>
<p>后来, Riemann 建立了一个显式的公式, 将素数和 $\zeta$ 函数的零点关联起来. 由此他猜想 $\zeta$ 的零点的实部为 $1/2$, 这相当于素数分布的一个极好的性质.</p>
<p>Dirichlet 在研究模 $q$ 余 $a$ 素数的分布时用到了所谓 Dirichlet <span class="link local"><a href="./L-函数.html" title="“L-函数” [L-函数]">L-函数</a></span>. 他的方法可理解为 $\mathbb{Z}/q$ 上的调和分析. 设 $\chi\colon (\mathbb{Z}/q)^\times \to\mathbb{C}^\times$ 为 <span class="link local"><a href="./Dirichlet特征.html" title="“Dirichlet 特征” [Dirichlet特征]">Dirichlet 特征</a></span>, 定义
$$
L(\chi,s)=\sum_{n}\chi(n)n^{-s} = \prod_p 1/(1-\chi(p)p^{-s}).
$$</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./Weil罗塞塔石碑.html" title="“Weil 罗塞塔石碑” [Weil罗塞塔石碑]">Weil 罗塞塔石碑</a></span>, <span class="link local"><a href="./函数域类比.html" title="函数域类比 [函数域类比]">函数域类比</a></span></p>
<p><span class="link local"><a href="./局部几何Langlands对应.html" title="“局部几何 Langlands 对应” [局部几何Langlands对应]">局部几何 Langlands 对应</a></span></p>
<p><span class="link local"><a href="./镜对称.html" title="“镜对称” [镜对称]">镜对称</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="l-进层"><header><h1><span class="taxon">Wiki. </span>“l-进层” <a class="slug" href="./l-进层.html">[l-进层]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>定义代数簇上的 $\mathbb{Z}_\ell$-层为<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展景</a></span>上的一系列局部常值 (或关于某个分层结构为可构造的) $\mathbb{Z}/\ell^m$-层. 消灭其中的挠层 (torsion sheaf), 就得到所谓 $\mathbb{Q}_{\ell}$-层.</p>
<p>类似地可以对 $\mathbb{Q}_{\ell}$ 的有限扩张 $E$ 定义 $E$-层.</p>
<p>最后, 取所有 $E$-层的范畴的 (有向) 余极限. 这个范畴中的对象称为 <strong>$\ell$-进局部系统</strong> ($\ell$-adic local system).</p>
<p>所谓 <span class="link local"><a href="./Galois表示.html" title=" [Galois表示]">Galois 表示</a></span>可理解为 $\ell$-进局部系统.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="函数域类比"><header><h1><span class="taxon">Wiki. </span>函数域类比 <a class="slug" href="./函数域类比.html">[函数域类比]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<table><thead><tr><th><span class="link local"><a href="./数域.html" title="数域 [数域]">数域</a></span> (“<span class="link local"><a href="./F1.html" title="F1 [F1]">F1</a></span> 上曲线的函数域”)</th><th>$\mathbb F_q$ 上曲线的<span class="link local"><a href="./函数域.html" title="“函数域” [函数域]">函数域</a></span></th><th>复曲线</th></tr></thead><tbody>
<tr><td>$\mathbb{Z}$</td><td>多项式环 $\mathbb F_q[z]$</td><td>复平面上的全纯函数 $\mathcal O$</td></tr>
<tr><td>$\mathbb{Q}$</td><td>分式域 $\mathbb F_q(z)$</td><td>复平面上的亚纯函数</td></tr>
<tr><td>素数 $p$</td><td>$x\in\mathbb F_p$</td><td>$x\in\mathbb{C}$</td></tr>
<tr><td>$\operatorname{Spec}\mathbb{Z}$</td><td>$\operatorname{Spec}\mathbb F_q[z]\simeq\mathbb A^1_{\mathbb F_q}$</td><td>复平面 $\mathbb{C}$</td></tr>
<tr><td>$\operatorname{Spec}\mathbb{Z} \cup \infty$</td><td>$\mathbb P^1_{\mathbb F_q}$</td><td>Riemann 球面 $\mathbb{C}P^1$</td></tr>
<tr><td>$\dfrac{(-)^p-(-)}{p}$</td><td>$\dfrac{\partial}{\partial z}$</td><td>$\dfrac{\partial}{\partial z}$</td></tr>
<tr><td>$\mathbb{Z}/p^n$</td><td>$\mathbb F_q[z]/(z-x)^n$</td><td>$\mathbb{C}[z]/(z-x)^n$</td></tr>
<tr><td><span class="link local"><a href="./p-进整数.html" title="p-进整数 [p-进整数]">$p$-进整数</a></span> $\mathbb{Z}_p$</td><td>形式幂级数 $\mathbb F_q[[z-x]]$</td><td>$\mathbb{C}[[z-x]]$</td></tr>
<tr><td>$p$-进数 $\mathbb{Q}_p$</td><td>Laurent 级数 $\mathbb F_q((z-x))$</td><td>去心邻域上的全纯函数 $\mathbb{C}((z-x))$</td></tr>
<tr><td><span class="link local"><a href="./Adèle.html" title="Adèle [Adèle]">Adèle</a></span> $\mathbb A_{\mathbb{Q}}$</td><td>$\mathbb A_{\mathbb F_q}$</td><td>$\prod'_{x\in\mathbb{C}}\mathbb{C}((z-x))$</td></tr>
<tr><td><span class="link local"><a href="./Idèle.html" title="Idèle [Idèle]">Idèle</a></span> $\mathbb I_{\mathbb{Q}}$</td><td>$\mathbb I_{\mathbb F_q}$</td><td>$\prod'_{x\in\mathbb{C}}\mathrm {GL}_1\mathbb{C}((z-x))$</td></tr>
<tr><td>Riemann <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td>Goss <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td></td></tr>
<tr><td>数域 $K$</td><td>代数曲线上的函数域 $K$</td><td><span class="link local"><a href="./Riemann面.html" title="“Riemann 面” [Riemann面]">Riemann 面</a></span> $\Sigma$ 上的有理函数层 $K_\Sigma$</td></tr>
<tr><td>整数环 $\mathcal O_K$</td><td></td><td>结构层 $\mathcal O_\Sigma$</td></tr>
<tr><td>带有 Archimedes <span class="link local"><a href="./位.html" title="“位” [位]">位</a></span>的谱 $\operatorname{Spec}_{\text{an}}(\mathcal O_K) \to \operatorname{Spec}\mathbb{Z}$</td><td>算术曲线 $\Sigma$</td><td>Riemann 面作为 Riemann 球面的<span class="link local"><a href="./分歧覆叠.html" title="分歧覆叠 [分歧覆叠]">分歧覆叠</a></span> $\Sigma \to \mathbb{C}P^1$</td></tr>
<tr><td>Frobenius 的提升 (<span class="link local"><a href="./λ-环.html" title="“λ-环” [λ-环]">λ-环</a></span>结构)</td><td>$\dfrac{\partial}{\partial z}$</td><td>$\dfrac{\partial}{\partial z}$</td></tr>
<tr><td>数域的亏格</td><td>代数曲线的亏格</td><td>Riemann 面的亏格</td></tr>
<tr><td>素理想 $v\in\mathcal O_K$</td><td>$x\in\Sigma$</td><td>$x\in\Sigma$</td></tr>
<tr><td><span class="link local"><a href="./Adèle.html" title="Adèle [Adèle]">Adèle</a></span> $\mathbb A_{\mathbb{K}}$</td><td></td><td>$\prod'_{x\in\Sigma}\mathbb{C}((z_x))$</td></tr>
<tr><td><span class="link local"><a href="./Idèle.html" title="Idèle [Idèle]">Idèle</a></span> $\mathbb I_{K}$</td><td></td><td>$\prod'_{x\in\Sigma}\mathrm {GL}_1\mathbb{C}((z_x))$</td></tr>
<tr><td>Galois 群</td><td></td><td>基本群</td></tr>
<tr><td>Galois 表示</td><td></td><td><span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span></td></tr>
<tr><td>$\mathrm {GL}_1(K)\backslash \mathrm {GL}_1(\mathbb A_K) / \mathrm {GL}_1(\mathcal O)$</td><td>$\mathrm {GL}_1(K)\backslash \mathrm {GL}_1(\mathbb A_K) / \mathrm {GL}_1(\mathcal O)$</td><td>线丛的模叠 $\mathrm {Bun}_{\mathrm {GL}_1}(\Sigma)$</td></tr>
<tr><td>数域 <span class="link local"><a href="./Langlands对应.html" title="“Langlands 对应” [Langlands对应]">Langlands 对应</a></span></td><td></td><td><span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span></td></tr>
<tr><td>Dedekind <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td>Weil <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td><td>Riemann 面 (Laplace 算子) 的 <span class="link local"><a href="./ζ-函数.html" title="ζ-函数 [ζ-函数]">ζ-函数</a></span></td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p><span class="link local"><a href="./Weil罗塞塔石碑.html" title="“Weil 罗塞塔石碑” [Weil罗塞塔石碑]">Weil 罗塞塔石碑</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="特征向量"><header><h1><span class="taxon">Wiki. </span>特征向量 <a class="slug" href="./特征向量.html">[特征向量]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>设<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span> $A$ 作用于另一对象 $V$. 定义一个<strong>特征值</strong>为一个代数同态 $\sigma\colon A \to 1$. 定义对应于特征值 $\sigma$ 的<strong>特征向量</strong>为元素 $v \colon 1\to V$, 满足
$$
a(v) = \sigma(a)v\,(a\in A),
$$
也即下图交换 (记 $\rho\colon A\otimes V\to V$ 为 $A$ 在 $V$ 上的作用):
$$
\begin{array}{ccc}
    A &amp; \overset{\sigma}{\to} &amp; 1\\
    \!\!\!\!v\downarrow&amp;&amp;\downarrow v\!\!\!\!\\
    A\otimes V&amp;\underset{\rho}{\to} &amp; V
\end{array}
$$</p>
<p>在高阶范畴的语境中也有类似概念, 只不过是将上述条件推广为单纯对象的同态
$$
\begin{array}{cccccc}
    \cdots &amp; A\otimes A \otimes 1 &amp; \rightrightarrows &amp; A\otimes 1 &amp; \overset{\sigma}{\to} &amp; 1\\
    &amp;\downarrow &amp;&amp;\!\!\!\!v\downarrow&amp;&amp;\downarrow v\!\!\!\!\\
    \cdots &amp; A\otimes A\otimes V &amp; \rightrightarrows&amp;A\otimes V&amp;\underset{\rho}{\to} &amp; V.
\end{array}
$$
或者用更简洁的表述, 对于 $\sigma$ 给出的 $A$ 在 $1$ 上的作用而言, $v \colon 1 \to V$ 是 $A$-线性映射.</p>
<h2>例</h2>
<h3>线性变换</h3>
<p>对于 $k$-线性空间 $V$ 上的线性变换 $T$,
有 $A = k[x]$ 在 $V$ 上的作用, 其中 $x$ 的作用为 $T$.
此时 $A$ 在 $V$ 上的作用的特征向量就是传统上说的线性变换 $T$ 的特征向量.</p>
<h3>Hecke 作用</h3>
<p>在<span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span>中,
$A = \operatorname{Rep}(\check{G})$ 作用在 $V= D(D\text{-}\mathsf{Mod}(\mathrm{Bun}_G))$ 上, 特征向量称为 <span class="link local"><a href="./Hecke特征层.html" title="Hecke 特征层 [Hecke特征层]">Hecke 特征层</a></span>.</p>
</details></section></details></section></footer></article></div></body></html>