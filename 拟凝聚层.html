<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>拟凝聚层</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="拟凝聚层"><header><h1><span class="taxon">Wiki. </span>拟凝聚层 <a class="slug" href="./拟凝聚层.html">[拟凝聚层]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span>上的拟凝聚层是环上的模的推广.</p>
<p>拟凝聚层的范畴 $\mathsf{QCoh}(X)$ 是代数几何中的一种代数对象 (见<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数–几何对偶</a></span>). 取拟凝聚层 $X \mapsto \mathsf{QCoh}(X)$ 构成一个由 (qcqs) 概形到<span class="link local"><a href="./可表现范畴.html" title="可表现范畴 [可表现范畴]">可表现</a></span><span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>的嵌入.</p>
<p>拟凝聚层有高阶范畴的<span class="link local"><a href="./范畴化.html" title="范畴化 [范畴化]">推广</a></span>: <span class="link local"><a href="./高阶拟凝聚层.html" title="高阶拟凝聚层 [高阶拟凝聚层]">高阶拟凝聚层</a></span>.</p>
<h2>定义</h2>
<h3>传统</h3>
<p>概形 $X$ 上的拟凝聚层是 $\mathcal O_X$-模 $M$, 满足在每个仿射<span class="link local"><a href="./开嵌入.html" title="开嵌入 [开嵌入]">开子概形</a></span> $\operatorname{Spec} A\hookrightarrow X$ 上等同于某个 $A$-模 $M$ 对应的模层 $\widetilde M$.</p>
<h3>函子式</h3>
<p>概形 $X$ 上的拟凝聚层范畴是
$$
\mathsf{QCoh}(X) := \operatorname{lim}_{\operatorname{Spec}A \to X}\mathsf{Mod}(A).
$$</p>
<p>换言之, <span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span> $\operatorname{Spec}A$ 上的拟凝聚层就定义为 $A$-模; 而一般概形 $X$ 上的拟凝聚层范畴 $\mathsf{QCoh}(X)$ 是由如下<span class="link local"><a href="./Kan扩张.html" title="Kan 扩张 [Kan扩张]">左 Kan 扩张</a></span>给出:
$$
\begin{array}{ccc}
\mathsf{Aff} &amp; \overset{\mathsf{Mod}}{\to} &amp; \mathsf{Cat} \\
\downarrow &amp; \nearrow &amp;\\
\mathsf{Sch}&amp;&amp;
\end{array}
$$
其中 $\mathsf{Aff} \to \mathsf{Sch}$ 是<span class="link local"><a href="./米田嵌入.html" title="米田嵌入 [米田嵌入]">米田嵌入</a></span>.</p>
<h2>性质</h2>
<h3>截面的可控奇异性</h3>
<p>设 $X$ 为拟紧拟分离概形, $f\in\Gamma(X,\mathcal O_X)$ 为整体函数, 考虑 $f$ 不消失的开子空间 $X_f$, 则对任意拟凝聚层 $F$,
$$
F(X)_f \to F(X_f)
$$
为同构. 这个事实的一种直观是, 拟凝聚层截面的<strong>奇异性</strong>总是可控的, 类似于一个亚纯函数.</p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Gestalt"><header><h1><span class="taxon">Wiki. </span>Gestalt <a class="slug" href="./Gestalt.html">[Gestalt]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Gestalt (复数 Gestalten, 在心理学上的译名为 “格式塔”) 是 <span class="link local"><a href="./ScholzeStefanichGestalten.html" title="Geometry and Higher Category Theory [ScholzeStefanichGestalten]">Scholze–Stefanich</a></span> 提出的一种几何概念, 旨在恢复完全的<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数–几何对偶</a></span>: 通过考虑几何对象上的 “线性 $(\infty,n)$-范畴” 取值的层, 即<span class="link local"><a href="./高阶拟凝聚层.html" title="高阶拟凝聚层 [高阶拟凝聚层]">高阶拟凝聚层</a></span>, 使得任何几何对象都具有代数的对应物, 而不再需要对 “仿射” 几何对象进行粘合操作.</p>
<h2>观念</h2>
<ol>
<li>代数几何中的几乎所有几何对象都来自于仿射概形之类的基本对象的 “粘合”. 做这件事的一般框架是<span class="link local"><a href="./景.html" title="景 [景]">景</a></span>和<span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span>的理论. 给仿射概形的范畴配备适当的覆盖结构, 然后取其上的层, 这就相当于取仿射概形的 (形式上的) 余极限, 得到一个包含许多几何对象的<span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span>.
而后<span class="link local"><a href="./模空间.html" title="模空间 [模空间]">模空间</a></span>的研究让人们自然地考虑群胚取值的层, 又称<span class="link local"><a href="./叠.html" title="叠 [叠]">叠</a></span>. 群胚取值的层是带有同伦信息的几何对象, 构成一个 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">∞-意象</a></span>.</li>
<li>在<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数–几何对偶</a></span>中, 通常不是所有几何对象都有完美的代数侧对偶. 例如在概形中, 只有仿射概形能被其上的整体函数环完全决定. 不仿射的概形如 $\mathbb P^1_k$ ($k$ 为域), 其上没有足够多的整体函数, 以至于仅看整体函数我们无法将它和一个点区分开.</li>
<li>在有非平凡高阶同伦信息的几何对象 (例如群概形 $G$ 的<span class="link local"><a href="./分类空间.html" title="分类空间 [分类空间]">分类空间</a></span> $* / G$) 上, 整体函数更加不可能提供全部的信息. 但 <span class="link local"><a href="./淡中对偶.html" title="淡中对偶 [淡中对偶]">Tannaka</a></span> 指出此时<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>的范畴 $\mathsf{QCoh}(X)$, 直观上即 “线性空间值的整体函数”, 连带着其上的<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半</a></span>结构, 能够忠实地记录这个几何对象. 这里<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>作为一种代数对象, 可视为环的推广.</li>
<li>事实上, $\mathsf{QCoh}$ 能忠实记录的几何对象就已经包括了所有的 (qcqs) 概形.
不仅如此, 一些叠 (对角线仿射的 qcqs <span class="link local"><a href="./代数叠.html" title="代数叠 [代数叠]">Artin 叠</a></span>) 也能被其拟凝聚层范畴忠实记录, 人们称之为 $1$-仿射 ($1$-affine) 叠.</li>
<li>将 Abel 范畴升级为<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>, 我们考虑的代数对象变成了<span class="link local"><a href="./可表现范畴.html" title="可表现范畴 [可表现范畴]">可表现</a></span><span class="link local"><a href="./对称幺半∞-范畴.html" title="对称幺半 ∞-范畴 [对称幺半∞-范畴]">对称幺半</a></span><span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 ∞-范畴</a></span>. 通过取导出范畴 $D \colon \mathsf{CAlg}(\mathsf{Sp})\hookrightarrow\mathsf{CAlg}(\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}})$, 环 (包括环谱) 忠实地嵌入这种代数对象.</li>
<li>但仍旧有几何对象无法被拟凝聚层的 (导出) 范畴记录. 例如 $\mathbf{B}^2\mathbb G_m$ (与 <span class="link local"><a href="./Brauer群.html" title="Brauer 群 [Brauer群]">Brauer 群</a></span>有关) 上就没有足够的拟凝聚层, 以至于仅看拟凝聚层无法将它和一个点区分开. 而 $\mathbf{B}^2\mathbb G_m$ 上能够记录其全部几何信息的是一个 “范畴值” 的拟凝聚层, 事实上是万有的 “范畴值线丛” (正如 $\mathbf{B}\mathbb G_m$ 上有万有线丛一样).</li>
<li>为了记录所有几何对象, 我们需要不断地走向范畴层级更高的代数对象, 即<span class="link local"><a href="./高阶拟凝聚层.html" title="高阶拟凝聚层 [高阶拟凝聚层]">高阶拟凝聚层</a></span>. 这就是 Gestalt 的起源.</li>
</ol>
<h2>定义</h2>
<p>Gestalt 的定义是基于一个称为 <strong>Stefanich 环</strong>的代数对象.</p>
<p>一个 Stefanich 环 $A$ 是如下资料:</p>
<ul>
<li>一个越来越高阶的<span class="link local"><a href="./可表现范畴.html" title="可表现范畴 [可表现范畴]">可表现范畴</a></span>的<span class="link local"><a href="./交换代数.html" title="交换代数 [交换代数]">交换代数</a></span>的塔
$$
      (A_0,A_1,A_2,\cdots),A_n\in \mathsf{CAlg}(n\mathsf{Pr}),
$$</li>
<li>每个部分 $A_n$ 等价于高一阶的部分 $A_{n+1}$ 的 “环路空间”:
$$
      A_n \simeq \operatorname{End}_{A_{n+1}}(1) \in \mathsf{CAlg}(n\mathsf{Pr}).
$$</li>
</ul>
<p>换言之, Stefanich 环构成的 $(\infty,1)$-范畴为
$$
\mathsf{StRing} = \operatorname{lim}_{\operatorname{End}_{-}(1)} \mathsf{CAlg}(n\mathsf{Pr}).
$$
(忽略这些范畴的高阶不可逆态射, 仅考虑其 $(\infty ,1)$-范畴结构.)</p>
<p><strong>注</strong>. 由定义中的第二个条件, Stefanich 环 $A=(A_0,A_1,A_2,\cdots)$ 的每个部分 $A_n$ 的交换代数结构实际上被高一阶的部分 $A_{n+1}$ 决定了. 进一步, 我们可以在定义中仅要求 $A_n\in n\mathsf{Pr}$, 且有等价 $A_n \simeq \operatorname{End}_{A_{n+1}}(*)$ ($A_n$ 的基点为恒等). 这样 (由 <span class="link local"><a href="./Eckmann--Hilton论证.html" title="Eckmann–Hilton 论证 [Eckmann--Hilton论证]">Eckmann–Hilton论证</a></span>) 交换代数的结构就来自于一连串等价
$$
A_n = \operatorname{End}_{A_{n+1}}(*) = \operatorname{End}_{\operatorname{End}_{A_{n+2}}(*)}(*) = \cdots.
$$</p>
<p><strong>定义</strong>. Gestalt 为 Stefanich 环的对偶: $\mathsf{Gest} = \mathsf{StRing}^{\mathrm{op}}$.</p>
<h2>性质</h2>
<p><strong>定理</strong> (<span class="link local"><a href="./ScholzeStefanichGestalten.html" title="Geometry and Higher Category Theory [ScholzeStefanichGestalten]">Scholze–Stefanich</a></span>). $\mathsf{Gest}$ 是一个 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">$\infty$-意象</a></span>.</p>
<h2>例</h2>
<p>普通的交换环 $A$ 给出一个 Stefanich 环
$$
(A,\mathsf{Mod}(A),1\mathsf{Pr}_A,2\mathsf{Pr}_A,\cdots).
$$</p>
<p>对于仿射概形范畴上适当的 Grothendieck 拓扑, 该构造即延拓至适当的叠.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Lie代数胚"><header><h1><span class="taxon">Wiki. </span>“Lie 代数胚” <a class="slug" href="./Lie代数胚.html">[Lie代数胚]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>设 $M$ 是流形, 其上的实 Lie 代数胚是一个实向量丛 $A$, 带有 Lie 括号 $[-,-]_A$, 以及丛映射 $q_A \colon  A\to TM$, 满足对 $A$ 的截面 $X,Y$, 以及 $M$ 上的函数 $f$,
$$
[X,fY]_A = f [X,Y]_A + (q_A(X)f)Y.
$$
且 $q_A$ 定义了 $A$ 的截面到 $TM$ 的截面的 Lie 代数同态.</p>
<p>设 $X$ 是概形, $L$ 是 $X$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>, 带有 Lie 括号 $[-,-]\colon  \wedge^2 L \to L$,</p>
<h2>例</h2>
<p>设 $X$ 是概形, $T_X$ 上有自然的 Lie 括号.</p>
<p>对于 Lie 代数 $\mathfrak g$ 在 $X$ 上的无穷小作用, $L = \mathfrak g\otimes \mathcal O_X$ (?)</p>
<p>无穷小自同构: 设 $E\to X$ 是向量丛, $GL(E)\to X$ 为 $GL(n)$-<span class="link local"><a href="./主丛.html" title="主齐性空间, 主丛 [主丛]">主丛</a></span>. (??)</p>
<h2>Picard 代数胚</h2>
<p>扭微分算子 (twisted differential operators) 是指 …</p>
<p>拟凝聚代数 $D$ 带有滤结构, 满足 $m (F_i D, F_jD)\subset F_{i+j}D$, $\mathcal O_X \subset F_0 D$, $F_1 D/ F_0 D \simeq T_X$.</p>
<p>扭微分算子对应 Picard 代数胚.</p>
<h2>联络</h2>
<p>Lie 代数胚上的联络是映射 $z\colon  L \to T_X$ 的截面 $\nabla\colon  T_X \to L$, 若 $\nabla$ 是 Lie 代数胚映射, 则称其为平坦联络.</p>
<p>联络的曲率 $c(\nabla) \in \operatorname{Hom}_{\mathcal O_X} (\wedge^2 T_X, \ker z)$</p>
<p>若 $L$ 为 Picard 代数胚, 则曲率 $c(\nabla) \in \Omega_X^2$.</p>
<p>联络的空间是 $\Omega^1$ 的仿射空间. 对于 $\alpha\in \Omega^1$, $c(\nabla + \alpha) = c(\nabla) + d\alpha$.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="fil-gr"><header><h1><span class="taxon">Wiki. </span>滤与分次的叠观点 <a class="slug" href="./fil-gr.html">[fil-gr]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./代数几何.html" title="代数几何 [代数几何]">代数几何</a></span></li><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>陈述</h2>
<h3>分次与半群作用</h3>
<p>设 $N$ 为交换幺半群, 则环 $A$ 上的 $N$-<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次</a></span>等同于仿射概形 $\operatorname{Spec}A$ 上的 $\operatorname{Spec}\mathbb{Z}[N]$-<span class="link local"><a href="./群作用.html" title="群作用 [群作用]">作用</a></span>. 详见<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次代数</a></span>.</p>
<p>考虑 $N=\mathbb{Z}$ 的特殊情形, 记 $\mathbb G_m = \operatorname{Spec}\mathbb{Z}[x^{\pm 1}] = \operatorname{Spec}\mathbb{Z}[\mathbb{Z}]$ 为<span class="link local"><a href="./乘法群概形.html" title="乘法群概形 [乘法群概形]">乘法群概形</a></span>. 那么环 $A$ 上的 $\mathbb{Z}$-<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次</a></span>等同于 $\mathbb G_m$ 在<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span> $\operatorname{Spec}A$ 上的<span class="link local"><a href="./群作用.html" title="群作用 [群作用]">作用</a></span>. 在<span class="link local"><a href="./相对.html" title="相对观点 [相对]">相对</a></span>情形中, <span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span> $X$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚</a></span>代数 $A$ 上的 $\mathbb{Z}$-<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次</a></span>等同于<span class="link local"><a href="./相对谱.html" title="相对谱 [相对谱]">相对谱</a></span> $\operatorname{Spec}_X A$ 上的 $\mathbb G_m$-<span class="link local"><a href="./群作用.html" title="群作用 [群作用]">作用</a></span>.</p>
<p>分次环 $A$ 上的分次模 $M$ 相当于 $\operatorname{Spec}A$ 上的 $\mathbb G_m$-等变拟凝聚层, 也即商叠 $\operatorname{Spec}A / \mathbb G_m$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>. 具体地, 考虑两个作用 $\mathrm{act},\mathrm{triv} \colon \mathbb G_m\times\operatorname{Spec}A\to\operatorname{Spec}A$, 对应两个环同态 $A\to A[x^{\pm 1}]$, 那么 $\operatorname{Spec}A$ 上的 $\mathbb G_m$-等变拟凝聚层是 $A$-模 $M$ 带有同构
$$
M\otimes_{A,\mathrm{act}}A[x^{\pm 1}] \simeq M\otimes_{A,\mathrm{triv}}A[x^{\pm 1}],
$$
这至少给出一个映射 $M \to M[x^{\pm 1}]$, 它将 $M$ 的 $n$ 次齐次元素 $m$ 映射到 $m x^n \in M[x^{\pm 1}]$.</p>
<h3>滤</h3>
<p><span class="link local"><a href="./A1-Gm.html" title="仿射直线对乘法群的商 [A1-Gm]">仿射直线对乘法群的商</a></span> $\mathbb A^1 / \mathbb G_m$</p>
<p>…</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="中山引理"><header><h1><span class="taxon">Wiki. </span>中山引理 <a class="slug" href="./中山引理.html">[中山引理]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><strong>中山引理</strong> (Nakayama lemma) 说的是<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>在<span class="link local"><a href="./局部环.html" title="“局部环” [局部环]">局部</a></span>的一些信息能由一点上的信息 (<span class="link local"><a href="./纤维函子.html" title="纤维函子 [纤维函子]">纤维函子</a></span>) 决定.</p>
<h2>陈述</h2>
<h3>一个较强的引理</h3>
<p><strong>结论</strong>. 设 $R$ 是交换环, $I\subset R$ 是理想, $M$ 是 $n$ 个元素生成的 $R$-模. 那么对任意同态 $f\colon M\to IM$, 存在 $a_1,\cdots,a_n\in I$ 使得
$$
f^n + a_1 f^{n-1} + \cdots + a_n = 0.
$$</p>
<p>这个结论是 Cayley–Hamilton 定理的直接应用.</p>
<p>考虑 $f=\mathrm{id}$, 得到如下结论.</p>
<p><strong>结论</strong>. 设 $R$ 是交换环, $I\subset R$ 是理想, $M$ 是 $n$ 个元素生成的 $R$-模, $IM = M$. 那么存在 $a\in I$ 使得
$$
(1+a) M = 0.
$$</p>
<h3>特例: 局部环与纤维</h3>
<p><strong>命题</strong>. 设 $R$ 是<span class="link local"><a href="./局部环.html" title="“局部环” [局部环]">局部环</a></span>, 极大理想为 $\mathfrak m$, 剩余域为 $k= R/\mathfrak m$. 对于有限生成 $R$-模 $M$, 若 $M / \mathfrak m M = 0$ (即 $M\otimes_R k$ = 0), 则 $M = 0$. 换言之, <span class="link local"><a href="./纤维函子.html" title="纤维函子 [纤维函子]">纤维函子</a></span>
$$
\mathsf{Mod}(R)_{\mathrm{fg}} \to \mathsf{Vect}_{k}
$$
保守.</p>
<p><em>证明</em>. 若 $M / \mathfrak m M = 0$, 则 $M = \mathfrak m M$, 而 $1 + \mathfrak m \subset R^\times$, 故前述结论给出 $M=0$.</p>
<h3>拟凝聚层消失处为开集</h3>
<p>设 $F$ 是<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span> $X$ 上的局部有限生成<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>. 定义 “$F$ 消失之处”
$U_F\colon\mathsf{Aff}^{\mathrm{op}}\to\mathsf{Set}$,
$$
	\operatorname{Spec} B\mapsto \{f\colon \operatorname{Spec} B\to X\mid f^*F\simeq 0\},
$$
则 $U_F\to X$ 为<span class="link local"><a href="./开嵌入.html" title="开嵌入 [开嵌入]">开子概形</a></span>. 事实上, $U_F$ 是理想 $\operatorname{Ann}(F)$ 对应的<span class="link local"><a href="./闭嵌入.html" title="闭嵌入 [闭嵌入]">闭子概形</a></span>的补空间.</p>
<p>等价的陈述: 设 $F$ 是概形 $X$ 上的局部有限生成<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>.
若对于某个域 $k$ 以及态射 $f\colon \operatorname{Spec} k\to X$ 有 $f^*F\simeq 0$,
则存在仿射<span class="link local"><a href="./开嵌入.html" title="开嵌入 [开嵌入]">开子概形</a></span> $j\colon U\to X$ 包含 $f$ (即 $f$ 穿过 $U$), 使得 $j^*F\simeq 0$.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="交换Hopf代数胚"><header><h1><span class="taxon">Wiki. </span>交换 Hopf 代数胚 <a class="slug" href="./交换Hopf代数胚.html">[交换Hopf代数胚]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>交换 Hopf 代数胚是<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span>范畴中的<span class="link local"><a href="./群胚.html" title="群胚 [群胚]">群胚</a></span>的<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数侧对偶</a></span>概念.</p>
<h2>定义</h2>
<p>…</p>
<h3>余模</h3>
<p>交换 Hopf 代数胚 $(A,\Gamma)$ 上的<strong>余模</strong>为 $A$-模 $M$, 带有余作用
$$
\eta \colon M \to \Gamma\otimes_A M,
$$
满足</p>
<ul>
<li>(余单位律) $M \to \Gamma\otimes_A M \to M = \operatorname{id}_M$;</li>
<li>(余结合律) $M\to \Gamma\otimes_A \Gamma\otimes_A M$ 的两个映射相等.</li>
</ul>
<h2>性质</h2>
<h3>与叠的关系</h3>
<p>一个交换 Hopf 代数胚 $(A,\Gamma)$ 也给出一个叠
$$
\mathcal M_{(A,\Gamma)}\colon \mathsf {Ring} \to \mathsf {Grpd},
$$
$$
R\mapsto \{\operatorname{Hom}_{\mathsf {Ring}}(\Gamma,R)\rightrightarrows \operatorname{Hom}_{\mathsf {Ring}}(A,R)\}.
$$</p>
<p>交换 Hopf 代数胚 $(A,\Gamma)$ 上的余模即是叠 $\mathcal M_{(A,\Gamma)}$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="仿射态射"><header><h1><span class="taxon">Wiki. </span>仿射态射 <a class="slug" href="./仿射态射.html">[仿射态射]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./代数几何.html" title="代数几何 [代数几何]">代数几何</a></span></li><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>仿射态射是<span class="link local"><a href="./相对.html" title="相对观点 [相对]">相对</a></span>版本的<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span>.</p>
<h2>定义</h2>
<p>对于<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span>的态射 $f\colon X\to Y$, 若对任意仿射开集 $U\subset Y$, 其原像 $X\times_Y U$ 为<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span>, 则称 $f$ 为<strong>仿射态射</strong>.</p>
<h2>性质</h2>
<p>仿射态射是<span class="link local"><a href="./局部性质.html" title="局部性质 [局部性质]">目标上的局部性质</a></span>, 在<span class="link local"><a href="./基变换.html" title="基变换 [基变换]">基变换</a></span>下稳定.</p>
<p><strong>定理</strong>. 对于仿射态射 $p\colon Y\to X$, 有 $p_*\mathcal O_Y$为<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚</a></span> $\mathcal O_X$-代数, 且 $Y$ 到<span class="link local"><a href="./相对谱.html" title="相对谱 [相对谱]">相对谱</a></span>的典范的映射 $Y\to\operatorname{Spec}_X(p_*\mathcal O_Y)$ 为同构.</p>
<p><strong>推论</strong>. <span class="link local"><a href="./闭嵌入.html" title="闭嵌入 [闭嵌入]">闭嵌入</a></span>都是仿射态射.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="凝聚层"><header><h1><span class="taxon">Wiki. </span>凝聚层 <a class="slug" href="./凝聚层.html">[凝聚层]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>凝聚层是将代数几何中的几何对象变为 “线性” 范畴的方式.</p>
<p><span class="link local"><a href="./凝聚概形.html" title="凝聚概形 [凝聚概形]">凝聚概形</a></span></p>
<p>Serre 的 “代数凝聚层” (FAC) 被称为 “20世纪代数几何最重要的文章”.</p>
<p>凝聚性将“点“的性质组织成为“局部“的性质. 粗略地说, 对于凝聚层, 当我们知道了一个点 $a$ 处的茎的信息, 我们就能获知与 $a$ 足够接近的点 $x$ 处茎的信息. 例如, 设凝聚层的序列 $\mathscr{F}'\to \mathscr{F} \to \mathscr{F}''$ 在一点 $a$ 处的茎是正合列, 则当 $x$ 足够接近 $a$ 时, 序列在 $x$ 处也是正合的.</p>
<p><span class="link local"><a href="./凝聚层上同调.html" title="“凝聚层上同调” [凝聚层上同调]">凝聚层上同调</a></span>是强有力的<span class="link local"><a href="./层上同调.html" title="(Abel) 层上同调 [层上同调]">层上同调</a></span>理论.</p>
<p>另见<span class="link local"><a href="./(拟)凝聚层范畴.html" title="“(拟)凝聚层范畴” [(拟)凝聚层范畴]">(拟)凝聚层范畴</a></span>.</p>
<h2>定义</h2>
<p>设 $X$ 为<span class="link local"><a href="./环化空间.html" title="环化空间 [环化空间]">环化空间</a></span>. $\mathcal O_X$-模 $F$ 称为有限型 (of finite type) 是指存在 $X$ 开覆盖, 在每个局部 $U$ 上存在满射 $\mathcal O_U^{\oplus N} \to F\big|_U$. 称其为<strong>凝聚层</strong>, 是指对任意映射 $u\colon \mathcal O_U^{\oplus N}\to F$, $\ker u$ 是有限型的. 称其为<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>, 是指存在开覆盖, 每个局部 $F\big|_U$ 有表现 $\mathcal O_{U}^{(B)}\to \mathcal O_U^{(A)} \to F$.</p>
<p><strong>定理</strong> (Oka). 复解析空间上凝聚层等价于有限型.</p>
<p><strong>命题</strong>. 若 $X$ 为 <span class="link local"><a href="./Noether概形.html" title=" [Noether概形]">Noether 概形</a></span>, 则凝聚层等价于有限型.</p>
<h2>性质</h2>
<p>凝聚层的重要性质是: 组成短正合列的三个层, 若其中两个是凝聚层, 则第三个也是凝聚层.</p>
<p>岡潔 (Oka Kiyoshi) 证明了一个深刻的结论: 复流形上的全纯函数层是凝聚层.</p>
<p>凝聚性的力量亦体现于 Cartan 定理 A 和定理 B.</p>
<h3>紧对象</h3>
<p>对于 <span class="link local"><a href="./Noether概形.html" title=" [Noether概形]">Noether 概形</a></span> $X$, 凝聚层范畴 $\mathsf{Coh}(X)$ 等同于拟凝聚层范畴 $\mathsf{QCoh}(X)$ 的<span class="link local"><a href="./紧对象.html" title="紧对象 [紧对象]">紧对象</a></span>的范畴.</p>
<h2>例</h2>
<h3>结构层</h3>
<p>凝聚层最简单的例子是结构层 $\mathcal O_X$, 对应平凡<span class="link local"><a href="./线丛.html" title="线丛 [线丛]">线丛</a></span>. 对于 $X=\operatorname{Spec}A$ 的情形, 这就是将 $A$ 视为 $A$-模.</p>
<h3>1-形式层</h3>
<p>设 $X$ 为 $k$ 上的非奇异仿射代数簇 (nonsingular affine algebraic variety), 其坐标环为 $A=k[X]$. 定义 $X$ 上的正则 1-形式 (regular differential 1-form) 是这样的 1-形式: 在每个局部 $U$ 上, 它都属于由 $df$ ($f\in k[U]$) 生成的 $k[U]$-子模. $X$ 上正则 1-形式构成的 $k[X]$-模记为 $\Omega[X]$.</p>
<p>可以证明, 若 $u_1,\cdots,u_n$ 是代数簇 $X$ 上 $x$ 附近的局部坐标, 那么存在仿射邻域 $U$, 使得 $\Omega[U]$ 作为 $k[U]$-模由 $du_1,\cdots ,du_n$ 生成.</p>
<p>定义 $X$ 的微分模 (module of differentials) $\Omega=\Omega[X]$. 可以证明 $\Omega$ 由 $df$ ($f$ 是 $X$ 上的正则函数) 生成.</p>
<p>记 $\Omega_X^1$ 为 $X$ 上的正则 $1$-形式层.</p>
<p>对于 $k$ 上的有限型 (finite type) 概形 $X$, 我们可类似地定义 $\Omega_X^1$.</p>
<h3>闭子簇</h3>
<p>对于闭子簇 $i\colon Y\to X$, $Y$ 上的向量丛 $E$ 的<span class="link local"><a href="./直像.html" title="“直像” [直像]">直像</a></span> $i_* E$ 是 $X$ 上的凝聚层. 这样, 一些关于闭子簇的问题可用凝聚层表达.</p>
<p>另见<span class="link local"><a href="./理想层.html" title="理想层 [理想层]">理想层</a></span>.</p>
<h3>重言层</h3>
<p><span class="link local"><a href="./射影空间.html" title="射影空间 (代数几何) [射影空间]">射影空间</a></span> $\mathbb P=\mathbb P(V)$ 上的可逆层 $\mathcal O_{\mathbb P}(1)$ 是<span class="link local"><a href="./重言线丛.html" title=" [重言线丛]">重言丛</a></span> (tautological line bundle) 上线性形式 (linear form) 的层. 其全局截面 $H^0(\mathbb P,\mathcal O_{\mathbb P}(1))$ 为 $V$ 上的线性形式的空间 $V^*$.</p>
<blockquote>
<p>注. 重言丛的截面层为什么是 $\mathcal O(-1)$: 以 $V=\mathbb{C}^{n+1}$ 为例. 分次模 $\mathbb{C}[x_0,\cdots,x_n](1)$ 以 $x_0,\cdots,x_n$ 为 $0$ 阶元素, 对应的 $\mathcal O(1)$ 以 $x_0,\cdots,x_n$ 为全局截面, 它们是 $V$ 上的线性函数. 故重言丛是 $\mathcal O(1)$ 的对偶, 即 $\mathcal O(-1)$.</p>
</blockquote>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="凝聚层的导出范畴"><header><h1><span class="taxon">Wiki. </span>凝聚层的导出范畴 <a class="slug" href="./凝聚层的导出范畴.html">[凝聚层的导出范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><span class="link local"><a href="./凝聚层.html" title="凝聚层 [凝聚层]">凝聚层</a></span>的<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span></p>
<p>向量丛不能做同调, 因为向量丛的范畴不是 Abel 范畴 (例如向量丛的态射的核不一定是向量丛).</p>
<p>复流形上的向量丛相当于局部自由凝聚层<span class="link local"><a href="./凝聚层.html" title="凝聚层 [凝聚层]">凝聚层</a></span>构成 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span>, 可以做同调; 而<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>是同调代数的合适的语言.</p>
<h2>定义</h2>
<p>记 $D^b(X):= D^b(\mathsf{Coh}(X))$ 为 $X$ 上凝聚层的有界<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>.</p>
<p>对于两个 $k$-概形 $X,Y$, 若存在 $k$-线性的三角范畴等价 $D^b(X)\simeq D^b(Y)$, 则称 $X$, $Y$ <span class="link local"><a href="./导出等价.html" title=" [导出等价]">导出等价</a></span>.</p>
<h2>拟凝聚层</h2>
<p>由于缺少内射对象, 需要考虑更大的范畴, 即<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span> $\mathsf {Qcoh}(X)$ 的导出范畴. (对于 <span class="link local"><a href="./Noether概形.html" title=" [Noether概形]">Noether 概形</a></span> $X$, 后者有足够多内射对象.)</p>
<p><strong>命题</strong>. 对 $*=+,-,b$, $D^*(\mathsf {Qcoh}(X)) \simeq D^*_{\mathsf {Qcoh}}(\mathcal O_X\mathsf {-Mod})$, 其中后者表示 $D^*(\mathcal O_X\mathsf {-Mod})$ 中具有拟凝聚同调的 $\mathcal O_X$ 模复形的子范畴.</p>
<h2>性质</h2>
<h3>不可分解性</h3>
<p><strong>定义</strong>. <span class="link local"><a href="./三角范畴.html" title="“三角范畴” [三角范畴]">三角范畴</a></span> $D$ <strong>可分解</strong>是指存在两个非空的子三角范畴 $D_1,D_2$, 互相没有非零态射, 且 $D$ 中的元素 $C$ 总可放进特殊三角 $A\to C\to B\to A[1]$, $A\in D_1,B\in D_2$.</p>
<p><strong>命题</strong>. $D^b(X)$ 不可分解当且仅当 $X$ 连通.</p>
<p><strong>引理</strong>. 对于 $\mathcal F^\bullet\in D^b(X)$, 若 $\operatorname{supp}\mathcal F^\bullet:= \bigcup_i \operatorname{supp}(\mathcal H^i(\mathcal F^\bullet))$ (见<span class="link local"><a href="./支集.html" title=" [支集]">支集</a></span>) 等于两个不交闭集 $Z_1,Z_2$ 的并, 则 $\mathcal F^\bullet$ 可写为 $\mathcal F_1^\bullet \oplus \mathcal F_2^\bullet$, 其中 $\operatorname{supp}(\mathcal F_i^\bullet) = Z_i$. (类似于环的中心幂等元分解.)</p>
<h3>重构</h3>
<p>由导出范畴与自等价群可重构出代数簇本身 (Bondal, Orlov).</p>
<p>当 $\omega_X$ 丰沛 (这可以推出 $X$ 是 “一般类型”, general type) 或 $\omega_X^{-1}$ 丰沛 (即 $X$ 是 <span class="link local"><a href="./Fano簇.html" title="“Fano 簇” [Fano簇]">Fano 簇</a></span>) 时, 由 $D^b_{\mathsf {coh}}(X)$ 可重构 $X$.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="几何Langlands对应"><header><h1><span class="taxon">Wiki. </span>几何 Langlands 对应 <a class="slug" href="./几何Langlands对应.html">[几何Langlands对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<blockquote>
<p>Recently, in a groundbreaking advance, Kapustin and Witten have linked the geometric Langlands correspondence and the S-duality of 4D supersymmetric gauge theories. This and subsequent works have already led to striking new insights into the geometric Langlands Program, which in particular involve the Homological Mirror Symmetry of the Hitchin moduli spaces of Higgs bundles on algebraic curves associated to two Langlands dual Lie groups.</p>
</blockquote>
<p><span class="link local"><a href="./Hitchin模叠.html" title="“Hitchin 模叠” [Hitchin模叠]">Hitchin 模叠</a></span></p>
<p><span class="link local"><a href="./Galois表示.html" title=" [Galois表示]">Galois 表示</a></span>理解为 <span class="link local"><a href="./l-进局部系统.html" title=" [l-进局部系统]">l-进层</a></span>.</p>
<p>非分歧<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span>给出 $\mathrm{GL}_n(F) \backslash \mathrm{GL}_n(\mathbb A) / \mathrm{GL}_n(\mathcal O)$ 上的函数 $f_\pi$ (差一个常数), 它是 <span class="link local"><a href="./Hecke代数.html" title=" [Hecke代数]">Hecke 代数</a></span> $\mathcal H_x, x\in X$ 的特征函数. 使用 <span class="link local"><a href="./Grothendieck函数–层字典.html" title="“Grothendieck 函数–层字典” [Grothendieck函数–层字典]">Grothendieck 函数–层字典</a></span>,</p>
<h2>范畴式几何 Langlands 对应</h2>
<p>范畴式几何 Langlands 对应的主旨是两个 <span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">DG 范畴</a></span>的比较:</p>
<ul>
<li>几何 (“自守”) 侧, 即 $X$ 上 $G$-丛的<span class="link local"><a href="./模叠.html" title=" [模叠]">模空间</a></span>上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>;</li>
<li>谱 (“Galois”) 侧, 即 $X$ 上 $\check G$-<span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span>的叠上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>.</li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="射影丛"><header><h1><span class="taxon">Wiki. </span>射影丛 <a class="slug" href="./射影丛.html">[射影丛]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>射影丛是<span class="link local"><a href="./射影空间.html" title="射影空间 (代数几何) [射影空间]">射影空间</a></span>的<span class="link local"><a href="./相对.html" title="相对观点 [相对]">相对</a></span>版本, 是<span class="link local"><a href="./相对射影谱.html" title="相对射影谱 [相对射影谱]">相对射影谱</a></span>的重要例子.</p>
<h2>定义</h2>
<h3>代数几何</h3>
<p>设 $E$ 是概形 $Y$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>. 定义其<strong>射影丛</strong>为对称代数的<span class="link local"><a href="./相对射影谱.html" title="相对射影谱 [相对射影谱]">相对射影谱</a></span>
$$
P_Y(E):= \operatorname{Proj}_Y(\operatorname{Sym}_{\mathcal O_Y}E).
$$</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./Segre嵌入.html" title="Segre 嵌入 [Segre嵌入]">Segre 嵌入</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="射影谱上的拟凝聚层"><header><h1><span class="taxon">Wiki. </span>射影谱上的拟凝聚层 <a class="slug" href="./射影谱上的拟凝聚层.html">[射影谱上的拟凝聚层]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./代数几何.html" title="代数几何 [代数几何]">代数几何</a></span></li><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $R$ 为 $\mathbb{Z}_{\geq 0}$-<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次环</a></span>, $M$ 为 $\mathbb{Z}$-分次 $R$-模. 考虑 $\operatorname{Spec}R$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span> $\widetilde {M}$, 限制在 $\operatorname{Spec}R$ 的开子空间
$$
\operatorname{Spec}^\circ R :=
\operatorname{Spec}R \setminus \operatorname{Spec}R_0=\bigcup_{f\in R_+} U(f).
$$
常常假设 $R_+$ 由 $R_1$ 生成, 因而
$$
\operatorname{Spec}^\circ R = \bigcup_{f\in R_1} U_+(f).
$$</p>
<p>有典范的拓扑空间映射 $\pi\colon \operatorname{Spec}^\circ R\to\operatorname{Proj}R$ (见<span class="link local"><a href="./射影谱.html" title="射影谱 [射影谱]">射影谱</a></span>).
定义<strong>射影谱上的拟凝聚层</strong> $\widetilde {M}\in\mathsf{QCoh}(\operatorname{Proj}R)$ 为其推前的零次部分:
$$
\widetilde {M} := \big[\pi_*(\widetilde {M}|_{\operatorname{Spec}^\circ R})\big]_0 \in \mathsf{QCoh}(\operatorname{Proj}R).
$$</p>
<p>由构造,
$$
\widetilde {M}|_{U_+(f)} \simeq \widetilde {M_{(f)}}\in\mathsf{QCoh}(U_+(f)),
$$
其中 $M_{(f)} := (M_f)_0$.</p>
<h3>通过商叠</h3>
<p>环 $S$ 上的<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次</a></span>相等于 $\operatorname{Spec}S$ 上的 $\mathbb G_m$-作用. 分次环 $S$ 上的 $\mathbb{Z}$-分次模相当于商叠 $\operatorname{Spec}S / \mathbb G_m$ 上的拟凝聚层.</p>
<p>… (todo)</p>
<h2>例</h2>
<p>分次环 $R$ 自身作为 $R$-模给出的 $\operatorname{Proj}R$ 上的拟凝聚层就是结构层 $\mathcal O_{\operatorname{Proj}R}$.</p>
<h3>移位</h3>
<p>对于 $\mathbb{Z}$-分次 $R$-模 $M$, 记 $M(n)$ 为如下 $\mathbb{Z}$-分次 $R$-模: 其底层 $R$-模为 $M$, 分次为
$M(n)_m = M_{n+m}$. 移位等同于与 $R(n)$ 作张量积: $M(n) = M \otimes_R R(n)$.</p>
<p>记 $R(n)$ 对应的 $\operatorname{Proj}R$ 上的拟凝聚层为
$$
\mathcal O(n) := \widetilde {R(n)}.
$$</p>
<h2>性质</h2>
<p>假设 $R_+$ 由 $R_1$ 生成.</p>
<p><strong>命题</strong>. 函子 $\mathsf{Mod}^{\mathrm{gr}}(R) \to \mathsf{QCoh}(\operatorname{Proj}R)$, $M\mapsto \widetilde {M}$ 为正合函子且保持余极限.</p>
<h3>张量积</h3>
<p><strong>命题</strong>. 设 $M$, $N$ 为分次 $R$-模, 则有 $\mathsf{QCoh}(\operatorname{Proj}R)$ 中的同构
$$
\widetilde {M} \otimes_{\mathcal O} \widetilde N \simeq \widetilde {M\otimes_R N}.
$$
换言之, $M\mapsto \widetilde M$ 是<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半函子</a></span>.</p>
<h3>截面</h3>
<p><strong>命题</strong>. 函子 $\widetilde{(-)} \colon \mathsf{Mod}^{\mathrm{gr}}(R) \to \mathsf{Mod}(\mathcal O)$ 与 $\Gamma^{\mathrm{gr}}\colon \mathsf{Mod}(\mathcal O)\to \mathsf{Mod}^{\mathrm{gr}}(R)$ 构成一对伴随 $\widetilde{(-)}\dashv\Gamma^{\mathrm{gr}}$.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="拟凝聚层的忠实平坦下降"><header><h1><span class="taxon">Wiki. </span>拟凝聚层的忠实平坦下降 <a class="slug" href="./拟凝聚层的忠实平坦下降.html">[拟凝聚层的忠实平坦下降]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>拟凝聚层的忠实平坦下降, 说的是<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>函子 $\mathsf{QCoh} \colon \mathsf{Sch} \to \mathsf{Cat}$ 是<span class="link local"><a href="./平坦景.html" title="平坦景 [平坦景]">平坦拓扑</a></span>的<span class="link local"><a href="./景上的层.html" title="景上的层 [景上的层]">层</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="概形闭包"><header><h1><span class="taxon">Wiki. </span>概形闭包 <a class="slug" href="./概形闭包.html">[概形闭包]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./代数几何.html" title="代数几何 [代数几何]">代数几何</a></span></li><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $i\colon Y\to X$ 是<span class="link local"><a href="./拟紧态射.html" title="拟紧态射 [拟紧态射]">拟紧</a></span>的<span class="link local"><a href="./局部闭嵌入.html" title="局部闭嵌入 [局部闭嵌入]">局部闭嵌入</a></span>. 那么 $i_*\mathcal O_Y$ 是<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚</a></span> $\mathcal O_X$-模. 考虑理想
$$
\mathcal I = \ker (\mathcal O_X \to i_*\mathcal O_Y).
$$
定义 $Y$ 的<strong>概形闭包</strong> (scheme-theoretic closure) 为商代数的<span class="link local"><a href="./相对谱.html" title="相对谱 [相对谱]">相对谱</a></span>
$$
\overline{Y} := \operatorname{Spec}_X (\mathcal O_X / \mathcal I).
$$
由<span class="link local"><a href="./相对谱.html" title="相对谱 [相对谱]">相对谱</a></span>的性质, 代数同态 $\mathcal O_X / \mathcal I \to i_*\mathcal O_Y$ 给出 $X$-概形的映射 $Y \to \overline{Y}$.</p>
<h2>性质</h2>
<p><strong>命题</strong>. 设 $i\colon Y\to X$ 是<span class="link local"><a href="./拟紧态射.html" title="拟紧态射 [拟紧态射]">拟紧</a></span>的<span class="link local"><a href="./局部闭嵌入.html" title="局部闭嵌入 [局部闭嵌入]">局部闭嵌入</a></span>, 则 $Y\to \overline{Y}$ 是开嵌入.</p>
<p><em>证明</em>. 设 $i \colon Y\to X$ 是一个<span class="link local"><a href="./闭嵌入.html" title="闭嵌入 [闭嵌入]">闭嵌入</a></span> $i'\colon Y\to U$ 后接一个开嵌入 $U\to X$.</p>
<p>因为 $U\to X$ 为开嵌入, 所以 $(i_*\mathcal O_Y)|_U = i'_*\mathcal O_Y$.</p>
<p>因为 $i'_*$ 为闭嵌入, $\mathcal O_U \to i'_*\mathcal O_Y$ 为 (集合值层的) 满射. 又 $\ker (\mathcal O_U \to i'_*\mathcal O_Y) = \ker (\mathcal O_X \to i_*\mathcal O_Y)|_U = \mathcal I|_U$,
故
$$
i'_*\mathcal O_Y=\mathcal O_U / \mathcal I|_U= (\mathcal O_X /\mathcal I)|_U.
$$
那么
$$
\begin{aligned}
\overline{Y}\times_X U
&amp;\simeq\operatorname{Spec}_U ((\mathcal O_X /\mathcal I)|_U)\\
&amp;\simeq\operatorname{Spec}_U (i'_*\mathcal O_Y)\\
&amp;\simeq Y.
\end{aligned}
$$
因此 $Y\to\overline{Y}$ 是 $U\to X$ 的<span class="link local"><a href="./基变换.html" title="基变换 [基变换]">基变换</a></span>, 从而是开嵌入.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="淡中对偶"><header><h1><span class="taxon">Wiki. </span>淡中对偶 <a class="slug" href="./淡中对偶.html">[淡中对偶]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>陈述</h2>
<h3>对称幺半线性范畴</h3>
<p>固定代数闭域 $k$ 作为基域, 定义<strong>淡中范畴</strong> (Tannakian category) 为<span class="link local"><a href="./紧生成范畴.html" title="紧生成范畴 [紧生成范畴]">紧生成</a></span>的<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半</a></span> $k$-线性 <span class="link local"><a href="./Abel范畴.html" title="Abel 范畴 [Abel范畴]">Abel 范畴</a></span>, 满足 $\operatorname{End}(1)\simeq k$. 那么仿射群概形 (的分类叠) 对偶于淡中范畴:</p>
<ul>
<li>对于仿射群概形 $G$ 的<span class="link local"><a href="./分类叠.html" title="分类叠 (模叠) [分类叠]">分类叠</a></span> $X = * / G$, 其上<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>的范畴 $\mathsf{QCoh}(X) = \mathsf{Rep}(G)$ 为淡中范畴;</li>
<li>对于淡中范畴 $(\mathcal C,\otimes)$, 叠 $A \mapsto \mathsf{Fun}^{\otimes, \mathrm{colim}} (\mathcal C,\mathsf{Mod}(A))$ 为某代数群的分类叠.</li>
</ul>
<h3>充实范畴</h3>
<p>设 $\mathcal V$ 为<span class="link local"><a href="./闭范畴.html" title="闭范畴 [闭范畴]">闭</a></span><span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>, $A$ 为其中的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">幺半群</a></span>, 其对应一个 $\mathcal V$-<span class="link local"><a href="./充实范畴.html" title="充实范畴 [充实范畴]">充实范畴</a></span> $\mathbf{B}A$; 记 $A$-模范畴为
$$
\mathsf{Mod}(A) := [\mathbf{B}A, \mathcal V].
$$
将 $\mathcal V$-充实函子 $\mathbf{B}A\to\mathcal V$ 取值于 $\mathbf{B}A$ 的唯一对象, 给出遗忘函子 (即所谓<strong>纤维函子</strong>)
$$
F \colon \mathsf{Mod}(A)\to\mathcal V.
$$</p>
<p><strong>定理</strong>. 由函子 $F$ 可重构出代数 $A$:
$$
\operatorname{End}(F) \simeq A.
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="相对射影谱"><header><h1><span class="taxon">Wiki. </span>相对射影谱 <a class="slug" href="./相对射影谱.html">[相对射影谱]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./代数几何.html" title="代数几何 [代数几何]">代数几何</a></span></li><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>相对射影谱是<span class="link local"><a href="./射影谱.html" title="射影谱 [射影谱]">射影谱</a></span>的<span class="link local"><a href="./相对.html" title="相对观点 [相对]">相对</a></span>版本.</p>
<h2>定义</h2>
<p>设 $S$ 是<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span> $Y$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚</a></span> $\mathbb{Z}_{\geq 0}$-<span class="link local"><a href="./分次代数.html" title="分次代数 [分次代数]">分次 $\mathcal O_Y$-代数</a></span>. 定义其相对射影谱 $\operatorname{Proj}_Y(S)$ 为 $Y$ 上的概形, 使得对于仿射开集 $U\subset Y$, $\operatorname{Proj}_Y(S)|_U\simeq\operatorname{Proj}(S(U))$.</p>
<h3>函子式</h3>
<p>相对射影谱 $\operatorname{Proj}(S)$ 表示的函子
$\operatorname{Proj}(S) \colon \mathsf{Sch}_{/Y}^{\mathrm{op}} \to \mathsf{Set}$ 为
$$
(p\colon X\to Y) \mapsto \{(L\colon X\,\text{上的线丛},\psi\colon p^*S \twoheadrightarrow \operatorname{Sym}_{\mathcal O_X}L)\}/\text{同构}.
$$
注意 $\psi\colon p^*S \twoheadrightarrow \operatorname{Sym}_{\mathcal O_X}L$ 为满射等价于 $\psi_1\colon S_1\to L$ 为满射.</p>
<h2>性质</h2>
<h3>基变换相容性</h3>
<p><strong>命题</strong>. 设 $f\colon Y' \to Y$ 为概形映射, 则有
$$
\operatorname{Proj}_Y(S)\otimes_Y Y' \simeq\operatorname{Proj}_{Y'}(f^*S).
$$</p>
<h2>例</h2>
<p>概形 $X$ 上<span class="link local"><a href="./线丛.html" title="线丛 [线丛]">线丛</a></span>的相对射影谱就是 $X$ 自身.</p>
<p>对于<span class="link local"><a href="./向量丛.html" title="向量丛 [向量丛]">向量丛</a></span> $E$, $\operatorname{Proj}\operatorname{Sym}_{\mathcal O_X}E = P(E)$ 是其<span class="link local"><a href="./射影丛.html" title="射影丛 [射影丛]">射影丛</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="高阶拟凝聚层"><header><h1><span class="taxon">Wiki. </span>高阶拟凝聚层 <a class="slug" href="./高阶拟凝聚层.html">[高阶拟凝聚层]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>高阶拟凝聚层是<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>的<span class="link local"><a href="./范畴化.html" title="范畴化 [范畴化]">范畴化</a></span>. 正如拟凝聚层是环上的模的推广, 高阶拟凝聚层也是环上的 “<span class="link local"><a href="./高阶模.html" title="高阶模 [高阶模]">高阶模</a></span>” 的推广.</p>
<p><span class="link local"><a href="./StefanichHigherQCoh.html" title="Higher Quasicoherent Sheaves [StefanichHigherQCoh]">Germán Stefanich 的博士论文</a></span>发展了高阶拟凝聚层的理论.</p>
<h2>定义</h2>
<p>定义预叠上的 “拟凝聚 $(n-1)$-范畴层” 构成的 $n$-范畴
$$
n\mathsf{QCoh} \colon \mathsf{PreStk}^{\mathrm{op}} \to n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}}
$$
是 “$n$ 重模范畴”
$$
\mathrm{Mod}^n \colon \mathsf{Aff}^{\mathrm{op}}=\mathsf{CAlg}(\mathsf{Sp})_{\mathrm{conn}} \to n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}}
$$
沿米田嵌入 $\mathsf{Aff}\to \mathsf{PreStk}$ 的右 <span class="link local"><a href="./Kan扩张.html" title="Kan 扩张 [Kan扩张]">Kan 扩张</a></span>, 从而
$$
n\mathsf{QCoh}(X) = \operatorname{lim}_{S\in\mathsf{Aff}_{/X}}n\mathsf{QCoh}(S)
$$</p>
<h2>性质</h2>
<h3>拉回与推前</h3>
<p>高阶拟凝聚层的拉回, 推前等等操作可体现为<span class="link local"><a href="./高阶关系范畴.html" title="高阶关系范畴 [高阶关系范畴]">关系 $n$-范畴</a></span> $n\mathsf{Corr}(\mathsf{Aff})$, $n\mathsf{Corr}(\mathsf{PreStk})$ 出发的函子.</p>
<p><strong>定理</strong> (仿射概形的情形, <span class="link local"><a href="./StefanichHigherQCoh.html" title="Higher Quasicoherent Sheaves [StefanichHigherQCoh]">Stefanich</a></span> 定理 14.1.4).
函子 $n\mathsf{QCoh}\colon \mathsf{Aff}^{\mathrm{op}} \to n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}}$ 升级为对称幺半函子
$$
(n+1)\mathsf{Corr}(\mathsf{Aff}) \to (n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}})^{(n+1)\text{-}\mathrm{op}}.
$$</p>
<p><strong>定理</strong> (预叠的情形, <span class="link local"><a href="./StefanichHigherQCoh.html" title="Higher Quasicoherent Sheaves [StefanichHigherQCoh]">Stefanich</a></span> 定理 14.2.9).
对于 $n\geq 2$,
函子 $n\mathsf{QCoh}\colon \mathsf{PreStk}^{\mathrm{op}} \to n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}}$ 升级为
$$
n\mathsf{Corr}(\mathsf{PreStk}) \to (n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}})^{(n+1)\text{-}\mathrm{op}}.
$$</p>
<h3>下降</h3>
<p><strong>定理</strong>. 对于 $n\geq 1$, 函子 $n\mathsf{QCoh} \colon \mathsf{Aff}^{\mathrm{op}} \to n\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}}$ 是<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展拓扑</a></span>的层.</p>
<h3>整体截面</h3>
<p>对仿射概形 $X$, 沿其到终对象的映射 $X\to \operatorname{Spec}(\mathbb S)$ 的推前称为 “整体截面” 函子
$$
\Gamma(X,-) \colon n\mathsf{QCoh}(X) \to (n-1)\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}}
$$</p>
<p>有一个术语衡量一个预叠 $X$ 上的高阶拟凝聚层的整体截面能否决定 $X$ 的所有几何信息, 称为<span class="link local"><a href="./高阶仿射性.html" title="高阶仿射性 [高阶仿射性]">高阶仿射性</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="高阶模"><header><h1><span class="taxon">Wiki. </span>高阶模 <a class="slug" href="./高阶模.html">[高阶模]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>高阶模是 “环上的<span class="link local"><a href="./结合代数上的模.html" title="结合代数上的模 [结合代数上的模]">模</a></span>” 这一概念的<span class="link local"><a href="./范畴化.html" title="范畴化 [范畴化]">范畴化</a></span>.</p>
<p>正如环 $A$ 上的模是其谱 $\operatorname{Spec} A$ 上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>, 环 $A$ 上的高阶模是 $\operatorname{Spec} A$ 上的<span class="link local"><a href="./高阶拟凝聚层.html" title="高阶拟凝聚层 [高阶拟凝聚层]">高阶拟凝聚层</a></span>.</p>
<h2>定义</h2>
<p>一般地, <span class="link local"><a href="./交换代数.html" title="交换代数 [交换代数]">交换代数</a></span> $A$ 上的模范畴 $\mathsf{Mod} (A)$ 仍是交换代数, 从而可以继续考虑其上的模. 环 $A$ 上的 $n$ 阶模范畴便是 “取模范畴” 操作的 $n$ 次迭代: “$\mathsf{Mod}^n (A) = \mathsf{Mod} (\mathsf{Mod}^{n-1} (A))$”.</p>
<p>为了明确上述定义所在的范畴, 我们需要<span class="link local"><a href="./高阶可表现范畴.html" title="高阶可表现范畴 [高阶可表现范畴]">高阶可表现范畴</a></span>的概念. 记 $n\mathsf{Pr}$ 为可表现 $n$-范畴的范畴.</p>
<h3>环上的高阶模范畴</h3>
<p><strong>约定</strong>. 这里的 $n$-范畴是指 $(\infty ,n)$-范畴, 环是指 <span class="link local"><a href="./E∞-环.html" title="“E∞-环” [E∞-环]">E∞-环</a></span>, 环上的模范畴 $\mathsf{Mod}(A)$ 在传统情形中称为<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span> $D(A)$. 暂且忽略基数的大小问题.</p>
<p><strong>定义</strong> ($A$-线性可表现范畴). 对于交换环 $A$, 考虑 $A$-模范畴 $\mathsf{Mod}(A) \in \mathsf{CAlg}(1\mathsf{Pr})$. 定义 “$A$-线性<span class="link local"><a href="./可表现范畴.html" title="可表现范畴 [可表现范畴]">可表现范畴</a></span>” 构成的对称幺半可表现 $2$-范畴
$$
1\mathsf{Pr}_A = \mathsf{Mod}_{1\mathsf{Pr}}(\mathsf{Mod}(A)) \in \mathsf{CAlg}(2\mathsf{Pr}),
$$
归纳地定义 “$A$-线性可表现 $n$-范畴” 构成的对称幺半可表现 $(n+1)$-范畴
$$
n\mathsf{Pr}_A = \mathsf{Mod}_{n\mathsf{Pr}}((n-1)\mathsf{Pr}_A)\in \mathsf{CAlg}((n+1)\mathsf{Pr}).
$$</p>
<h3>可表现范畴上的高阶模范畴</h3>
<p><strong>定义</strong> ($C$-线性可表现范畴). 更一般地, 对于 $C \in \mathsf{CAlg}(1\mathsf{Pr})$, 也可定义
$$
1\mathsf{Pr}_C = \mathsf{Mod}_{1\mathsf{Pr}}(C) \in \mathsf{CAlg}(2\mathsf{Pr}),
$$
并归纳定义
$$
n\mathsf{Pr}_C = \mathsf{Mod}_{n\mathsf{Pr}}((n-1)\mathsf{Pr}_C) \in \mathsf{CAlg}((n+1)\mathsf{Pr}).
$$</p>
</details></section></details></section></footer></article></div></body></html>