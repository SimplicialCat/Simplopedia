<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>“K-群 (拓扑)”</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="K-群(拓扑)"><header><h1><span class="taxon">Wiki. </span>“K-群 (拓扑)” <a class="slug" href="./K-群(拓扑).html">[K-群(拓扑)]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li><li class="meta-item">相对 K-群</li></ul></div></header></summary>

<p>K-群是<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span>的研究对象.</p>
<h2>定义</h2>
<p>拓扑空间 $X$ 上的<span class="link local"><a href="./复向量丛.html" title="“复向量丛” [复向量丛]">复向量丛</a></span>的同构类 $V(X)$ 在 Whitney 和下构成交换半群, 而 $K(X)$ 可定义为其群化.</p>
<p>由向量丛的拉回, $X\mapsto K(X)$ 是拓扑空间范畴到 Abel 群范畴的反变函子.</p>
<p>注意到 $K(\mathrm{pt})\simeq\mathbb Z$, 而平凡投影 $p\colon X\to \mathrm{pt}$ 诱导了同态 $p^*\colon K(\mathrm{pt})\to K(X)$. 若选定 $X$ 的基点 $j\colon \mathrm{pt}\to X$, 则 $p^*$ 为 $j^*\colon K(X)\to K(\mathrm{pt})$ 的截面, 即有直和分解
$$
K(X)\simeq \widetilde{K}(X)\oplus\mathbb Z.
$$
其中 $\widetilde{K}(X)$ 称为<span class="link local"><a href="./约化K-群.html" title=" [约化K-群]">约化 K-群 (拓扑)</a></span>. (更多定义见此页面.)</p>
<p>另见 <span class="link local"><a href="./Grothendieck群.html" title="“Grothendieck 群” [Grothendieck群]">Grothendieck 群</a></span>.</p>
<h3>等价定义: 向量丛的复形</h3>
<p>考虑 $X$ 上向量丛的链复形, 定义复形的<strong>支集</strong> (support) 为不正合的点的集合. 我们只考虑<strong>紧支集</strong>的复形.</p>
<p>定义 $X$ 上向量丛复形 $E$ 到 $F$ 的同伦为 $X\times I$ 上的复形 $G$, 使得 $G$ 限制在 $X\times 0$ 和 $X\times 1$ 上分别是 $E$ 和 $F$.</p>
<p>复形的同伦类 $C(X)$ 构成半群, 其中正合 (支集为空) 的复形构成子半群 $C_\varphi (X)$; 定义 $K(X)$ 为商半群 $C(X)/C_\varphi(X)$. 虽然由定义它只是半群, 但事实上它是群.</p>
<h2>性质</h2>
<p>$K(X)$ 只与 $X$ 的伦型有关.</p>
<h2>相对 K-群</h2>
<p>对于满足同伦扩张性质的空间对 $(X,A)$, 定义<span class="link local"><a href="./相对.html" title="相对观点 [相对]">相对</a></span> <span class="link local"><a href="./K-群.html" title=" [K-群]">相对 K-群 (拓扑)</a></span>
$$
K(X,A):= \widetilde{K}(X/A).
$$</p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Bismut超联络"><header><h1><span class="taxon">Wiki. </span>“Bismut 超联络” <a class="slug" href="./Bismut超联络.html">[Bismut超联络]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>设 $S$ 是紧流形, $\pi\colon W\to S$ 是纤维丛, 纤维为紧可定向流形 $Z$.</p>
<p>记 $TZ=\ker \pi_*$ 为相对切丛, 选取水平切丛 $T^HW$ 使得 $TW= T^HW \oplus TZ$. 记 $P^{TZ}$ 为 $TW$ 到 $TZ$ 的投影.</p>
<p>设 $g^{TS},g^{TZ}$ 分别为 $TZ$, $TS$ 上的 Riemann 度量, 定义 $TW$ 上的 Riemann 度量
$$
g^{TW} := \pi^* g^{TS} \oplus g^{TZ}.
$$
考虑 <span class="link local"><a href="./Levi-Civita联络.html" title="“Levi-Civita 联络” [Levi-Civita联络]">Levi-Civita 联络</a></span> $\nabla^{TW}$ 和 $\nabla^{TS}$.</p>
<p>定义
$$
\nabla^{TZ} = P^{TZ} \nabla^{TW} P^{TZ},
$$
那么 $\nabla^{TZ}$ 保持 $g^{TZ}$, 且在每个纤维 $Z_b$ 上 $\nabla^{TZ}$ 为 $Z_b$ 上的 Levi-Civita 联络.
定义
$$
^0\nabla^{TW}:= \pi^* \nabla^{TS} \oplus \nabla^{TZ}.
$$
$^0\nabla^{TW}$ 保持度量, 但不是 Levi-Civita 联络, 也即有<span class="link local"><a href="./挠.html" title=" [挠]">挠</a></span>. 记
$$
T(A,B)= {^0\nabla_A^{TW}} B - {^0\nabla_B^{TW}} A - [A,B].
$$</p>
<p>记 $\mathsf S = \nabla^{TW}-{^0\nabla^{TW}}$ 为两个联络的差.</p>
<p>设 $(\mathcal E,h^{\mathcal E},\nabla^{\mathcal E})$ 为 Clifford 代数丛 $\mathrm{Cl}(TZ)$ 的模. 设 $\{e_i\}$ 为 $TZ$ 的标准正交标架, 定义 <span class="link local"><a href="./Dirac算子.html" title="Dirac 算子 [Dirac算子]">Dirac 算子</a></span>
$$
D^Z = \sum_i c(e_i) \nabla_{e_i}^{\mathcal E}
$$
研究 $\ker D_+$ 与 $\ker D_-$ 在 <span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>中的差.
$$
\operatorname{Ind}(D^Z) = \ker D_+ - \ker D_- \in K^0(S).
$$</p>
<p><strong>定理</strong> (族指标定理, family index theorem)
$$
\operatorname{ch}(\operatorname{Ind}(D^Z)) = \int_Z \widehat A (TZ) \operatorname{ch}(\mathcal E / S).
$$</p>
<p>Bismut 的想法: 考虑 $S$ 上的无穷维向量丛 $C^\infty (Z,\mathcal E)$ 的截面空间
$$
\mathscr E = C^\infty (S,C^\infty (Z,\mathcal E)).
$$
定义 $C^\infty (Z,\mathcal E)$ 上的 Riemann 度量: 对 $b$ 处的两个向量 $s_1,s_2\in C^\infty (Z_b,\mathcal E)$,
$$
\langle  s_1,s_2\rangle := \int_{Z_b} \langle  s_1(x), s_2(x)\rangle_{\mathcal E} dV_{Z}.
$$</p>
<p>定义 $C^\infty (Z,\mathcal E)$ 上的联络如下. 对 $h\in\mathscr E$ 以及 $S$ 上的向量场 $U$,
$$
\nabla^{\mathscr E}_U h = \nabla_{U^H}^{\mathcal E} h,
$$
其中 $U^H$ 表示 $U$ 在 $W$ 上的唯一水平提升.
$$
\nabla_U^{\mathscr E,U} := \nabla_U^{\mathscr E} - \frac{1}{2} \langle \mathsf S(e_i)e_i,U \rangle,
$$
则联络 $\nabla_U^{\mathscr E,H}$ 保持度量.</p>
<p>令
$$
c(T):= \frac{1}{2} c(T (f_p^H, f_q^H)) f^p \wedge f^q \wedge,
$$
其中 $T$ 是 $^0\nabla^{TW}$ 的挠, $\{f_p\}$ 为 $TS$ 的正交标架, $\{f^p\}$ 是其对偶.</p>
<p>可以证明 $T(f_p^H, f_q^H) \in TZ$. 联络 $\nabla^{\mathscr E,H}$ 可表示为 $\sum_p f^p \wedge \nabla_{f_p}^{\mathscr E,H}$.</p>
<p>定义 <strong>Bismut 超联络</strong> $B\colon C^\infty (S,\mathscr E)\to C^\infty (S,  \wedge T^*S \otimes \mathscr E)$,
$$
B = D^Z + \nabla^{\mathscr E,U} -\frac{1}{4}c(T).
$$</p>
<h2>性质</h2>
<p>Bismut 超联络的平方 $B^2$ 是沿着纤维的 $2$ 阶椭圆算子.</p>
<h2>伸缩</h2>
<p>考虑伸缩变换 (rescaling)
$$
\delta_t \colon \wedge T^*S \otimes \mathscr E \to\wedge T^*S\otimes \mathscr E,\quad
\delta_t(\alpha)=t^{-k/2}\alpha\,(\alpha\in\wedge^k T^*S).
$$
定义
$$
B_t =\sqrt t \delta_t B \delta_t^{-1} =\sqrt t D^Z + \nabla^{\mathscr E,U} - \frac{1}{4\sqrt t}c(T),
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Fourier--向井变换"><header><h1><span class="taxon">Wiki. </span>“Fourier–向井变换” <a class="slug" href="./Fourier--向井变换.html">[Fourier--向井变换]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Fourier–向井变换是<span class="link local"><a href="./凝聚层的导出范畴.html" title="凝聚层的导出范畴 [凝聚层的导出范畴]">凝聚层的导出范畴</a></span>之间的函子 $D(X)\to D(Y)$, 它是通过核对象 $K\in D(X\times Y)$ 构造的 “积分变换”.</p>
<p>许多基本的函子, 如<span class="link local"><a href="./直像.html" title="“直像” [直像]">直像</a></span>与<span class="link local"><a href="./逆像.html" title="逆像 [逆像]">逆像</a></span>, 都具有这种形式.</p>
<p>向井茂于 1981 年最早使用这种变换研究 <span class="link local"><a href="./Abel簇.html" title="“Abel 簇” [Abel簇]">Abel 簇</a></span>与其对偶上的<span class="link local"><a href="./凝聚层的导出范畴.html" title="凝聚层的导出范畴 [凝聚层的导出范畴]">凝聚层的导出范畴</a></span>的等价性, 这类似于 Fourier 变换建立了向量空间与其对偶空间上分布的同构.</p>
<h2>定义</h2>
<p>设 $X,Y$ 是光滑代数簇. 对于 $P \in D^b(X\times Y)$, 有函子 $\Phi_P\colon D^b(X)\to D^b(Y)$,
$$
\mathcal E \mapsto  p_*(P \otimes q^*\mathcal E).
$$
(省略了所有导出记号.)</p>
<p>投影映射是平坦的, 也即 $q^*$ 没有导出. 若 $P$ 局部自由, 则 $p_*$ 也没有导出.</p>
<h2>例</h2>
<h3>恒等</h3>
<p>对于对角线层 $\Delta\colon X\to X\times X$, $P=\mathcal O_\Delta$ 对应 $\operatorname{id}$.</p>
<p>$$
\begin{aligned}
	\Phi_{\mathcal O_\Delta}(\mathcal E) &amp; \simeq p_*(\Delta_* \mathcal O_X \otimes q^*\mathcal E)\\
	&amp; \simeq p_* \Delta_* (\Delta^* q^*\mathcal E \otimes\mathcal O_X).
\end{aligned}
$$
这里使用了<span class="link local"><a href="./投影公式.html" title="投影公式 [投影公式]">投影公式</a></span>,
$$
Rf_*(\mathcal F^\bullet) \otimes^L \mathcal E \simeq Rf_* (\mathcal F^\bullet \otimes^L Lf^*\mathcal E).
$$</p>
<h3>前推与拉回</h3>
<p>对于 $f\colon X\to Y$ 的 “图像” $\iota \colon X\to X\times Y$, $\Gamma_f := \iota_*\mathcal O_X$, 两个方向的 Fourier–向井变换分别是<span class="link local"><a href="./前推.html" title=" [前推]">直像</a></span> $f_*$ 和<span class="link local"><a href="./拉回.html" title="拉回 (范畴论) [拉回]">逆像</a></span> $f^*$.</p>
<h3>一族连续变化的层</h3>
<p>设 $P\in D^b(X\times Y)$ 在 $X$ 上凝聚平坦 (coherent flat). (想象 $Y$ 为参数, $P_x$ 是 $P_{x_0}$ 的形变)</p>
<p>(待补充)</p>
<h3>小平–Spencer 映射</h3>
<p>(待补充)
$$
T_{x_0}X \to \operatorname{Ext}^1(P_{x_0},P_{x_0})
$$
注意 $T_{x_0}X$ 同构于 $\operatorname{Ext}^1(k(x_0),k(x_0))$.</p>
<h2>性质</h2>
<p><strong>定理</strong>. Fourier–向井变换有左右伴随, 且均为 Fourier–向井变换.</p>
<p>对 $P\in D^b(X\times Y)$, 定义 $P_L = P^\vee \otimes p^* \omega_Y[\dim Y]$ ($p\colon X\times Y\to Y$ 为投影), $P_R = P^\vee \otimes q^*\omega_X [\dim X] \in D^b(Y\times X)$. 参见 <span class="link local"><a href="./Serre对偶.html" title="“Serre 对偶” [Serre对偶]">Serre 对偶</a></span>.</p>
<p><strong>定理</strong>. 两个 Fourier–向井变换的复合也是 Fourier–向井变换.</p>
<p>对 $P\in D^b(X\times Y)$, $Q\in D^b(Y\times Z)$, 定义 $R\in D^b(X\times Z)$ 如下.
$$
R = (\pi_{XZ})_* ((\pi_{XY})^*P \otimes (\pi_{YZ})^* Q).
$$
其中 $\pi_{XZ}$ 是 $X\times Y\times Z$ 到 $X\times Z$ 的投影, 等等.</p>
<p>如下是 Fourier–向井变换是全忠实函子的判定.</p>
<p><strong>定理</strong> 设 $X,Y$ 是特征 $0$ 的代数闭域 $k$ 上的光滑<span class="link local"><a href="./射影簇.html" title="“射影簇” [射影簇]">射影簇</a></span>, $P\in D^b(X\times Y)$. Fourier–向井变换 $\Phi$ 是全忠实函子当且仅当对任意闭点 $x,y\in X$,
$$
\operatorname{Hom}(\Phi_P(k(x)),\Phi_P(k(y))[i])=
\begin{cases}
k, &amp; x=y,i=0\\
0, &amp; x\neq y\text{ or }i&lt;0 \text{ or }i&gt;\dim X.
\end{cases}
$$</p>
<h2>K-理论版本</h2>
<p>$\mathcal F^\bullet \in D^b(X)$ 对应 $X$ 的 <span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>中的元素 $[\mathcal F^\bullet]:=\sum (-1)^i[\mathcal F^i] \in K(X)$.</p>
<p><strong>命题</strong>. $[\mathcal F^\bullet] = \sum (-1)^i [\mathcal H^i (\mathcal F^\bullet)]$.</p>
<p>定义<span class="link local"><a href="./紧支集直像.html" title="“紧支集直像” [紧支集直像]">紧支集直像</a></span> $f_! \mathcal F := \sum (-1)^i [R^i f_*\mathcal F]$.</p>
<p><span class="link local"><a href="./K-理论.html" title="“K-理论” [K-理论]">K-理论</a></span>版本的 Fourier–向井变换定义如下. 对 $e\in K(X\times Y)$,
$$
\Phi^K_e \colon f\mapsto p_!(e\otimes q^* f).
$$</p>
<h2>上同调版本</h2>
<p>对于 $f\colon X\to Y$, 有 $f_*\colon H^*(X;\mathbb{Q}) \to H^{*+2\dim Y - 2\dim X}(Y;\mathbb{Q})$, 满足<span class="link local"><a href="./投影公式.html" title="投影公式 [投影公式]">投影公式</a></span>
$$
f_*(f^*\alpha \cdot \beta) = \alpha \cdot f_*\beta.
$$
定义 $\Phi^H\colon H^*(X;\mathbb{Q}) \to H^*(Y;\mathbb{Q})$,
$$
\Phi^H\colon \beta\mapsto p_*(\alpha \cdot q^* \beta).
$$</p>
<p><span class="link local"><a href="./陈特征.html" title="“陈特征” [陈特征]">陈特征</a></span>是从 <span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>到上同调的函子, 可联系 K-理论和上同调两个版本的 Fouier–向井变换. 两者的关系涉及 <span class="link local"><a href="./Todd类.html" title="“Todd 类” [Todd类]">Todd 类</a></span>: 设 $e\in K(X\times Y)$, 则
$$
\Phi^H_{v(e)} (\operatorname{ch}(f)\sqrt{\operatorname{td}X}) = \operatorname{ch}(\Phi^K_e(f)) \sqrt{\operatorname{td}Y}.
$$
其中 $v(e) = \operatorname{ch}(e)\sqrt{\operatorname{td}X} \in H^*(X;\mathbb{Q})$ 称为 Fourier–向井向量.</p>
<p><strong>证明</strong>.
$$
\begin{array}
	{ccccccc}
	K(X) &amp; \to &amp; K(X\times Y) &amp; \to &amp; K(X\times Y) &amp; \to &amp; K(Y)\\
	\downarrow &amp;&amp; \downarrow &amp;&amp; \downarrow &amp;&amp; \downarrow\\
	H^*(X) &amp; \to &amp; H^*(X\times Y) &amp; \to &amp; H^*(X\times Y) &amp; \to &amp; H^*(Y)
\end{array}
$$
中间方块交换是由于 <span class="link local"><a href="./Grothendieck--Riemann--Roch定理.html" title="“Grothendieck–Riemann–Roch 定理” [Grothendieck--Riemann--Roch定理]">Grothendieck–Riemann–Roch 定理</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="K-群(代数)"><header><h1><span class="taxon">Wiki. </span>“K-群 (代数)” <a class="slug" href="./K-群(代数).html">[K-群(代数)]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>代数簇</h3>
<p>设 $X$ 是<span class="link local"><a href="./代数簇.html" title="“代数簇” [代数簇]">代数簇</a></span>, 考虑 $X$ 上有限秩向量丛的范畴 $\mathcal P(X)$. 定义 $K_0(X)$ 为 $\mathcal P(X)$ 的同构类在 “短正合列中间等于两边之和” 的关系下生成的交换群.</p>
<h3>仿射簇</h3>
<p>在 $X=\operatorname{spec}R$ 的情形, $X$ 上的向量丛对应 $R$ 上的有限生成<span class="link local"><a href="./投射模.html" title="投射模 [投射模]">投射模</a></span>.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>, <span class="link local"><a href="./向量丛-投射模类比.html" title="向量丛-投射模类比 [向量丛-投射模类比]">向量丛-投射模类比</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="拓扑K-理论"><header><h1><span class="taxon">Wiki. </span>“拓扑 K-理论” <a class="slug" href="./拓扑K-理论.html">[拓扑K-理论]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>拓扑 K-理论是由拓扑空间上的向量丛构造的一种广义上同调理论. <span class="link local"><a href="./K-理论.html" title="“K-理论” [K-理论]">K-理论</a></span>这个名字最早由 Grothendieck 使用, 来自德文 Klasse.</p>
<p>粗略地说, K-理论试图用 Abel 上同调去表达向量丛的分类, (向量丛的分类本身是一种<span class="link local"><a href="./非Abel上同调.html" title="非 Abel 上同调 [非Abel上同调]">非 Abel 上同调</a></span>, 即 $GL_n$ 系数的上同调).</p>
<blockquote>
<p>It turns out that an important source of virtual vector bundles representing classes in $K$-theory are index bundles: Given a Riemannian spin manifold $B$, then there is a vector bundle $S\to B$ called the spin bundle of $B$, which carries a differential operator, called the <span class="link local"><a href="./Diracoperator.html" title=" [Diracoperator]">Dirac 算子</a></span> $D$. The index of a Dirac operator is the formal difference of its kernel by its cokernel. Now given a <strong>continuous family</strong> $D_x$ of Dirac operators/Fredholm operators, parameterized by some topological space $X$, then these <strong>indices combine to a class</strong> in $K(X)$. It is via this construction that topological K-theory connects to spin geometry (see e.g. Karoubi K-theory) and index theory.</p>
<p>As the terminology indicates, both spin geometry and Dirac operator originate in physics. Accordingly, K-theory plays a central role in various areas of mathematical physics, for instance in the theory of geometric quantization (“$\mathrm{spin}^\mathrm{c}$ quantization”) in the theory of D-branes (where it models D-brane charge and RR-fields) and in the theory of Kaluza-Klein compactification via spectral triples (see below).</p>
<p>All these geometric constructions have an <strong>operator algebraic incarnation</strong>: by the topological Serre-Swan theorem then vector bundles of finite rank are equivalently modules over the $C^*$-algebra of continuous functions on the base space. Using this relation one may express K-theory classes entirely operator algebraically, this is called operator K-theory. Now Dirac operators are generalized to Fredholm operators.</p>
<p>There are more $C^*$-algebras than arising as algebras of functions of topological space, namely non-commutative C-algebras. One may think of these as defining non-commutative geometry, but the definition of operator K-theory immediately generalizes to this situation (see also at KK-theory).</p>
<p>While the $C^*$-algebra of a Riemannian spin manifold remembers only the underlying topological space, one may algebraically encode the smooth structure and Riemannian structure by passing from Fredholm modules to “spectral triples”. This may for instance be used to algebraically encode the spin physics underlying the standard model of particle physics and operator K-theory plays a crucial role in this.</p>
</blockquote>
<h2>相关概念</h2>
<p><span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>, <span class="link local"><a href="./约化K-群(拓扑).html" title="“约化 K-群 (拓扑)” [约化K-群(拓扑)]">约化 K-群 (拓扑)</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="约化K-群(拓扑)"><header><h1><span class="taxon">Wiki. </span>“约化 K-群 (拓扑)” <a class="slug" href="./约化K-群(拓扑).html">[约化K-群(拓扑)]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>约化 K-群的定义见 <span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>.</p>
<h3>作为一个核</h3>
<p>约化 K-群 $\widetilde K(X)$ 也同构于如下的 $K'(X)$, 其中 $r$ 将向量丛对应到其维数 (作为局部常值函数, 即 $H^0(X;\mathbb{Z})$ 的元素)
$$
0 \to K'(X)\to K(X) \overset{r}{\to} H^0(X;\mathbb{Z}) \to 0
$$</p>
<h3>作为稳定等价类的群</h3>
<p>对于紧空间 $X$ (或与之同伦等价的空间), 由于 $X$ 上任何向量丛均为平凡丛的子丛, 可证明其上的约化 K-群同构于向量丛的<strong>稳定等价</strong>类构成的群. (向量丛 $E,F$ 稳定等价是指存在平凡丛 $k,l$ 使得 $E\oplus k\simeq F\oplus l$.) 换言之, 令 $\Phi_n(X)$ 是 $X$ 上 $n$ 维向量丛的等价类, $\Phi_n(X) \to \Phi_{n+1}(X)$ 为与平凡丛的直和, 那么 $\widetilde K(X)$ 是下图的余极限:
$$
\Phi_0(X)\to \Phi_1(X) \to \Phi_2(X) \to \cdots,
$$
其上有由 Whitney 和 $\Phi_p(X)\times\Phi_q(X)\to \Phi_{p+q}(X)$ 给出的半群结构.</p>
<h3>到分类空间的同伦类</h3>
<p>稳定分类空间 $BO$ 是如下 (Grassmann 流形态射的) 余极限:
$$
BO(1) \to BO(2) \to \cdots \to BO(n) \to \cdots,
$$
那么约化 K-群还可用 $X$ 到 $BO$ (或 $BU$) 的映射的同伦类来描述, 即
$$
\widetilde{K}_{\mathbb{R}}(X)\simeq [X,BO].
$$</p>
<h2>性质</h2>
<p>$\widetilde{K}(X)$ 满足如下万有性质: 对任意 Abel 群 $A$ 与半群同态 $\varphi\colon V(X)\to A$, 若 $\varphi$ 将所有平凡丛映射到 $0$, 则 $\varphi$ 经过 $\widetilde{K}(X)$.</p>
</details></section></details></section></footer></article></div></body></html>