<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>“Riemann–Roch 定理”</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="Riemann--Roch定理"><header><h1><span class="taxon">Wiki. </span>“Riemann–Roch 定理” <a class="slug" href="./Riemann--Roch定理.html">[Riemann--Roch定理]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>复分析中, Riemann–Roch 定理描述了给定零点与可能极点的亚纯函数空间的维数. 它将紧 <span class="link local"><a href="./Riemann面.html" title="“Riemann 面” [Riemann面]">Riemann 面</a></span>上的复分析与其<span class="link local"><a href="./拓扑亏格.html" title=" [拓扑亏格]">亏格</a></span>联系起来.</p>
<p>Riemann–Roch 定理将代数或解析簇 $X$ 上局部自由层 $E$ 的 <span class="link local"><a href="./Euler示性数.html" title="Euler 示性数 [Euler示性数]">Euler 示性数</a></span>表示为 $E$ 与 $X$ 的<span class="link local"><a href="./示性类.html" title="“示性类” [示性类]">示性类</a></span>.</p>
<p>Riemann–Roch 定理与 <span class="link local"><a href="./Mittag-Leffler问题.html" title="“Mittag-Leffler 问题” [Mittag-Leffler问题]">Mittag-Leffler 问题</a></span>有关.</p>
<h2>陈述</h2>
<p>对<span class="link local"><a href="./亏格.html" title="“亏格” [亏格]">亏格</a></span>为 $g$ 的紧<span class="link local"><a href="./曲线.html" title="“曲线” [曲线]">Riemann 面</a></span> $C$ 上的全纯向量丛 $E$,
$$
\chi(C,E) = \deg(E) + \operatorname{rk}(E)(1-g).
$$</p>
<p>对<span class="link local"><a href="./正则.html" title=" [正则]">正则性</a></span>射影曲线 $C$ 上的<span class="link local"><a href="./除子.html" title="“除子” [除子]">除子</a></span> $D=\sum a_{p}\cdot (p)$, 定义 $\deg D=\sum a_p \deg p$,
$$
\chi(C,\mathcal O_C(D))=\deg D + \chi(C,\mathcal O_C).
$$</p>
<p>对<span class="link local"><a href="./亏格.html" title="“亏格” [亏格]">亏格</a></span>为 $g$ 的紧 <span class="link local"><a href="./Riemann面.html" title="“Riemann 面” [Riemann面]">Riemann 面</a></span> $M$ 上的任意<span class="link local"><a href="./除子.html" title="“除子” [除子]">除子</a></span> $D$, $H^\bullet(M,\mathcal{O}_D)$ 均为有限维, 且
$$
\chi(H^\bullet(M,\mathcal{O}_D)) -\deg D= 1-g.
$$</p>
<h2>推广</h2>
<p><span class="link local"><a href="./Hirzebruch--Riemann--Roch定理.html" title="“Hirzebruch–Riemann–Roch 定理” [Hirzebruch--Riemann--Roch定理]">Hirzebruch–Riemann–Roch 定理</a></span>, <span class="link local"><a href="./Grothendieck--Riemann--Roch定理.html" title="“Grothendieck–Riemann–Roch 定理” [Grothendieck--Riemann--Roch定理]">Grothendieck–Riemann–Roch 定理</a></span></p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Hirzebruch--Riemann--Roch定理"><header><h1><span class="taxon">Wiki. </span>“Hirzebruch–Riemann–Roch 定理” <a class="slug" href="./Hirzebruch--Riemann--Roch定理.html">[Hirzebruch--Riemann--Roch定理]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Hirzebruch–Riemann–Roch 定理是整体复 (代数) 几何中一个十分有用的定理. 它是 <span class="link local"><a href="./Riemann--Roch定理.html" title="“Riemann–Roch 定理” [Riemann--Roch定理]">Riemann–Roch 定理</a></span>的推广, 可视为 <span class="link local"><a href="./Grothendieck--Riemann--Roch定理.html" title="“Grothendieck–Riemann–Roch 定理” [Grothendieck--Riemann--Roch定理]">Grothendieck–Riemann–Roch 定理</a></span>中 $Y$ 为一个点且基域为 $\mathbb{C}$ 的情形.</p>
<p>对于紧复流形 (或概形) 上的<span class="link local"><a href="./全纯向量丛.html" title="“全纯向量丛” [全纯向量丛]">全纯向量丛</a></span> (或一般的<span class="link local"><a href="./凝聚层.html" title="凝聚层 [凝聚层]">凝聚层</a></span>), 其 <span class="link local"><a href="./Euler示性数.html" title="Euler 示性数 [Euler示性数]">Euler 示性数</a></span>, 即<span class="link local"><a href="./凝聚层上同调.html" title="“凝聚层上同调” [凝聚层上同调]">凝聚层上同调</a></span>的交错和 (对于平凡丛即 <span class="link local"><a href="./Dolbeault算子.html" title=" [Dolbeault算子]">Dolbeault 上同调</a></span>的<span class="link local"><a href="./指标.html" title=" [指标]">解析指标</a></span>), 等于 <span class="link local"><a href="./Todd类.html" title="“Todd 类” [Todd类]">Todd 类</a></span>与<span class="link local"><a href="./陈特征.html" title="“陈特征” [陈特征]">陈特征</a></span>之积:
$$
\chi(\mathcal F) =\int_M \operatorname{ch}(\mathcal F)\wedge \operatorname{td}(TM).
$$
(积分表示取最高维上同调)</p>
<h2>曲线的情形</h2>
<p>对于曲线 $X$ 上的除子 $D$,</p>
<ul>
<li><span class="link local"><a href="./可逆层.html" title="“可逆层” [可逆层]">可逆层</a></span> $\mathcal O(D)$ 的<span class="link local"><a href="./陈特征.html" title="“陈特征” [陈特征]">陈特征</a></span>是 $1+c_1(\mathcal O(D))$,</li>
<li>曲线 $X$ 的 <span class="link local"><a href="./Todd类.html" title="“Todd 类” [Todd类]">Todd 类</a></span>是 $1+c_1(TX)/2$,</li>
<li>$h^0(\mathcal O(D))$ 就是 $l(D)$,</li>
<li>$h^1(\mathcal O(D))$ 由 <span class="link local"><a href="./Serre对偶.html" title="“Serre 对偶” [Serre对偶]">Serre 对偶</a></span>等于 $l(K-D)$, 其中 $K$ 是<span class="link local"><a href="./典范除子.html" title=" [典范除子]">典范除子</a></span>.</li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="K-理论"><header><h1><span class="taxon">Wiki. </span>“K-理论” <a class="slug" href="./K-理论.html">[K-理论]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>K-理论由 Grothendieck 在 <span class="link local"><a href="./Riemann--Roch定理.html" title="“Riemann–Roch 定理” [Riemann--Roch定理]">Riemann–Roch 定理</a></span>的推广工作中提出. Atiyah 和 Hirzebruch 发展了与之类似的<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span>.</p>
<p>设 $\mathcal C$ 为<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定无穷范畴</a></span>, 其 K-理论是一个<span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span> $K(\mathcal C)$, $\pi_0K(\mathcal C)$ 是 $\mathcal C$ 的 Grothendieck 群.</p>
<h2>例</h2>
<h3>代数 K-理论</h3>
<blockquote>
<p>Historically, the <em>algebraic K-theory</em> of a commutative ring (what today is the <strong>“0th” algebraic K-theory group</strong>) was originally defined to be the Grothendieck group of its symmetric monoidal category of projective modules. Under the relation between modules and vector bundles, this is directly analogous to the basic definition of topological K-theory, whence the common term. (In fact when applied to the <strong>stack of vector bundles</strong> then algebraic K-theory subsumes topological K-theory and also differential K-theory.</p>
</blockquote>
<p>Quillen 定义了环 $R$ 的高阶 <span class="link local"><a href="./K-群.html" title=" [K-群]">K-群 (代数)</a></span>, 它是某个空间 $BGL(R)^+$ 的同伦群.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Serre对偶"><header><h1><span class="taxon">Wiki. </span>“Serre 对偶” <a class="slug" href="./Serre对偶.html">[Serre对偶]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Serre 对偶是 <span class="link local"><a href="./Poincaré对偶.html" title=" [Poincaré对偶]">Poincaré–Verdier 对偶</a></span>在<span class="link local"><a href="./凝聚层上同调.html" title="“凝聚层上同调” [凝聚层上同调]">凝聚层上同调</a></span>中的类比.</p>
<blockquote>
<p>李归农在<span class="link external"><a href="https://www.zhihu.com/question/268043432/answer/333423706" title="知乎回答 [https://www.zhihu.com/question/268043432/answer/333423706]">知乎回答</a></span>中指出 Serre 对偶完全是<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>的性质.</p>
</blockquote>
<blockquote>
<p>Wiki: According to Grothendieck’s relative point of view, the theory of Jean-Pierre Serre was extended to a <span class="link local"><a href="./propermorphism.html" title=" [propermorphism]">紧合映射</a></span>; Serre duality was recovered as the case of the morphism of a non-singular projective variety to a point.</p>
</blockquote>
<h2>初见</h2>
<p>设 $X$ 是 $k$ 上的不可约光滑射影 $n$ 维代数簇, 则存在<span class="link local"><a href="./可逆层.html" title="“可逆层” [可逆层]">可逆层</a></span> $\omega_X$, 使得对任意局部自由有限秩层 $\mathcal F$,
$$
h^i(X,\mathcal F) = h^{n-i}(X,\omega_X\otimes \mathcal F^\vee).
$$
且有完美配对
$$
H^i(X,\mathcal F)\otimes H^{n-i}(X,\omega_X\otimes \mathcal F^\vee)\to H^n(X,\omega_X) = k.
$$
对于曲线 $C$ 有
$$
h^1(C,\mathscr L)=h^0(C,\omega_C\otimes\mathscr L^\vee),
$$
<span class="link local"><a href="./Riemann--Roch定理.html" title="“Riemann–Roch 定理” [Riemann--Roch定理]">Riemann–Roch 定理</a></span>可表达为
$$
h^0(C,\mathscr L)-h^0(C,\omega_C\otimes\mathscr L^\vee)=\deg\mathscr L - p_a(C) +1.
$$</p>
<p><strong>定理</strong> 设 $X$ 是射影概形, Cohen–Macauley, 则存在 $\omega_X$ (dualizing), 使得
$$
H^i(X,F)^* \simeq \operatorname{Ext}_{\mathcal O_X}^{n-i}(F,\omega_X).
$$
对于光滑的射影概形, $\omega_X$ 可定义为<span class="link local"><a href="./典范丛.html" title="“典范丛” [典范丛]">典范丛</a></span> $\wedge^n \Omega^1_{X/k}$.</p>
<p>设 $\mathcal E$ 局部自由有限秩, 则
$$
H^i(X,\mathcal E)^* \simeq \operatorname{Ext}_{\mathcal O_X}^{n-i} (\mathcal E,\omega_X) \simeq \operatorname{Ext}_{\mathcal O_X}^{n-i}(\mathcal O_X,\mathcal E^*\otimes \omega_X) \simeq H^{n-i}(X,\mathcal E^*\otimes\omega_X).
$$
对于<span class="link local"><a href="./复向量丛.html" title="“复向量丛” [复向量丛]">复向量丛</a></span>, 考虑 <span class="link local"><a href="./Dolbeault消解.html" title=" [Dolbeault消解]">Dolbeault 上同调</a></span> $A^{0,\bullet}\mathcal E$,
$$
H^i(\mathcal E) = H^i\Gamma (A^{0,*},d'').
$$
$$
\Gamma(A^{0,i})' = K_c^{n,n-i}(\mathcal E^*)
$$
$\Omega^n\otimes\mathcal E^*$ 被 $K^{n,*}_{\text{c}}$ (紧支集分布 ?) 消解.</p>
<h2>一般结论</h2>
<p>Grothendieck 的做法来源于对<span class="link local"><a href="./前推.html" title=" [前推]">直像</a></span> $f_*$ 的右伴随的探索 (它的左伴随是拉回).</p>
<p>对于 $n$ 维光滑射影概形 $X$,</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="形变"><header><h1><span class="taxon">Wiki. </span>“形变” <a class="slug" href="./形变.html">[形变]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $X$ 是光滑 $k$-代数簇, $(Y,y_0)$ 是带基点<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span>. $X$ 在 $(Y,y_0)$ 上的<strong>形变</strong>是一个平坦<span class="link local"><a href="./紧合映射.html" title="紧合映射 [紧合映射]">紧合映射</a></span> $\mathcal X\to Y$ 与一个同构 $\psi\colon X\to \varphi^{-1}(y_0)$.</p>
<p><strong>一阶无穷小形变</strong>是 $(\operatorname{Spec}k[x]/(x^2),(x))$ 之上的形变.</p>
<h2>曲线的无穷小形变</h2>
<p><span class="link local"><a href="./曲线.html" title="“曲线” [曲线]">曲线</a></span> $C$ 的无穷小形变的空间即为<span class="link local"><a href="./模空间.html" title="模空间 [模空间]">模空间</a></span>的切空间, 由此可计算模空间的维数. 由 <span class="link local"><a href="./Serre对偶.html" title="“Serre 对偶” [Serre对偶]">Serre 对偶</a></span>,
$$
H^1(C,T_C) \simeq H^0 (C,T^\vee_C\otimes\omega_C)^\vee \simeq H^0(C,\omega_C^{\otimes 2}),
$$
后一个等式是因为 $T_C^\vee=\omega_C$; 又由 <span class="link local"><a href="./Riemann--Roch定理.html" title="“Riemann–Roch 定理” [Riemann--Roch定理]">Riemann–Roch 定理</a></span>,
$$
\dim H^0 (C,\omega_C^{\otimes 2})- \dim H^1(C,\omega_C^{\otimes 2})=\deg(\omega^{\otimes 2})+g-1=3g-3,
$$
又因为 $H^1(C,\omega_C^{\otimes 2})=0$ (为什么?), 所以曲线模空间的维数为
$$
\dim H^1(C,T_C)=3g-3.
$$</p>
</details></section></details></section></footer></article></div></body></html>