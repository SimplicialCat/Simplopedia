<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>AI 会消灭数学家吗?</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="nonmath"><details open><summary id="AI-replace-math"><header><h1><span class="taxon"><span class="link local"><a href="./nonmath.html" title="非数学 [nonmath]">nonmath</a></span></span>AI 会消灭数学家吗? <a class="slug" href="./AI-replace-math.html">[AI-replace-math]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>2026-02-07</p>
<p>近日, 一群数学家在 arXiv 发布了一篇<span class="link local"><a href="./2602-05192.html" title="First Proof [2602-05192]">文章</a></span>, 列举他们研究中遇到的问题, 宣称他们知道这些问题的答案, 并将短时间内保密, 意图测试 AI 解决研究级别数学问题的能力.</p>
<p>这个月 arXiv 上另有一篇 5 位作者的文章 2602.03722 和一篇 21 位作者的文章 2602.03716 包含了 AI 在数学上的贡献, 包括在 <span class="link local"><a href="./Lean.html" title="Lean [Lean]">Lean/Mathlib</a></span> 中的形式化.</p>
<p>上个月, Tony Feng 在 arXiv 发布了一篇 “数学内容完全由 Gemini Deep Think (由 Google DeepMind 研发, 原名 Aletheia) 生成” 的文章 Eigenweights for arithmetic Hirzebruch Proportionality. <span class="link external"><a href="https://mp.weixin.qq.com/s/c9qiW8EWLoU8zQ-M83hGOg" title="一篇微信公众号文章 [https://mp.weixin.qq.com/s/c9qiW8EWLoU8zQ-M83hGOg]">一篇微信公众号文章</a></span>将其评价为 “第一次由 AI 完成的顶级数学成果”, 然而 “更多地是技术攻关而非概念革命”.</p>
<blockquote>
<p>《Eigenweights for Arithmetic Hirzebruch Proportionality》不仅是一篇扎实的数学论文，更是一份关于数学研究未来的宣言。它标志着我们正在进入一个新时代：在这个时代，数学家将从繁重的技术计算中解放出来，专注于更高层次的概念构建，而 AI 将作为强大的合作伙伴，负责跨越那些曾被视为不可逾越的技术鸿沟。</p>
<p>(来源微信公众号 “数语ShuYu”, 作者 GG)</p>
</blockquote>
<p>这些事件引起了某个微信 AI 社群的讨论. 有人甚至预测 10 年内人类数学家这个职业将会消亡; 人类 “将由球员变成观众”. 而有人认为 AI 目前没有独立发现 “新的数学” 的迹象; 很难相信 AI 能够自主发展重要的数学概念, 例如平展上同调.</p>
<p>在我看来, AI 能够作为工具帮助数学研究, 并不意味着人不再需要做数学, 或者数学不再需要人; 理由是数学工作的好坏的评判标准是取决于人类数学家的价值观.</p>
<p>当一件事情有明确的目的和机器可判定的评价标准时, 这件事就有可能完全交由机器完成. 围棋的胜利, 自动驾驶的安全, 以至于数学证明的正确性, 都是机器可以判定的. 我们知道 AI 在越来越多这样的工作中替代了人类.</p>
<p>然而谁来决定数学工作的好坏呢? 并不是所有正确的命题在人们心中都有同等的价值; 即使同一个命题, 不同的证明也有不同的意义. 换言之, “我们该研究什么问题, 建立怎样的理论来研究它”, 是一个只能由人类决定的问题. 这就像是无论汽车的自动驾驶如何强大, “我们该去哪里, 走哪条路风景好”, 还是要由人类来判断.</p>
<blockquote>
<p>Ce qui fait la qualité de l’inventivité et de l’imagination du chercheur, c’est la qualité de son attention, à l’écoute de la voix des choses. Car les choses de l’Univers ne se lassent jamais de parler d’elles-mêmes et de se révéler, à celui qui se soucie d’entendre.</p>
<p>研究者创造力与想象力的品质, 源于其注意力的品质——那是一种倾听事物之声的专注. 因为宇宙中的万物从不倦于诉说自身, 展现自身, 只待那些真心愿意倾听的人去发现.</p>
<p>Grothendieck, <em>Récoltes et Semailles</em></p>
</blockquote>
<p>在我看来, 指引数学发展的是人类的这样一种 “聆听事物之声” 的能力. 这比遵守形式化系统的游戏规则来生成一个命题的证明要困难得多. 在这方面, 近期有一个杰出的例子是 Peter Scholze 等人引入的名为 <span class="link local"><a href="./Gestalt.html" title="Gestalt [Gestalt]">Gestalt</a></span> 的概念. 它并不是为了解决某个具体的猜想而产生的, 而是脱胎于代数几何和高阶范畴论长期的实践 (“聆听事物之声”), 为了融合代数–几何对偶, 范畴化等等数学界长期存在的模糊的观念, 或简而言之——为了表达数学家的内心而产生的. 我相信任何人阅读了这样的工作, 再看当下 AI 在数学研究中所扮演的角色, 都不会产生 AI 将会替代人类数学家的想法.</p>
<p>当然, 预测未来是一个不可能的任务. 所以如上的讨论都是基于一个假设: 在可见的未来, AI 工作将会保持当今的范式. 我们不知道是否会有一种新的人工智能的架构横空出世, 让今天的所有讨论失效.</p>
<hr />
<p>2026-02-17 更新</p>
<p>和朋友见面聊天, 发现他在看一本研究 “美” 的书, 书名叫做<em>美是进化的奖励</em>. 这本书的作者认为艺术是对基因的反叛. 美是人的基因造成的一种奖励机制, 这种机制的 “本来目的” (如果它存在的话) 是基因的延续, 而艺术则是利用这一机制做了一些与基因的延续无关的事情. 孔雀的尾羽在理论上无益于生存, 仅仅由于它的美丽而进化了出来.</p>
<p>当 AI 做数学的能力越来越强, 人类做的数学工作将更多地成为一种艺术, 即一种为了触发人类基因的奖励机制而创作的作品. 人类数学家将设计理论, 而把具体的验证工作交给机器.
人类是园林的设计师, 居住在自己构建的空间中, 获得舒适和美学的享受; 而 AI 则会扮演瓦匠和木工的角色.
最了解人类审美的永远是人类自己; 所以这是一份永远不会被其它族类取代的工作.</p>
<p>但这幅图景可能只是我的一厢情愿. 朋友指出一个悲观的现实: 可能正是因为当前科研的评价体系, 导致人类数学家会被 AI 替代. 在当下的数学社群, 做出已有结果的更美的, 更好理解的表述, 在很多人眼中是无价值的. 他曾写了一篇用范畴论做分析学 (Banach 空间) 的<span class="link external"><a href="https://www.researchgate.net/publication/391807846_Categorical_Universal_Algebra_and_Functorial_Perspectives_in_Analysis" title="文章 [https://www.researchgate.net/publication/391807846_Categorical_Universal_Algebra_and_Functorial_Perspectives_in_Analysis]">文章</a></span>, 教授向他提的第一个问题便是你有没有得到新的定理. 这个问题也是我自己的本科毕业论文 “<span class="link local"><a href="./盲人摸象.html" title="盲人摸象 [盲人摸象]">盲人摸象</a></span>” 在答辩中遇到的第一个问题. 而这种价值观可能导致一个更优雅的理论会在发展到能做出新的定理的水平之前被丢弃遗忘.</p>
</details></section><footer><section class="block link-list" id="references"><details open><summary><header><h1>References</h1></header></summary><section class="block" data-taxon="Reference"><details ><summary id="2602-05192"><header><h1><span class="taxon">Reference. </span>First Proof <a class="slug" href="./2602-05192.html">[2602-05192]</a></h1><div class="metadata"><ul><li class="meta-item">Mohammed Abouzaid, Andrew J. Blumberg, Martin Hairer, Joe Kileel, Tamara G. Kolda, Paul D. Nelson, Daniel Spielman, Nikhil Srivastava, Rachel Ward, Shmuel Weinberger, Lauren Williams</li></ul></div></header></summary>
<pre><code>@misc{abouzaid2026proof,
      title={First Proof}, 
      author={Mohammed Abouzaid and Andrew J. Blumberg and Martin Hairer and Joe Kileel and Tamara G. Kolda and Paul D. Nelson and Daniel Spielman and Nikhil Srivastava and Rachel Ward and Shmuel Weinberger and Lauren Williams},
      year={2026},
      eprint={2602.05192},
      archivePrefix={arXiv},
      primaryClass={cs.AI},
      url={https://arxiv.org/abs/2602.05192}, 
}
</code></pre>
</details></section><section class="block" data-taxon="Reference"><details ><summary id="盲人摸象"><header><h1><span class="taxon">Reference. </span>盲人摸象 <a class="slug" href="./盲人摸象.html">[盲人摸象]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link external"><a href="https://simplicialcat.github.io" title="我 [https://simplicialcat.github.io]">我</a></span></li></ul></div></header></summary>
<p>项目 (包括 tex 源代码): https://github.com/SimplicialCat/topos</p>
<p>PDF : https://simplicialcat.github.io/topos.pdf</p>
<p>2023 年开始的项目, 包含 $1$-<span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span>的基本知识, <span class="link local"><a href="./位象.html" title="位象 [位象]">位象</a></span>的概念, 以及范畴论和<span class="link local"><a href="./一阶语言.html" title="一阶语言与一阶逻辑 [一阶语言]">一阶逻辑</a></span>基础.</p>
<h2>内容</h2>
<ul>
<li>1 意象的范畴论性质
<ul>
<li>1.1 范畴论基本概念</li>
<li>1.2 意象</li>
<li>1.3 更多范畴论结构</li>
</ul>
</li>
<li>2 位象: 无点拓扑学
<ul>
<li>2.1 基本概念</li>
<li>2.2 位象的几何性质</li>
<li>2.3 位象与逻辑</li>
</ul>
</li>
<li>3 意象与空间的概念
<ul>
<li>3.1 拓扑空间上的层与平展空间</li>
<li>3.2 位象上的层与平展空间</li>
<li>3.3 范畴上的预层</li>
<li>3.4 景</li>
<li>3.5 层化与Grothendieck+构造</li>
<li>3.6 Grothendieck意象</li>
<li>3.7 Lawvere–Tierney拓扑,内蕴层化与局部化</li>
<li>3.8 意象之间的态射</li>
<li>3.9 景之间的态射</li>
<li>3.10 意象的几何性质</li>
<li>3.11 Giraud定理</li>
<li>3.12 等变层与拓扑群胚</li>
<li>3.13 意象的余极限</li>
</ul>
</li>
<li>4 意象的内语言
<ul>
<li>4.1 Mitchell–Bénabou语言</li>
<li>4.2 Kripke–Joyal语义</li>
<li>4.3不同意象的内语言的联系</li>
</ul>
</li>
<li>5 语法景与分类意象
<ul>
<li>5.1语法范畴:语法–语义对偶</li>
<li>5.2分类意象</li>
</ul>
</li>
<li>6 意象理论的应用
<ul>
<li>(这一章没有完成)</li>
</ul>
</li>
<li>A 范畴论基础
<ul>
<li>A.1 $2$-范畴</li>
<li>A.2 伴随</li>
<li>A.3 <span class="link local"><a href="./自反子范畴.html" title="自反子范畴 [自反子范畴]">自反子范畴</a></span>与局部化</li>
<li>A.4 预层范畴与米田嵌入</li>
<li>A.5 (余)滤范畴和(余)滤(余)极限</li>
<li>A.6 可表现范畴</li>
<li>A.7 Kan扩张</li>
<li>A.8 单子论</li>
<li>A.9 万有代数</li>
<li>A.10 纤维范畴与索引范畴</li>
<li>A.11 下降</li>
</ul>
</li>
<li>B 形式逻辑和范畴逻辑基础
<ul>
<li>B.1 一阶逻辑</li>
<li>B.2 一阶逻辑的范畴语义</li>
<li>B.3 高阶逻辑</li>
<li>B.4 类型论</li>
<li>B.5 模态逻辑</li>
</ul>
</li>
<li>术语和符号表</li>
<li>参考文献</li>
</ul>
</details></section></details></section><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="nonmath"><details ><summary id="AI4FP"><header><h1><span class="taxon"><span class="link local"><a href="./nonmath.html" title="非数学 [nonmath]">nonmath</a></span></span>AI 与形式化数学 <a class="slug" href="./AI4FP.html">[AI4FP]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>2026-01-24</p>
<p>这一周我参加了求真书院组织的 “AI与形式化数学” 冬令营, 学写 <span class="link local"><a href="./Lean.html" title="Lean [Lean]">Lean</a></span>, 思考形式化数学的未来.</p>
<p>虽然 LLM (大语言模型) 不一定是 AI 的最终答案, 但形式化数学工具的出现, 使得我们不得不面对这样一个未来: 随着被形式化的命题与证明构成的工具库的增长, LLM 的数学能力将会稳步上升, 成为数学家的有力合作者或竞争对手.
所以, 至少了解这位潜在的合作者或竞争对手, 成为了我学习 Lean 的动机.</p>
<p>经过简单的调研, 我发现不出所料, Lean 对于范畴论的实现完全停留在严格 $1$-范畴的层面, 对于高阶范畴没有丝毫推广的潜力. 恐怕本质的原因是 Lean 的一个等式的任何两个证明都相等, 换言之等式类型仅仅是 <span class="link local"><a href="./截断性(同伦类型论).html" title="截断性 (同伦类型论) [截断性(同伦类型论)]">$(-1)$-截断</a></span>的 “命题”; 这让我相信它不可能在现代数学的许多分支 (如导出代数几何) 中发挥作用.</p>
<h2>相关话题</h2>
<p><span class="link local"><a href="./AI-replace-math.html" title="AI 会消灭数学家吗? [AI-replace-math]">AI 会消灭数学家吗?</a></span></p>
</details></section></details></section></footer></article></div></body></html>