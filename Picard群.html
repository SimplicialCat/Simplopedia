<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>Picard 群</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="Picard群"><header><h1><span class="taxon">Wiki. </span>Picard 群 <a class="slug" href="./Picard群.html">[Picard群]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>空间的 Picard 群是其上<span class="link local"><a href="./线丛.html" title="线丛 [线丛]">线丛</a></span>的同构类关于张量积构成的群.</p>
<h2>定义</h2>
<h3>复流形</h3>
<p>紧复流形 $M$ 的 Picard 群 $\text{Pic}(M)$ 是<span class="link local"><a href="./全纯线丛.html" title="“全纯线丛” [全纯线丛]">全纯线丛</a></span>的同构类关于张量积构成的群. $\text{Pic}(M)$ 的单位元是平凡丛, 也即全纯函数层 $\mathcal O_M$.</p>
<p>定义 $\text{Pic}^0(M)$ 为 $\text{Pic}(M)$ 中由第一<span class="link local"><a href="./陈类.html" title="“陈类” [陈类]">陈类</a></span>等于零的线丛构成的子群.</p>
<h3>概形</h3>
<p><span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span> (或<span class="link local"><a href="./环化空间.html" title="环化空间 [环化空间]">环化空间</a></span>) $X$ 的 Picard 群 $\operatorname{Pic}(X)$ 是 $X$ 上秩为 $1$ 的局部自由 $\mathcal O_X$-模的同构类在张量积下构成的群. 它也同构于<span class="link local"><a href="./平展上同调.html" title="平展上同调 [平展上同调]">平展上同调</a></span> $H^1(X_{\mathrm{\'et}},\mathbb G_m)$.</p>
<h3>对称幺半范畴</h3>
<p><span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>的 Picard 群是其中可逆对象的同构类构成的 Abel 群.</p>
<h2>性质</h2>
<p>$\text{Pic}(M) \simeq H^1(M,\mathcal O_M^*)$.</p>
<p>$\text{Pic}^0(M) \simeq H^1(M,\mathcal O_M) / H^1(M,\mathbb{Z})$. (参见<span class="link local"><a href="./指数序列.html" title="“指数序列” [指数序列]">指数序列</a></span>)</p>
<p><span class="link local"><a href="./Dedekind整环.html" title="“Dedekind 整环” [Dedekind整环]">Dedekind 整环</a></span>的谱的 Picard 群是这个环的<span class="link local"><a href="./理想类群.html" title="“理想类群” [理想类群]">理想类群</a></span>.</p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Brauer群"><header><h1><span class="taxon">Wiki. </span>Brauer 群 <a class="slug" href="./Brauer群.html">[Brauer群]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>概形的 <strong>Brauer 群</strong>是其上 <span class="link local"><a href="./Azumaya代数.html" title="Azumaya 代数 [Azumaya代数]">Azumaya 代数</a></span>的相似类在张量积下构成的群; Azumaya 代数 $A$ 在 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中可逆; 因此其上的模范畴 $\mathsf{Mod}(A)$ 是可逆线性范畴.</p>
<p><span class="link local"><a href="./向量丛.html" title="向量丛 [向量丛]">向量丛</a></span>的自同态丛是 Azumaya 代数, 其对应的 Brauer 类平凡.</p>
<blockquote>
<p>Brauer groups and Azumaya algebras play an important role in many areas of mathematics, but especially in arithmetic geometry, algebraic geometry, and applications to mathematical physics. In arithmetic geometry, they are closely related to Tate’s conjecture on l-adic cohomology of schemes over finite fields, and they play a critical role in studying rational points of varieties through, for example, the Brauer Manin obstructions to the Hasse principle. In algebraic geometry, Azumaya algebras arise naturally when studying moduli spaces of vector bundles, and Brauer classes appear when considering certain constructions motivated from physics in homological mirror symmetry. The Brauer group was also used by Artin-Mumford (AM72) to construct one of the first examples of a non-rational unirational complex variety.</p>
</blockquote>
<h2>定义</h2>
<h3>域</h3>
<p>域 $K$ 的 Brauer 群 $\mathrm{Br}(K)$ 是其上的<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>的相似类关于张量积构成的群, 也即上同调
$$
H^2(\operatorname{Gal}(K_{\mathrm{sep}}/K),K^*_{\mathrm{sep}}) = H^2(\operatorname{Spec}K_{\mathrm{et}},\mathbb G_{\mathrm{m}}).
$$</p>
<p>设 $A,B$ 为 $K$ 上的有限维中心单代数, 若存在 $n,m\in\mathbb{Z}_+$ 使得 $M_n(A)\simeq M_m(B)$ (作为 $K$-代数), 则称 $A$ 与 $B$ 相似.</p>
<p>$A$ 与 $B$ 相似当且仅当存在可除代数 $D$ 使得 $A,B$ 均为 $D$ 上的矩阵代数.</p>
<p><strong>例</strong>. $\mathrm{Br}(\mathbb{R})\simeq \{[\mathbb{R}],[\mathbb H]\}$. $\mathbb H\otimes\mathbb H\simeq M_4(\mathbb{R})$.</p>
<p><strong>例</strong>. 有限域的 Brauer 群平凡, 因为有限除环都是域.</p>
<h3>环</h3>
<h4>与模范畴的关系</h4>
<p>设 $R$ 为交换环, 考虑 $2$-范畴 $\mathsf{Alg}_R$, 其对象为 $R$-代数 (即 $R$-模范畴中的幺半群), 态射为双模, 态射的复合为张量积, $2$-态射为双模的同态.</p>
<p>考虑 $\mathsf{Alg}_R$ 的<span class="link local"><a href="./对象的生象.html" title="对象的生象 [对象的生象]">核</a></span> $\mathrm{Core}(\mathsf{Alg}_R)$, 其对象为 $R$-代数, 态射为 Morita 等价, $2$-态射为双模的同构.</p>
<blockquote>
<p>This may be understood as the $2$-groupoid of (generalized) line $2$-bundles over $\operatorname{Spec}R$, inside that of all $2$-vector bundles.</p>
</blockquote>
<ul>
<li>$\pi_0(\mathbf{Br}(R))$ 为 $R$ 的 Brauer 群;</li>
<li>$\pi_1(\mathbf{Br}(R))$ 为 $R$ 的 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>;</li>
<li>$\pi_2(\mathbf{Br}(R))$ 为 $R$ 的乘法可逆元群.</li>
</ul>
<h3>平展上同调的定义</h3>
<p>在一些小的假设下, 概形 $X$ 的 Brauer 群 $\mathrm{Br}(X)$ 同构于<span class="link local"><a href="./平展上同调.html" title="平展上同调 [平展上同调]">平展上同调</a></span> $H^2_{\text{\'et}}(X,\mathbb G_m)$ 的挠部分. 见<span class="link local"><a href="./EC-H1-H2.html" title="平展上同调讨论班 : 非 Abel 上同调, 主齐性空间与 Brauer 群 [EC-H1-H2]">平展上同调讨论班讲义</a></span>.</p>
<h3>“范畴化” 的定义</h3>
<p>Brauer 群某种意义上是 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>的<span class="link local"><a href="./范畴化.html" title="范畴化 [范畴化]">范畴化</a></span>.</p>
<p>对于概形 $X$ 可以谈论 “$X$ 上的拟凝聚<span class="link local"><a href="./叠.html" title="叠 [叠]">叠</a></span>”, 又叫 “$X$-线性<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 ∞-范畴</a></span>”; 其构成的范畴记为 $\mathsf{Cat}_X$.
一个与 Brauer 群相关的群是所谓 “导出 Brauer 群”, 定义为 $\mathsf{Cat}_X$ 的 Picard 群
$$
\mathrm{Br}^{\mathrm{der}}(X) := \operatorname{Pic}(\mathsf{Cat}_X).
$$</p>
<h2>性质</h2>
<p>代数闭域的 Brauer 群是平凡群.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Kummer理论"><header><h1><span class="taxon">Wiki. </span>Kummer 理论 <a class="slug" href="./Kummer理论.html">[Kummer理论]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h3>单位根概形</h3>
<p>设 $n$ 为正整数. 考虑<span class="link local"><a href="./乘法群概形.html" title="乘法群概形 [乘法群概形]">乘法群概形</a></span> $\mathbb G_m = \operatorname{Spec}\mathbb{Z}[x^{\pm 1}]$. 记
$$
n\colon \mathbb G_m \to \mathbb G_m
$$
为 $n$ 次方映射,
定义 “$n$ 次单位根” <span class="link local"><a href="./群概形.html" title="群概形 [群概形]">群概形</a></span>为其核:
$$
\mu_n := \operatorname{ker}(n\colon \mathbb G_m \to \mathbb G_m).
$$
作为<span class="link local"><a href="./函子式代数几何.html" title="函子式代数几何 [函子式代数几何]">函子</a></span> $\mathsf{Ring} \to \mathsf{Set}$, $\mu_n(A)$ 是 $A$ 中 $n$ 次方等于 $1$ 的元素的集合. 作为<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span>, $\mu_n = \operatorname{Spec}\mathbb{Z}[x]/(x^n-1)$.</p>
<h3>基底的选取</h3>
<p>记 $\zeta_n$ 为 $n$ 次<span class="link local"><a href="./本原单位根.html" title="本原单位根 [本原单位根]">本原单位根</a></span>. Kummer 理论关注的是定义在 $A:=\mathbb{Z}[1/n][\zeta_n]$ 上的概形 $X$, 这种概形 $X$ 满足 $\mathcal O(X)$ 具有本原 $n$ 次单位根, 且 $n$ 在其中可逆.</p>
<p><span class="link local"><a href="./基变换.html" title="基变换 [基变换]">基变换</a></span>到 $A$ 上会产生如下两个重要现象:</p>
<ul>
<li>
<p>由于本原单位根 $\zeta_n$ 的存在, 单位根群 $\mu_n$ 成为 $n$ 阶<strong>循环群</strong> $\mathbb{Z}/n$. 具体地, $A[x]/(x^n-1) \simeq \prod_{i=0}^{n-1} A[x]/(x-\zeta_n^i) \simeq A^n$.</p>
</li>
<li>
<p>由于 $n$ 可逆, 概形态射 $n\colon \mathbb G_m \to\mathbb G_m$ 成为<span class="link local"><a href="./平展概形态射.html" title="“平展概形态射” [平展概形态射]">平展覆盖</a></span> ($y^n-x$ 关于 $y$ 的导数可逆), 从而是<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展景</a></span>上的<span class="link local"><a href="./意象中的满射.html" title="意象中的满射 [意象中的满射]">满射</a></span>.</p>
</li>
</ul>
<h3>长正合列</h3>
<p>对于 $\mathbb{Z}[1/n][\zeta_n]$-<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span> $X$, 其<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展景</a></span>上的<span class="link local"><a href="./群短正合列.html" title="群的短正合列 [群短正合列]">短正合列</a></span>
$$
0 \to \mu_n \to \mathbb G_m \overset{n}{\to} \mathbb G_m\to 0
$$
给出<span class="link local"><a href="./平展上同调.html" title="平展上同调 [平展上同调]">平展上同调</a></span>的长正合列
$$
\begin{aligned}
0 &amp;\to \mu_n(X) \to \mathcal O(X)^* \overset{n}{\to} \mathcal O (X)^*\\
&amp;\to H^1(X_{\mathrm{\'et}},\mu_n) \to \operatorname{Pic}(X) \overset{n}{\to} \operatorname{Pic}(X),
\end{aligned}
$$
其中 $\operatorname{Pic}(X) = H^1(X,\mathbb G_m)$ 为 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>.
这个结论也可以表述为正合列
$$
0 \to \mathcal O(X)^* / (\mathcal O(X)^*)^n
\to H^1(X_{\mathrm{\'et}},\mu_n) \to \operatorname{Pic}(X)_n \to 0.
$$</p>
<p>设 $X$ 为代数闭域 $k$ 上的完备光滑曲线, 则 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>分解为 $\operatorname{Pic}^0(X)\oplus \mathbb{Z}$, 而 $\operatorname{Pic}^0(X) \simeq \operatorname{Jac}(X)(k)\simeq (\mathbb{Z}/n)^{2g}$, $\operatorname{Jac}(X)$ 为 <span class="link local"><a href="./Jacobi簇.html" title="Jacobi 簇 [Jacobi簇]">Jacobi 簇</a></span>.</p>
<p><strong>结论</strong>. 设 $X$ 为代数闭域 $k$ 上亏格为 $g$ 的完备连通光滑曲线, 正整数 $n$ 在 $k$ 中可逆, 则
$$
H^1(X_{\mathrm{\'et}},\mu_n)\simeq H^1(X_{\mathrm{\'et}},\mathbb{Z}/n)\simeq (\mathbb{Z}/n)^{2g}.
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="全纯向量丛"><header><h1><span class="taxon">Wiki. </span>“全纯向量丛” <a class="slug" href="./全纯向量丛.html">[全纯向量丛]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>$n$ 维<strong>全纯向量丛</strong> (holomorphic vector bundle) 是<span class="link local"><a href="./复流形.html" title="“复流形” [复流形]">复流形</a></span>上以<strong>全纯映射</strong> $U_{ij}\to GL(n,\mathbb{C})$ 为转移函数的<span class="link local"><a href="./复向量丛.html" title="“复向量丛” [复向量丛]">复向量丛</a></span>. 全纯向量丛也可等价地定义为投影映射 $E\to X$ 是复流形全纯映射的复向量丛.</p>
<p><strong>注</strong>. 复向量丛可在一般的空间上定义, 而全纯向量丛依赖于底流形的复结构, 即全纯向量丛只能在<strong>复流形</strong>上定义.</p>
<h2>度数</h2>
<p><span class="link local"><a href="./全纯线丛.html" title="“全纯线丛” [全纯线丛]">全纯线丛</a></span>的度数是除子的 “系数之和”, 与第一<span class="link local"><a href="./陈类.html" title="“陈类” [陈类]">陈类</a></span>有关.</p>
<p>全纯向量丛 $E$ 的<strong>度数</strong> (degree) 定义为其行列式丛 $\wedge^r E$ 的度数.</p>
<p><strong>命题</strong>. 对两个全纯向量丛 $E_1,E_2$,
$$
\deg (E_1\otimes E_2) = \deg(E_1)\operatorname{rank}(E_2) + \operatorname{rank}(E_1)\deg(E_2).
$$</p>
<h2>全纯截面</h2>
<p>全纯向量丛 $E$ 上的<strong>全纯截面</strong> (holomorphic section) 是指局部 (在某个平凡化中) 全纯的截面. 全纯截面构成一个<span class="link local"><a href="./层.html" title="拓扑空间上的层 [层]">层</a></span> $\mathcal O(E)$. 有时人们不区分全纯向量丛与其对应的层.</p>
<h2>$\bar\partial$ 算子</h2>
<p>全纯向量丛上的<strong>光滑截面</strong>上可定义算子
$$\bar\partial_E \colon
C^\infty(M,E)\to C^\infty(M,E\otimes {T^*}''M).
$$
具体地, 给定局部的全纯截面 $\sigma_i$, 对光滑截面 $s= f^i \sigma_i$ 有 $\bar\partial_E s = (\bar\partial f^i) \sigma_i.$ 由于转移函数是全纯的, 这个表达式不依赖于 $\sigma_i$ 的选取.</p>
<p>例如复流形上的微分形式有算子
$$
\bar\partial \colon C^\infty (\wedge^{p,q}M)\to C^\infty(\wedge^{p,q+1}M).
$$</p>
<h2>等价定义</h2>
<p>(待补充)</p>
<h2>联络</h2>
<p>见<span class="link local"><a href="./陈联络.html" title="“陈联络” [陈联络]">陈联络</a></span>.</p>
<h2>分类</h2>
<p><strong>定理</strong> 设 $X$ 是 $\mathbb P^1$ 或 <span class="link local"><a href="./椭圆曲线.html" title="“椭圆曲线” [椭圆曲线]">椭圆曲线</a></span>, 则 $X$ 上的全纯向量丛等同于代数向量丛, 也即局部自由层. 参见 <span class="link local"><a href="./GAGA.html" title="“GAGA” [GAGA]">GAGA</a></span>.</p>
<p><strong>定理</strong> (Grothendieck) $\mathbb P^1$ 上的全纯向量丛都可写成
$$
\mathcal O(d_1)^{n_1}\oplus \cdots \oplus \mathcal O(d_k)^{n_k}.
$$</p>
<p><strong>定理</strong>. <span class="link local"><a href="./椭圆曲线.html" title="“椭圆曲线” [椭圆曲线]">椭圆曲线</a></span> $X$ 的 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>同构于 $X$ 本身.</p>
<h2>例</h2>
<p>复流形的切丛是全纯向量丛.</p>
<p>另见 <span class="link local"><a href="./Hermite向量丛.html" title="“Hermite 向量丛” [Hermite向量丛]">Hermite 向量丛</a></span>, <span class="link local"><a href="./线丛.html" title="线丛 [线丛]">线丛</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="全纯线丛"><header><h1><span class="taxon">Wiki. </span>“全纯线丛” <a class="slug" href="./全纯线丛.html">[全纯线丛]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>复一维<span class="link local"><a href="./全纯向量丛.html" title="“全纯向量丛” [全纯向量丛]">全纯向量丛</a></span>.</p>
<p>另见<span class="link local"><a href="./线丛.html" title="线丛 [线丛]">线丛</a></span>.</p>
<h2>陈类</h2>
<p><strong>定理</strong>. 设 $L\to M$ 为全纯线丛, 带有 Hermite 结构 $h$, 则有 (不依赖于平凡化!)
$$
\Omega = - \partial \bar\partial \log h.
$$
<strong>推论</strong>. 全纯线丛的第一<span class="link local"><a href="./陈类.html" title="“陈类” [陈类]">陈类</a></span>
$$
c_1 = \frac{i}{2\pi}\Omega = - \frac{i}{2\pi} \partial \bar\partial  \log h.
$$
见<span class="link local"><a href="./陈联络.html" title="“陈联络” [陈联络]">陈联络</a></span>.</p>
<h2>Picard 群</h2>
<p>复几何中, 复流形 $X$ 的 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span> $\operatorname{Pic}(X)$ 是 $X$ 上全纯线丛的同构类在张量积下构成的群, 也等同于<span class="link local"><a href="./除子.html" title="“除子” [除子]">除子</a></span>的等价类构成的群.</p>
<p>全纯线丛的分类见<span class="link local"><a href="./全纯向量丛.html" title="“全纯向量丛” [全纯向量丛]">全纯向量丛</a></span>.</p>
<h2>例</h2>
<h3>射影空间</h3>
<p><strong>命题</strong>. $\mathbb P^1(\mathbb{C})$ 的<span class="link local"><a href="./全纯切丛.html" title=" [全纯切丛]">全纯(余)切丛</a></span> $T'\mathbb P^1(\mathbb{C}) = \mathcal O(2) = [2H]$, 其中 $H$ 是超平面 (即一个点) 对应的除子.</p>
<p><strong>证明</strong>. 考虑开集 $U_\lambda = \{x_\lambda\neq 0\}$. 考虑 $T'\mathbb P^1(\mathbb{C})$ 在 $U_0$ (坐标函数为 $s$) 上的截面 $\frac{\partial}{\partial s}$, $U_1$ (坐标函数为 $t$) 上的截面 $-\frac{\partial}{\partial t}$, 在 $U_0\cap U_1$ 上有 $s=1/t$,
$$
-\frac{\partial}{\partial t}=\frac{1}{t^2}\frac{\partial}{\partial s}=s^2\frac{\partial}{\partial s}.
$$
这说明 $T'\mathbb P^1(\mathbb{C})=\mathcal O(2)$.</p>
<p><strong>命题</strong>. 对于 $k\in\mathbb{Z}_+$, $\mathbb{CP}^n$ 上的线丛 $\mathcal O(k)$ 的截面是 $k$ 次齐次多项式.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="指数序列"><header><h1><span class="taxon">Wiki. </span>“指数序列” <a class="slug" href="./指数序列.html">[指数序列]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>指数序列是指紧复流形上层的正合列
$$
 0 \to \mathbb{Z} \to \mathcal O_M \overset{\exp}{\to} \mathcal O^*_M \to 0.
$$</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./陈类.html" title="“陈类” [陈类]">陈类</a></span>, <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span></p>
</details></section></details></section></footer></article></div></body></html>