<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>Grothendieck 拓扑</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="Grothendieck拓扑"><header><h1><span class="taxon">Wiki. </span>Grothendieck 拓扑 <a class="slug" href="./Grothendieck拓扑.html">[Grothendieck拓扑]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>使用范畴上的筛</h3>
<p>小范畴 $C$ 上的 Grothendieck 拓扑是对每个对象 $c\in C$ 指定一族<span class="link local"><a href="./筛.html" title="“筛” [筛]">筛</a></span>, 称作<strong>覆盖筛</strong> (covering sieve), 满足如下条件.</p>
<ul>
<li>最大筛 $\{f: d \to c, d\in C\}$ 是覆盖筛;</li>
<li>(稳定性) 若 $S$ 是 $c$ 的覆盖筛, 则对任意 $h\colon d\to c$, $h^*(S)$ 是 $d$ 的覆盖筛;</li>
<li>(传递性) 若 $S$ 是 $c$ 的覆盖筛, $R$ 是 $c$ 上另一个筛, 使得对任意 $h\colon d\to c$, $h^*(R)$ 都是覆盖筛, 则 $R$ 也是覆盖筛.</li>
</ul>
<p>特别地, 包含一个覆盖筛的筛也是覆盖筛.</p>
<h3>使用意象中的态射族</h3>
<p>参考 <span class="link local"><a href="./ABFJ.html" title="Left-exact localizations of ∞-topoi [ABFJ]">ABFJ-II</a></span>.</p>
<p><strong>定义</strong>. <span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span> $\mathcal{C}$ 中的 <strong>Grothendieck 拓扑</strong>是满足如下条件的态射族 $\tau$:</p>
<ul>
<li>$\tau$ 关于<span class="link local"><a href="./基变换.html" title="基变换 [基变换]">基变换</a></span>封闭;</li>
<li>$\tau$ 可被沿<span class="link local"><a href="./意象中的满射.html" title="意象中的满射 [意象中的满射]">满射</a></span>的<span class="link local"><a href="./基变换.html" title="基变换 [基变换]">基变换</a></span>探测; 具体地, 对态射 $f$ 与满射 $g$, 若 $f$ 沿 $g$ 的拉回属于 $\tau$, 则 $f$ 属于 $\tau$;</li>
<li>$\tau$ 关于复合封闭;</li>
<li>若 $fg$ 属于 $\tau$, 则 $f$ 属于 $\tau$.</li>
</ul>
<h2>性质</h2>
<ul>
<li><span class="link local"><a href="./次典范拓扑.html" title="次典范拓扑 [次典范拓扑]">次典范拓扑</a></span></li>
</ul>
</details></section><footer><section class="block link-list" id="references"><details open><summary><header><h1>References</h1></header></summary><section class="block" data-taxon="Reference"><details ><summary id="ABFJ"><header><h1><span class="taxon">Reference. </span>Left-exact localizations of ∞-topoi <a class="slug" href="./ABFJ.html">[ABFJ]</a></h1><div class="metadata"><ul><li class="meta-item">Mathieu Anel, Georg Biedermann, Eric Finster, André Joyal</li></ul></div></header></summary>
<h2>Left-exact localizations of ∞-topoi I: Higher sheaves</h2>
<pre><code>@article{ANEL2022108268,
title = {Left-exact localizations of ∞-topoi I: Higher sheaves},
journal = {Advances in Mathematics},
volume = {400},
pages = {108268},
year = {2022},
issn = {0001-8708},
doi = {https://doi.org/10.1016/j.aim.2022.108268},
url = {https://www.sciencedirect.com/science/article/pii/S0001870822000846},
author = {Mathieu Anel and Georg Biedermann and Eric Finster and André Joyal},
keywords = {Infinity-topos, Left-exact localization, Sheaf, Site, Congruence, Acyclic class},
abstract = {We are developing tools for working with arbitrary left-exact localizations of ∞-topoi. We introduce a notion of higher sheaf with respect to an arbitrary set of maps Σ in an ∞-topos E. We show that the full subcategory of higher sheaves Sh(E,Σ) is an ∞-topos, and that the sheaf reflection E→Sh(E,Σ) is the left-exact localization generated by Σ. The proof depends on the notion of congruence, which is a substitute for the notion of Grothendieck topology in 1-topos theory.}
}
</code></pre>
<h2>Left-exact localizations of ∞-topoi II: Grothendieck topologies</h2>
<pre><code>@article{ANEL2024107472,
title = {Left-exact localizations of ∞-topoi II: Grothendieck topologies},
journal = {Journal of Pure and Applied Algebra},
volume = {228},
number = {3},
pages = {107472},
year = {2024},
issn = {0022-4049},
doi = {https://doi.org/10.1016/j.jpaa.2023.107472},
url = {https://www.sciencedirect.com/science/article/pii/S0022404923001548},
author = {Mathieu Anel and Georg Biedermann and Eric Finster and André Joyal},
keywords = {∞-topos, Grothendieck topologies, Hypercompletion, Acyclic classes},
abstract = {We revisit the work of Toën–Vezzosi and Lurie on Grothendieck topologies, using the new tools of acyclic classes and congruences. We introduce a notion of extended Grothendieck topology on any ∞-topos, and prove that the poset of extended Grothendieck topologies is isomorphic to that of topological localizations, hypercomplete localizations, Lawvere–Tierney topologies, and covering topologies (a variation on the notion of pretopology). It follows that these posets are small and have the structure of a frame. We revisit also the topological–cotopological factorization by introducing the notion of a cotopological morphism. And we revisit the notions of hypercompletion, hyperdescent, hypercoverings and hypersheaves associated to an extended Grothendieck topology. We also introduce the notion of forcing, which is a tool to compute with localizations of ∞-topoi. We use this in particular to show that the topological part of a left-exact localization of an ∞-topos is universally forcing the generators of this localization to be ∞-connected instead of inverting them.}
}
</code></pre>
<h2>Left-exact Localizations of -Topoi III: The Acyclic Product</h2>
<pre><code>@misc{anel2025leftexactlocalizationsinftytopoiiii,
      title={Left-exact Localizations of $\infty$-Topoi III: The Acyclic Product}, 
      author={Mathieu Anel and Georg Biedermann and Eric Finster and André Joyal},
      year={2025},
      eprint={2308.15573},
      archivePrefix={arXiv},
      primaryClass={math.CT},
      url={https://arxiv.org/abs/2308.15573}, 
}
</code></pre>
</details></section></details></section><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Lawvere--Tierney拓扑"><header><h1><span class="taxon">Wiki. </span>Lawvere–Tierney 拓扑 <a class="slug" href="./Lawvere--Tierney拓扑.html">[Lawvere--Tierney拓扑]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>…
见 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span>.</p>
<h2>动机</h2>
<h2>与 Grothendieck 拓扑的关系</h2>
<p><strong>命题</strong>. 小范畴 $C$ 上的 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span>给出<span class="link local"><a href="./预层意象.html" title="预层意象 [预层意象]">预层意象</a></span> $\mathsf {Set}^{C^{\mathrm{op}}}$ 上的 Lawvere–Tierney 拓扑.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Nisnevich景"><header><h1><span class="taxon">Wiki. </span>“Nisnevich 景” <a class="slug" href="./Nisnevich景.html">[Nisnevich景]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>考虑 <span class="link local"><a href="./Noether概形.html" title=" [Noether概形]">Noether 概形</a></span>的范畴上的如下覆盖结构: 一族态射 $\{p_i\colon V_i \to U\}$ 为覆盖当且仅当任何域点 $\operatorname{spec}k\to U$ 都提升到某个 $V_i$. 该覆盖结构生成的 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span>称为 Nisnevich 拓扑.</p>
<p>设 $S$ 为 Noether 概形, 考虑 $S$ 上有限型光滑概形的范畴, 其配备 Nisnevich 拓扑构成的景称为 $S$ 上的 Nisnevich 景.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Zariski景"><header><h1><span class="taxon">Wiki. </span>Zariski 景 <a class="slug" href="./Zariski景.html">[Zariski景]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>Zariski 景是<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span>的范畴上配备 “单位分解” 给出的 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span>.
仿射概形的单位分解, 是对应的环中生成单位理想的一族元素.</p>
<h2>定义</h2>
<p>设 $k$ 为交换环, 记 $\mathsf{Alg}_k$ 为 $k$-代数的范畴; 对于 $A\in\mathsf{Alg}_k$ 记对偶范畴中相应的对象为 $\operatorname{Spec} A$.</p>
<p>定义 $k$ 上的 <strong>Zariski 景</strong>为 $\mathsf{Alg}_k^{\mathrm{op}}$ 配备如下 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span>: $\operatorname{Spec} A$ 的覆盖是一族态射
$$
\operatorname{Spec} A[a_i^{-1}] \to \operatorname{Spec} A,
$$
满足 $1\in (a_1,\cdots,a_n)$.</p>
<h2>性质</h2>
<h3>结构层</h3>
<p>Zariski 景上有典范的结构<span class="link local"><a href="./层.html" title="拓扑空间上的层 [层]">层</a></span>, 它是局部环层.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Čech上同调"><header><h1><span class="taxon">Wiki. </span>Čech 上同调 <a class="slug" href="./Čech上同调.html">[Čech上同调]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>Čech 上同调是一种用<span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">覆盖</a></span>的 <span class="link local"><a href="./Čech脉.html" title="Čech 脉 [Čech脉]">Čech 脉</a></span>来计算<span class="link local"><a href="./上同调.html" title="上同调 [上同调]">上同调</a></span>的方法. 一般 Čech 上同调计算的是 Abel 群 (<span class="link local"><a href="./E∞-群.html" title="E∞-群 [E∞-群]">$\mathbb E_\infty$-群</a></span>) 系数的上同调, 但少数情形也有<span class="link local"><a href="./非交换Čech上同调.html" title="非交换 Čech 上同调 [非交换Čech上同调]">非交换 Čech 上同调</a></span>.</p>
<h2>定义</h2>
<h3>单纯对象</h3>
<p>先讨论最广义的情形 (甚至包含了<span class="link local"><a href="./非交换Čech上同调.html" title="非交换 Čech 上同调 [非交换Čech上同调]">非交换 Čech 上同调</a></span>): 我们试图计算以<span class="link local"><a href="./单纯对象.html" title="单纯对象 [单纯对象]">单纯对象</a></span> (的<span class="link local"><a href="./几何实现(单纯图表的余极限).html" title="几何实现 (作为单纯图表的余极限) [几何实现(单纯图表的余极限)]">几何实现</a></span>) 为系数的上同调. 设 $\mathcal C$ 为 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">$\infty$-意象</a></span>, 记 $\mathsf{s}\mathcal{C}$ 为<span class="link local"><a href="./单纯对象.html" title="单纯对象 [单纯对象]">单纯对象</a></span>的范畴.
定义 $\mathcal C$ 中的覆盖 (<span class="link local"><a href="./意象中的满射.html" title="意象中的满射 [意象中的满射]">满射</a></span>) $U\to X$ 上取值于<span class="link local"><a href="./单纯对象.html" title="单纯对象 [单纯对象]">单纯对象</a></span> $A\in\mathsf{s}\mathcal{C}$ 的 <strong>Čech 上圈</strong>为<span class="link local"><a href="./单纯对象.html" title="单纯对象 [单纯对象]">单纯对象</a></span>的同态
$$
\text{\v{C}}(U\to X) \to A,
$$
也即对每个 $[n]\in\Delta$ 给出相容的同态
$$
\underbrace{U\times_X U \times_X \cdots\times_X U}_{n+1} \to A_n.
$$</p>
<h3>Abel 群</h3>
<p>设 $\mathcal C$ 为 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">$\infty$-意象</a></span>, $A$ 为其中的 <span class="link local"><a href="./E∞-群.html" title="E∞-群 [E∞-群]">$\mathbb E_\infty$-群</a></span>.</p>
<p>设 $U\to X$ 为覆盖. 下面我们定义 $\mathscr U$ 上取值在 $\mathcal F$ 中的上链复形
$$
0\to C^0(\mathscr U,\mathcal F)\to C^1(\mathscr U,\mathcal F) \to \cdots.
$$</p>
<p>上链群 $C^k(\mathscr U,\mathcal F)$ 的元素是如下的函数 $\varphi$: 对于每个 $(k+1)$-元组 (也叫 $k$-<strong>单形</strong>, simplex) $(\alpha_0,\cdots,\alpha_k)$ 都指定一个截面 $\varphi(\alpha_0,\cdots,\alpha_k)\in \Gamma (U_{\alpha_0}\cap\cdots\cap U_{\alpha_k} , \mathcal F)$.</p>
<p>上边缘 $\delta$ 的定义为
$$
\delta\varphi(\alpha_0,\cdots,\alpha_{k+1})=\sum_i (-1)^i \varphi(\alpha_0,\cdots,\widehat{\alpha_i},\cdots,\alpha_{k+1}).
$$
(我们默认对于右边的求和项施加适当的限制映射.)</p>
<p>复形 $C^\bullet(\mathscr U,\mathcal F)$ 的上同调即为 Čech 上同调 $\check H^\bullet(\mathscr U,\mathcal F)$.</p>
<p>设开覆盖 $\mathscr V = (V_j)_{j\in J}$ 是 $\mathscr U = (U_i)_{i\in I}$ 的<strong>加细</strong> (refinement), 也即存在映射 $\lambda \colon J\to I$, 使得对任意 $j\in J$, $V_j$ 包含于 $U_{\lambda (j)}$. 定义链映射
$$
\lambda_{\mathscr V}^{\mathscr U} \colon  C^k(\mathscr U,\mathcal F) \to C^k(\mathscr V, \mathcal F),
$$
$$
(\lambda_{\mathscr V}^{\mathscr U} \varphi)(j_0,\cdots,j_k) := \varphi(\lambda (j_0),\cdots,\lambda (j_k)),
$$
可验证 $\lambda_{\mathscr V}^{\mathscr U}$ 与上边缘 $\delta$ 交换, 于是有上同调之间的同态 $\check H^\bullet (\mathscr U,\mathcal F) \to \check H^\bullet(\mathscr V,\mathcal F)$. 进一步, 可证明上同调的同态与映射 $\lambda \colon  J\to I$ 的选取无关 (不同的映射 $\lambda$ 得到的链映射 $\lambda_{\mathscr V}^{\mathscr U}$ 相差一个 “棱镜” 链同伦).</p>
<p>我们可对所有开覆盖取顺向极限, 得到 $X$ 上系数在 $\Gamma$ 中的 Čech 上同调:
$$
\check H^\bullet(X,\mathcal F)=\lim_{\longrightarrow} \check H^\bullet(\mathscr{V},\mathcal F).
$$</p>
<h2>性质</h2>
<h3>函子性</h3>
<p>设 $\mathcal S,\mathcal T$ 为 Abel 群 (或一般的模) 层, $h\colon  \mathcal S \to \mathcal T$ 是同态, 则对任意局部有限开覆盖 $\mathscr U$ 有链映射 $h\colon  C^\bullet(\mathscr U,\mathcal S) \to C^\bullet (\mathscr U,\mathcal T)$, 从而有同态 $h\colon \check H^\bullet (\mathscr U,\mathcal S) \to \check H^\bullet (\mathscr U,\mathcal T)$, $h\colon \check H^\bullet (X,\mathcal S) \to \check H^\bullet (X,\mathcal T)$.</p>
<h3>正合列</h3>
<p><strong>命题</strong>. 层的短正合列
$$
0\to \mathcal F' \to \mathcal F \to \mathcal F'' \to 0,
$$
诱导 Čech 上同调的长正合列
$$
0 \to H^0(X,\mathcal F')\to H^0(X,\mathcal F) \to H^0(X,\mathcal F'')
\overset{\delta}{\to} H^1(X,\mathcal F') \to \cdots.
$$</p>
<p>细节. 映射 $C^p(\mathscr U,\mathcal F) \to C^p(\mathscr U,\mathcal F'')$ 不一定是满射, 但可以选取更细的开覆盖 $\mathscr W$, 使得对任意 $c''\in C^p(\mathscr W,\mathcal F'')$ 存在 $c\in C^p(\mathscr U,\mathcal F)$ 限制到 $c''$.</p>
<p>连接同态 $\delta$ 的定义. 对 $[c'']\in H^p(\mathscr U,\mathcal F'')$, 取 $[c]\in C^p(\mathscr U,\mathcal F)$, 那么 $\delta c\in C^{p+1}(X,\mathcal F)$ 来自 $c'\in C^{p+1}(X,\mathcal F')$. 定义 $\delta[c'']=[c']$.</p>
<h3>与层上同调的关系</h3>
<p>设 $\mathcal F$ 为 $X$ 上的预层, 则总有 Čech 上同调到其层化 $\mathcal F^+$ 的<span class="link local"><a href="./层上同调.html" title="(Abel) 层上同调 [层上同调]">层上同调</a></span>的映射
$$
\check H^n(X,\mathcal F) \to H^n(X,\mathcal F^+),
$$
但不一定是同构. 当 $X$ 是仿紧 Hausdorff 空间时, 上述映射是同构.</p>
<h2>例</h2>
<h3>0 维上同调</h3>
<p>$H^0(\mathscr U, \mathcal F)$ 的元素是上圈 $(\varphi_i)$, 满足任意两个截面 $\varphi_i$ 与 $\varphi_j$ 在相交处 $U_{ij}$ 都相等; 这就是说 $H^0(\mathscr U, \mathcal F)$ 的元素是 $\mathcal F$ 的<span class="link local"><a href="./整体截面.html" title="“整体截面” [整体截面]">整体截面</a></span> (这个事实与开覆盖 $\mathscr U$ 的选取无关).</p>
<h3>主丛</h3>
<p>设有 $X$ 上的 $G$-主丛 $E\to X$, $\mathscr{U}=(U_\alpha)$ 是平凡化覆盖,
$\varphi_\alpha\colon U_\alpha\times G\to E$ 是局部坐标.
转移函数 $\varphi_{\alpha\beta}\colon U_\alpha\cap U_\beta\to G$ 满足
$$
\varphi_{\alpha\gamma}=\varphi_{\alpha\beta}\circ \varphi_{\beta\gamma}.
$$
换言之, 对于 $1$-上链 $\varphi\colon (\alpha,\beta)\mapsto \varphi_{\alpha\beta}$, 有
$$
\delta\varphi(\alpha,\beta,\gamma)=\varphi_{\beta\gamma}\circ\varphi_{\alpha\gamma}^{-1}\circ\varphi_{\alpha\beta} =1.
$$
(这里为了确切符合上面定义的形式, 还需要 $G$ 为 Abel 群.)
因此这个条件称为<strong>上圈条件</strong> (cocycle condition). 见<span class="link local"><a href="./非Abel上同调.html" title="非 Abel 上同调 [非Abel上同调]">非 Abel 上同调</a></span>.</p>
<h3>Mittag-Leffler 问题</h3>
<p>设 $X$ 为复流形, $O$ 为 $X$ 上的全纯函数层, 则 <span class="link local"><a href="./Mittag-Leffler问题.html" title="“Mittag-Leffler 问题” [Mittag-Leffler问题]">Mittag-Leffler 问题</a></span>
(?)</p>
<h3>代数几何</h3>
<p>一般地, 对具有拓扑的<span class="link local"><a href="./景.html" title="景 [景]">景</a></span>, 如 <span class="link local"><a href="./Zariski景.html" title="Zariski 景 [Zariski景]">Zariski 景</a></span>, 概形的<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展景</a></span>, 都可定义 Čech 上同调.</p>
</details></section><section class="block" data-taxon="notion"><details ><summary id="局部性质"><header><h1><span class="taxon"><span class="link local"><a href="./notion.html" title="观念 [notion]">notion</a></span></span>局部性质 <a class="slug" href="./局部性质.html">[局部性质]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>对于<span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">覆盖结构</a></span> $J$, 以及态射的某种性质 $P$,</p>
<ul>
<li>称 $P$ 为<strong>源的局部性质</strong> (local on the source), 是指对任意 $J$-覆盖 $\{U_i \to X\}$, 态射 $X\to Y$ 有性质 $P$ 当且仅当每个复合 $U_i \to X\to Y$ 有性质 $P$.</li>
<li>称 $P$ 为<strong>目标的局部性质</strong> (local on the target), 是指对任意 $J$-覆盖 $\{U_i \to X\}$, 态射 $Y\to X$ 有性质 $P$ 当且仅当每个<span class="link local"><a href="./基变换.html" title="基变换 [基变换]">基变换</a></span> $U_i\times_X Y \to X$ 有性质 $P$.</li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="景"><header><h1><span class="taxon">Wiki. </span>景 <a class="slug" href="./景.html">[景]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p><strong>景</strong>是<span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span>的一种<span class="link local"><a href="./数学对象的表现.html" title="数学对象的表现 [数学对象的表现]">表现</a></span>.</p>
<p>Grothendieck 将拓扑空间上的<span class="link local"><a href="./层.html" title="拓扑空间上的层 [层]">层</a></span>推广为<span class="link local"><a href="./景上的层.html" title="景上的层 [景上的层]">景上的层</a></span>. <strong>景</strong> (site) 是带有覆盖结构 (又称 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span>) 的范畴. 正如拓扑空间中的开集可由子开集覆盖, 景规定了其对象何时由一族到它的态射覆盖.</p>
<h2>例</h2>
<p><span class="link local"><a href="./Zariski景.html" title="Zariski 景 [Zariski景]">Zariski 景</a></span></p>
<p><span class="link local"><a href="./无穷小景.html" title="“无穷小景” [无穷小景]">无穷小景</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="次典范拓扑"><header><h1><span class="taxon">Wiki. </span>次典范拓扑 <a class="slug" href="./次典范拓扑.html">[次典范拓扑]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>对于范畴 $\mathcal C$ 上的 <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span> $J$, 若所有<span class="link local"><a href="./可表函子.html" title="可表函子 [可表函子]">可表函子</a></span>均为<span class="link local"><a href="./景上的层.html" title="景上的层 [景上的层]">层</a></span>, 即<span class="link local"><a href="./米田嵌入.html" title="米田嵌入 [米田嵌入]">米田嵌入</a></span> $\mathcal C\hookrightarrow\mathsf{Psh}(\mathcal C)$ 落在<span class="link local"><a href="./层意象.html" title="层意象 [层意象]">层范畴</a></span> $\mathsf{Sh}(\mathcal C,J)$ 中, 则称 $J$ 为<strong>次典范</strong> (subcanonical) Grothendieck 拓扑.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="筛"><header><h1><span class="taxon">Wiki. </span>“筛” <a class="slug" href="./筛.html">[筛]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>对于小范畴 $\mathsf{C}$ 与其中的对象 $c$, 我们称 $\operatorname{Hom}(-,c)$ 的子函子为 $c$ 上的<strong>筛</strong> (sieve). 等价地, $c$ 上的筛是指向 $c$ 的一族箭头 $S$, 满足 $f\in S \Rightarrow f\circ g\in S$.</p>
<p>筛可用于定义<span class="link local"><a href="./子对象分类子.html" title="子对象分类子 [子对象分类子]">子对象分类子</a></span>.</p>
<p>相关概念: <span class="link local"><a href="./Grothendieck拓扑.html" title="Grothendieck 拓扑 [Grothendieck拓扑]">Grothendieck 拓扑</a></span></p>
</details></section></details></section></footer></article></div></body></html>