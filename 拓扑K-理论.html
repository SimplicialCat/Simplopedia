<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>“拓扑 K-理论”</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="拓扑K-理论"><header><h1><span class="taxon">Wiki. </span>“拓扑 K-理论” <a class="slug" href="./拓扑K-理论.html">[拓扑K-理论]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>拓扑 K-理论是由拓扑空间上的向量丛构造的一种广义上同调理论. <span class="link local"><a href="./K-理论.html" title="“K-理论” [K-理论]">K-理论</a></span>这个名字最早由 Grothendieck 使用, 来自德文 Klasse.</p>
<p>粗略地说, K-理论试图用 Abel 上同调去表达向量丛的分类, (向量丛的分类本身是一种<span class="link local"><a href="./非Abel上同调.html" title="非 Abel 上同调 [非Abel上同调]">非 Abel 上同调</a></span>, 即 $GL_n$ 系数的上同调).</p>
<blockquote>
<p>It turns out that an important source of virtual vector bundles representing classes in $K$-theory are index bundles: Given a Riemannian spin manifold $B$, then there is a vector bundle $S\to B$ called the spin bundle of $B$, which carries a differential operator, called the <span class="link local"><a href="./Diracoperator.html" title=" [Diracoperator]">Dirac 算子</a></span> $D$. The index of a Dirac operator is the formal difference of its kernel by its cokernel. Now given a <strong>continuous family</strong> $D_x$ of Dirac operators/Fredholm operators, parameterized by some topological space $X$, then these <strong>indices combine to a class</strong> in $K(X)$. It is via this construction that topological K-theory connects to spin geometry (see e.g. Karoubi K-theory) and index theory.</p>
<p>As the terminology indicates, both spin geometry and Dirac operator originate in physics. Accordingly, K-theory plays a central role in various areas of mathematical physics, for instance in the theory of geometric quantization (“$\mathrm{spin}^\mathrm{c}$ quantization”) in the theory of D-branes (where it models D-brane charge and RR-fields) and in the theory of Kaluza-Klein compactification via spectral triples (see below).</p>
<p>All these geometric constructions have an <strong>operator algebraic incarnation</strong>: by the topological Serre-Swan theorem then vector bundles of finite rank are equivalently modules over the $C^*$-algebra of continuous functions on the base space. Using this relation one may express K-theory classes entirely operator algebraically, this is called operator K-theory. Now Dirac operators are generalized to Fredholm operators.</p>
<p>There are more $C^*$-algebras than arising as algebras of functions of topological space, namely non-commutative C-algebras. One may think of these as defining non-commutative geometry, but the definition of operator K-theory immediately generalizes to this situation (see also at KK-theory).</p>
<p>While the $C^*$-algebra of a Riemannian spin manifold remembers only the underlying topological space, one may algebraically encode the smooth structure and Riemannian structure by passing from Fredholm modules to “spectral triples”. This may for instance be used to algebraically encode the spin physics underlying the standard model of particle physics and operator K-theory plays a crucial role in this.</p>
</blockquote>
<h2>相关概念</h2>
<p><span class="link local"><a href="./K-群(拓扑).html" title="“K-群 (拓扑)” [K-群(拓扑)]">K-群 (拓扑)</a></span>, <span class="link local"><a href="./约化K-群(拓扑).html" title="“约化 K-群 (拓扑)” [约化K-群(拓扑)]">约化 K-群 (拓扑)</a></span></p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Fredholm算子"><header><h1><span class="taxon">Wiki. </span>“Fredholm 算子” <a class="slug" href="./Fredholm算子.html">[Fredholm算子]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $H$ 为 Hilbert 空间, $\mathcal B$ 为 $H$ 上的有界线性算子构成的 Banach 代数. Fredholm 算子是指 $\mathcal B$ 中核与余核维数均有限的算子.</p>
<p>Fredholm 算子在紧算子误差的意义下可逆, 即 Fredholm 算子是 “有界算子商去紧算子” $\mathcal B(H_1,H_2)/ \mathcal K(H_1,H_2)$ 中的可逆元.</p>
<p>对于 Fredholm 算子 $T$, 方程 $Tu=0$ 仅有有限个线性无关的解; 且方程 $Tu=v$ 有解只需要 $v$ 满足有限个线性条件.</p>
<h3>无解算子的情形</h3>
<p>我们也可对 (稠密子空间上定义的) 无界的闭算子谈论它何时是 Fredholm 算子.</p>
<h2>指标</h2>
<p>Fredholm 算子 $T$ 的<span class="link local"><a href="./解析指标.html" title="解析指标 [解析指标]">解析指标</a></span>定义为
$$
\operatorname{ind}T=\dim\ker T - \dim\operatorname{coker}T.
$$
类似地可定义两个不同 Hilbert 空间之间的 Fredholm 算子.</p>
<p>指标是连续的, 而只取整数值, 因此对于一族随时间 $t$ 连续变化的 Fredholm 算子 $A_t$, 指标 $\operatorname{ind} A_t$ 与 $t$ 无关.</p>
<h2>与 K-理论的关系</h2>
<p>一个可分 Hilbert 空间上 Fredholm 算子的空间是 $0$ 阶<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span>的分类空间.</p>
<h2>例</h2>
<p>考虑 $\ell^2 = L^2(\mathbb{Z}_{\geq 0})$ 上的移位算子 $S\colon (x_0,x_1,x_2,\cdots)\mapsto (0,x_0,x_1,\cdots)$. 则 $S$ 为 Fredholm 算子, 且 $\operatorname{ind}S=-1$.</p>
<p><span class="link local"><a href="./椭圆算子.html" title="椭圆算子 [椭圆算子]">椭圆算子</a></span> (作用在 $L^2$ 空间上) 是无界的 Fredholm 算子, 其指标是非常重要的问题.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="K-理论"><header><h1><span class="taxon">Wiki. </span>“K-理论” <a class="slug" href="./K-理论.html">[K-理论]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>K-理论由 Grothendieck 在 <span class="link local"><a href="./Riemann--Roch定理.html" title="“Riemann–Roch 定理” [Riemann--Roch定理]">Riemann–Roch 定理</a></span>的推广工作中提出. Atiyah 和 Hirzebruch 发展了与之类似的<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span>.</p>
<p>设 $\mathcal C$ 为<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定无穷范畴</a></span>, 其 K-理论是一个<span class="link local"><a href="./谱.html" title="谱 (稳定同伦论) [谱]">谱</a></span> $K(\mathcal C)$, $\pi_0K(\mathcal C)$ 是 $\mathcal C$ 的 Grothendieck 群.</p>
<h2>例</h2>
<h3>代数 K-理论</h3>
<blockquote>
<p>Historically, the <em>algebraic K-theory</em> of a commutative ring (what today is the <strong>“0th” algebraic K-theory group</strong>) was originally defined to be the Grothendieck group of its symmetric monoidal category of projective modules. Under the relation between modules and vector bundles, this is directly analogous to the basic definition of topological K-theory, whence the common term. (In fact when applied to the <strong>stack of vector bundles</strong> then algebraic K-theory subsumes topological K-theory and also differential K-theory.</p>
</blockquote>
<p>Quillen 定义了环 $R$ 的高阶 <span class="link local"><a href="./K-群.html" title=" [K-群]">K-群 (代数)</a></span>, 它是某个空间 $BGL(R)^+$ 的同伦群.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="K-群(拓扑)"><header><h1><span class="taxon">Wiki. </span>“K-群 (拓扑)” <a class="slug" href="./K-群(拓扑).html">[K-群(拓扑)]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li><li class="meta-item">相对 K-群</li></ul></div></header></summary>

<p>K-群是<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span>的研究对象.</p>
<h2>定义</h2>
<p>拓扑空间 $X$ 上的<span class="link local"><a href="./复向量丛.html" title="“复向量丛” [复向量丛]">复向量丛</a></span>的同构类 $V(X)$ 在 Whitney 和下构成交换半群, 而 $K(X)$ 可定义为其群化.</p>
<p>由向量丛的拉回, $X\mapsto K(X)$ 是拓扑空间范畴到 Abel 群范畴的反变函子.</p>
<p>注意到 $K(\mathrm{pt})\simeq\mathbb Z$, 而平凡投影 $p\colon X\to \mathrm{pt}$ 诱导了同态 $p^*\colon K(\mathrm{pt})\to K(X)$. 若选定 $X$ 的基点 $j\colon \mathrm{pt}\to X$, 则 $p^*$ 为 $j^*\colon K(X)\to K(\mathrm{pt})$ 的截面, 即有直和分解
$$
K(X)\simeq \widetilde{K}(X)\oplus\mathbb Z.
$$
其中 $\widetilde{K}(X)$ 称为<span class="link local"><a href="./约化K-群.html" title=" [约化K-群]">约化 K-群 (拓扑)</a></span>. (更多定义见此页面.)</p>
<p>另见 <span class="link local"><a href="./Grothendieck群.html" title="“Grothendieck 群” [Grothendieck群]">Grothendieck 群</a></span>.</p>
<h3>等价定义: 向量丛的复形</h3>
<p>考虑 $X$ 上向量丛的链复形, 定义复形的<strong>支集</strong> (support) 为不正合的点的集合. 我们只考虑<strong>紧支集</strong>的复形.</p>
<p>定义 $X$ 上向量丛复形 $E$ 到 $F$ 的同伦为 $X\times I$ 上的复形 $G$, 使得 $G$ 限制在 $X\times 0$ 和 $X\times 1$ 上分别是 $E$ 和 $F$.</p>
<p>复形的同伦类 $C(X)$ 构成半群, 其中正合 (支集为空) 的复形构成子半群 $C_\varphi (X)$; 定义 $K(X)$ 为商半群 $C(X)/C_\varphi(X)$. 虽然由定义它只是半群, 但事实上它是群.</p>
<h2>性质</h2>
<p>$K(X)$ 只与 $X$ 的伦型有关.</p>
<h2>相对 K-群</h2>
<p>对于满足同伦扩张性质的空间对 $(X,A)$, 定义<span class="link local"><a href="./相对.html" title="相对观点 [相对]">相对</a></span> <span class="link local"><a href="./K-群.html" title=" [K-群]">相对 K-群 (拓扑)</a></span>
$$
K(X,A):= \widetilde{K}(X/A).
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="λ-环"><header><h1><span class="taxon">Wiki. </span>“λ-环” <a class="slug" href="./λ-环.html">[λ-环]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<blockquote>
<p>λ-rings are one incarnation of the representation theory of the symmetric groups</p>
</blockquote>
<blockquote>
<p>λ-rings are all about getting the most for your money when you <strong>decategorify</strong> a <strong>symmetric monoidal abelian category</strong> — for example the category of representations of a group, or the category of vector bundles on a topological space.</p>
</blockquote>
<p>λ-环到环的遗忘
$$
U \colon \Lambda\mathsf {Ring} \to \mathsf {Ring}
$$
有左右伴随 $\operatorname{Symm}\dashv U\dashv W$, 也即自由和余自由 λ-环.</p>
<p>$\operatorname{Symm}$ 是 “对称函数” 环, 其元素直观上是无穷多变量的无穷多项式, 在变量的任何排列下不变.</p>
<h2>例</h2>
<p>空间 $X$ 的<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span> $K(X)$ 具有 λ-环结构.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="拓扑指标"><header><h1><span class="taxon">Wiki. </span>拓扑指标 <a class="slug" href="./拓扑指标.html">[拓扑指标]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>向量丛之间的<span class="link local"><a href="./线性微分算子.html" title="线性微分算子 [线性微分算子]">微分算子</a></span>的拓扑指标是由<span class="link local"><a href="./拓扑K-理论.html" title="“拓扑 K-理论” [拓扑K-理论]">拓扑 K-理论</a></span>给出的一个整数, 其中涉及算子的<span class="link local"><a href="./象征.html" title="象征 [象征]">象征</a></span>.</p>
<h2>定义</h2>
<h3>示性类</h3>
<p>拓扑指标也可定义为<span class="link local"><a href="./陈特征.html" title="“陈特征” [陈特征]">陈特征</a></span>与 <span class="link local"><a href="./Todd类.html" title="“Todd 类” [Todd类]">Todd 类</a></span>之积在整个流形上的积分.</p>
</details></section></details></section></footer></article></div></body></html>