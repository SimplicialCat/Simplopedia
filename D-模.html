<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>D-模</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="D-模"><header><h1><span class="taxon">Wiki. </span>D-模 <a class="slug" href="./D-模.html">[D-模]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>D-模是<span class="link local"><a href="./微分层.html" title="微分算子层 [微分层]">微分算子环 (层)</a></span> 上的模. D-模起源于微分方程, <span class="link local"><a href="./线性偏微分方程.html" title="线性偏微分方程 [线性偏微分方程]">线性偏微分方程</a></span>是 D-模的<span class="link local"><a href="./数学对象的表现.html" title="数学对象的表现 [数学对象的表现]">表现</a></span>.</p>
<p>微分算子层 $D_X$ 上的模可以描述微分方程局部的解; 它可以描述一个解沿闭合路径一周的解析延拓与原来不同的现象, 称为<strong>单值</strong> (monodromy).</p>
<p>我们研究的主要对象是<strong>局部有限表现</strong>的 $D_X$-模, 也即<span class="link local"><a href="./凝聚层.html" title="凝聚层 [凝聚层]">凝聚</a></span> $D_X$-模. 函子
$$
\operatorname{Hom}_{D_X}(-,\mathcal O_X)\colon \mathsf {Mod}_{\text{coh}}(D_X) \to \mathsf {Mod}(\mathbb{C}_X),
$$
描述了微分方程组的解; 其<span class="link local"><a href="./导出函子.html" title="导出函子 [导出函子]">导出函子</a></span> $\operatorname{Ext}^\bullet_{D_X}(-,\mathcal O_X)$ 描述了微分方程的 “高阶解”.</p>
<h3>特征簇</h3>
<p>设 $p=q=1$, $R$ 的<span class="link local"><a href="./特征簇.html" title="特征簇 [特征簇]">特征簇</a></span>是…</p>
<h2>定义</h2>
<p>设 $X$ 是 $\mathbb C$ 上的光滑代数簇. $X$ 上的 D-模是<span class="link local"><a href="./正则微分算子.html" title="“正则微分算子” [正则微分算子]">正则微分算子</a></span>层 $D_X$ 上的模. 左 $D_X$-模即带有 $D_X$ 作用的 $\mathcal{O}_X$-模, 等同于线性映射
$$
\nabla\colon D_X \to \operatorname{End}_{\mathbb C}(M),
$$
满足</p>
<ul>
<li>$\nabla_{fv}(m)=f\nabla_v(m)$;</li>
<li>$\nabla_v(fm)=v(f) m + f\nabla_v m$;</li>
<li>$\nabla_{[v,w]}m=[\nabla_v,\nabla_w]m$.</li>
</ul>
<p>$X$ 上的 D-模也可视为带有<span class="link local"><a href="./平坦联络.html" title=" [平坦联络]">可积联络</a></span>的拟凝聚 $\mathcal{O}_X$-模.</p>
<h2>函子性</h2>
<p>与凝聚层类似, 不同代数簇上的 D-模由推出和拉回联系起来.</p>
<h2>和乐</h2>
<p>设 $M$ 为凝聚 $D_X$-模. 若其<span class="link local"><a href="./特征簇.html" title="特征簇 [特征簇]">特征簇</a></span>满足 $\dim \operatorname{Ch}(M)=\dim X$, 即特征簇的维数取到<strong>最小</strong>可能值, 则称 $M$ 为<strong>和乐</strong> (holonomic) 的.</p>
<p>和乐 $D_X$-模是线性常微分方程在高维复流形的自然推广.</p>
<h2>例</h2>
<h3>函数层作为 D-模</h3>
<p>函数层 $\mathcal O_X$ 是 D-模, 且可表现为
$$
\mathcal O_X \simeq \mathcal D_X / \mathcal D_X T_X.
$$
对于一般的 D-模 $M$, D-模同态 $\mathcal O_X \to M$ 等同于 $M$ 的平坦截面, 即被 $T_X$ 零化的截面.</p>
<h3>向量丛</h3>
<p>设 $E$ 是 $X$ 上带有<span class="link local"><a href="./平坦联络.html" title=" [平坦联络]">可积联络</a></span> $\nabla$ 的向量丛, 也即局部形如 $\bigoplus_i \mathcal O_U e_i$ 的层.</p>
<p>回忆联络 $\nabla$ 可视为丛映射 $TX\to \operatorname{End}(E)$, 满足</p>
<ul>
<li>$\nabla_{av}=a\nabla_v$;</li>
<li>$\nabla_v(as)=v(a)s+a\nabla_v s$;</li>
<li>$\nabla_{[v,w]}=[\nabla_v,\nabla_w]$ (称为可积性或平坦性; 见<span class="link local"><a href="./可积联络.html" title="“可积联络” [可积联络]">可积联络</a></span>).</li>
</ul>
<p>此时左 $D_X$-模结构即由 $v\cdot s = \nabla_v s$ 给出.</p>
<h3>“δ 函数” D-模</h3>
<p>对于 $X$ 的闭点 $x$, 有 D-模
$$
\delta_x:= \mathcal D_X / \mathcal D_X\mathfrak m_x\otimes_k\operatorname{det}T_xX.
$$
D-模同态 $\delta_x \to M$ 等同于 $M$ 上被 $\mathfrak m_x$ 零化的截面. 与直线 $\operatorname{det}T_xX$ 作张量积的目的是使得存在典范同构
$$
f_*\delta_x \simeq \delta_{f(x)}.
$$</p>
<blockquote>
<p>$\delta_x$ 是由 $\delta$ 函数和它的各阶导数张成的向量空间.</p>
</blockquote>
<h3>对偶层</h3>
<p>对偶层 $\omega = \det \Omega^1$</p>
<p>由于 Lie 导数 $L_v = [\iota_v, d]$, 对于 $\alpha\in\omega$ 有 $L_v\alpha = d \iota_v \alpha$.</p>
<p>对偶层可以把右 D-模变成左 D-模:
$$
D^{\text{op}} = \omega\otimes D \otimes \omega^{-1}
$$</p>
<h3>摩天大楼 D-模</h3>
<p>$p\in X$, 定义
$$
M_p = D_X / D_X ()
$$</p>
<h2>性质</h2>
<h3>与 de Rham 空间的关系</h3>
<p>$X$ 上的 D-模等同于 $X$ 的 <span class="link local"><a href="./deRham空间.html" title="de Rham 空间 [deRham空间]">de Rham 空间</a></span>上的拟凝聚层.</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./D-概形.html" title="D-概形 [D-概形]">D-概形</a></span></p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Beilinson–Bernstein局部化"><header><h1><span class="taxon">Wiki. </span>“Beilinson–Bernstein 局部化” <a class="slug" href="./Beilinson–Bernstein局部化.html">[Beilinson–Bernstein局部化]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>当 $X$ 为<span class="link local"><a href="./旗流形.html" title="旗流形 [旗流形]">旗流形</a></span> $\mathrm {Fl}_G$ 时, <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>的全局截面函子
$$
\Gamma(X,-) \colon \mathrm D\text{-mod}(X) \to \Gamma(X,\mathcal D_X)\text{-mod}
$$
为等价.</p>
<p>考虑 “中心商” $\Gamma(\mathrm {Fl}_G,\mathcal D)\simeq\mathcal U_0\mathfrak g := \mathcal U\mathfrak g\otimes_{Z\mathfrak g}k_\chi$, 其中 $k_\chi$ 是平凡 $\mathfrak g$-表示对应的中心特征. 记 $\mathcal U_0\mathfrak g$-模的范畴为 $\mathfrak g\text{-}\mathrm {mod}_0$, 即具有平凡中心特征的 $\mathfrak g$-模的范畴. 那么 Beilinson–Bernstein 局部化可表述为
$$
\Gamma(\mathrm {Fl}_G,-)\colon \mathrm D\text{-mod}(\mathrm {Fl}_G) \to \mathfrak g\text{-}\mathrm {mod}_0
$$
为等价.</p>
<blockquote>
<p>We have discussed above only the case of the trivial central character. Beilinson–Bernstein in fact proved a similar statement for any regular central character.</p>
</blockquote>
<p>例如,</p>
<ul>
<li>微分算子层 $\mathcal D$ 对应的是 $\mathcal U\mathfrak g$.</li>
<li>结构层 $\mathcal O$ 对应的是 $k$.</li>
<li>对于点 $x\in\mathrm {Fl}_G$, $\delta_x$ 对应的是 <span class="link local"><a href="./Verma模.html" title="“Verma 模” [Verma模]">Verma 模</a></span> $\mathcal U\mathfrak g\otimes_{\mathcal U\mathfrak b}\operatorname{det}(\mathfrak g/\mathfrak b)$, 其中 Borel 子群 $B$ 是 $x$ 的稳定子群.</li>
</ul>
<p>这个等价不仅是范畴等价, 还是 $G$-表示的等价. 其中, 元素 $g\in G$ 作用在 $\mathfrak g$-模范畴上的方式是伴随表示 $(\operatorname{Ad}_g)_*$.</p>
<h2>局部化伴随</h2>
<p>在一般情形, 代数群 $K$ 作用于光滑代数簇 $X$ 上, 给出一个全局截面函子
$$
\Gamma(X,-) \colon \mathrm D\text{-}\mathrm {mod}(X) \to \mathfrak k\text{-}\mathrm {mod}.
$$
这个函子有左伴随, 称为局部化
$$
\mathrm {Loc}\colon \mathfrak k\text{-}\mathrm {mod} \to \mathrm D\text{-}\mathrm {mod}(X),\ M\mapsto \mathcal D_X\otimes_{\mathcal U\mathfrak k}M.
$$
我们不仅要让群 $K$ 作用在 $\mathrm D\text{-}\mathrm {mod}(X)$ 上, 还要让 $\mathrm D\text{-}\mathrm {mod}(K)$ (在卷积下构成的幺半群) 作用在 $\mathrm D\text{-}\mathrm {mod}(X)$ 上, 这和群表示等同于群代数的表示是一样的道理.</p>
<p>另一方面, $\mathfrak {k}\text{-}\mathrm {mod}$ 也可写成某种 D-模的范畴: 它是 $K$ 上的弱等变 D-模范畴 $\mathrm D\text{-}\mathrm {mod}(K)^{K,w}$, 而这个范畴自然具有卷积给出的 $\mathrm D\text{-}\mathrm {mod}(K)$-作用.</p>
<p>总之, 我们有 $\mathrm D\text{-}\mathrm {mod}(K)$-等变函子的伴随
$$
\mathrm {Loc} \colon \mathfrak k\text{-}\mathrm {mod}\rightleftarrows \mathrm D\text{-}\mathrm {mod}(X) \colon \Gamma(X,-).
$$
而在 Beilinson–Bernstein 局部化的情形中, 原来的等价升级为 $\mathrm D\text{-}\mathrm {mod}(G)$-表示的等价
$$\Gamma(\mathrm {Fl}_G,-)\colon \mathrm D\text{-mod}(\mathrm {Fl}_G) \to \mathfrak g\text{-}\mathrm {mod}_0.$$</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./Harish-Chandra模.html" title="Harish-Chandra 模 [Harish-Chandra模]">Harish-Chandra 模</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="D-几何"><header><h1><span class="taxon">Wiki. </span>“D-几何” <a class="slug" href="./D-几何.html">[D-几何]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p><span class="link local"><a href="./综合微分几何.html" title="综合微分几何 [综合微分几何]">综合微分几何</a></span>的一种, 其关注点在 <span class="link local"><a href="./deRham空间.html" title="de Rham 空间 [deRham空间]">de Rham 空间</a></span>. de Rham 空间上的拟凝聚层即为 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Harish-Chandra模"><header><h1><span class="taxon">Wiki. </span>Harish-Chandra 模 <a class="slug" href="./Harish-Chandra模.html">[Harish-Chandra模]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li><li class="meta-item">几何表示论</li></ul></div></header></summary>
<h2>定义</h2>
<p>设 $H\subset G$ 是代数子群, $\mathfrak g$ 是 $G$ 的 <span class="link local"><a href="./Lie代数.html" title="Lie 代数 [Lie代数]">Lie 代数</a></span>. 一个 $\mathfrak g$-模称为 Harish-Chandra 模 (又称 $(\mathfrak g,H)$-模) 是指其 $\mathfrak h$-作用可积为 $H$-作用. (这是一个性质而非额外结构.)</p>
<p>更一般地, 设代数群 $K$ 作用于 Lie 代数 $\mathfrak g$ 上, 且有 Lie 代数的嵌入 $\mathfrak{k} \to \mathfrak g$, 满足</p>
<ul>
<li>$K$ 在 $\mathfrak k$ 上的伴随作用与 $K$ 在 $\mathfrak g$ 上的作用相容;</li>
<li>$\mathfrak k$ 在 $\mathfrak g$ 上的伴随作用与诱导自 $K$ 的作用相同.</li>
</ul>
<p>一个 Harish-Chandra $(\mathfrak g,K)$-模是一个 $\mathfrak g$-模和 $K$-模 $M$, 两者诱导的 $\mathfrak k$-模结构相同, 且 $\mathfrak g\otimes M\to M$ 是 $K$-模同态.</p>
<h3>作为形式群概形的表示</h3>
<p>Harish-Chandra 二元组 $(\mathfrak g,K)$ 给出一个<span class="link local"><a href="./形式概形.html" title="形式概形 [形式概形]">形式群概形</a></span> $\exp (\mathfrak g,K)$, Harish-Chandra $(\mathfrak g,K)$-模等同于 $\exp(\mathfrak g,K)$-表示.</p>
<h2>例</h2>
<p>若 $\mathfrak g$ 半单, 则中心商 $U_0\mathfrak g:= U\mathfrak g\otimes_{Z(\mathfrak g)}k_{\chi}$ ($\chi\colon Z(\mathfrak g)\to k$ 是 $Z(\mathfrak g)$ 作用在平凡 $\mathfrak g$-表示上给出的特征) 只是平凡子群的 Harish-Chandra 模.</p>
<p>平凡模 $k$ 是 $G$ 自身的 Harish-Chandra 模.</p>
<p><span class="link local"><a href="./Verma模.html" title="“Verma 模” [Verma模]">Verma 模</a></span> $\mathcal U\mathfrak g\otimes_{\mathcal U\mathfrak b}\operatorname{det}(\mathfrak g/\mathfrak b)$ 是 $(\mathfrak g,B)$-模.</p>
<p>更一般地, 对于 $H$-表示 $W$,
$$
\mathcal U\mathfrak g\otimes_{\mathcal U\mathfrak h} W
$$
是 $(\mathfrak g,H)$-模.</p>
<h2>与 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>的关系</h2>
<p>在几何侧, <span class="link local"><a href="./Beilinson–Bernstein局部化.html" title="“Beilinson–Bernstein 局部化” [Beilinson–Bernstein局部化]">Beilinson–Bernstein 局部化</a></span>将 Harish-Chandra 模对应到 $H$-等变 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>的子范畴 $\mathrm D\text{-}\mathrm {mod}(\mathrm {Fl}_G)^H\subset \mathrm D\text{-}\mathrm {mod}(\mathrm {Fl}_G)$.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Hecke范畴"><header><h1><span class="taxon">Wiki. </span>Hecke 范畴 <a class="slug" href="./Hecke范畴.html">[Hecke范畴]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>对于<span class="link local"><a href="./约化群.html" title="“约化群” [约化群]">约化群</a></span> $G$ 的 <span class="link local"><a href="./Borel子群.html" title="Borel 子群 [Borel子群]">Borel 子群</a></span> $B$, Hecke 范畴大致是 “双商叠”
$$
B \backslash G / B = \mathbf{B}B\times_{\mathbf{B}G} \mathbf{B}B
$$
上的层范畴
$$
\mathcal H = \mathsf{Sh}(B \backslash G / B).
$$
其中 $\mathsf{Sh}$ 是某个层理论, 例如 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>.</p>
<p>更一般地 (参考 <span class="link local"><a href="./BenZviNadlerChG.html" title="The Character Theory of a Complex Group [BenZviNadlerChG]">Ben-Zvi–Nadler</a></span>), 对<span class="link local"><a href="./叠.html" title="叠 [叠]">叠</a></span>的映射 $f\colon X\to Y$, 可定义 Hecke 范畴
$$
\mathcal H = \mathsf{Sh}(X\times_Y X),
$$
由 $X\times_Y X\times_Y X$ 到 $X\times_Y X$ 的三个投影映射的推前-拉回可定义 $\mathcal H$ 上的一种<span class="link local"><a href="./卷积.html" title="卷积 [卷积]">卷积</a></span>.</p>
<h2>性质</h2>
<h3>卷积</h3>
<p><span class="link local"><a href="./卷积.html" title="卷积 [卷积]">卷积</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Hopf代数"><header><h1><span class="taxon">Wiki. </span>Hopf 代数 <a class="slug" href="./Hopf代数.html">[Hopf代数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>Hopf 代数可视为群的推广; 它具有<span class="link local"><a href="./双代数.html" title="双代数 [双代数]">双代数</a></span>结构与一个对径映射, 对径映射可视为群中取逆运算的推广.</p>
<p>Hopf 代数上的模范畴是群表示范畴的推广.</p>
<p>另见<span class="link local"><a href="./量子群.html" title="量子群 [量子群]">量子群</a></span>.</p>
<p>另见<span class="link local"><a href="./交换Hopf代数.html" title="交换 Hopf 代数 [交换Hopf代数]">交换 Hopf 代数</a></span>.</p>
<h2>定义</h2>
<h3>传统定义</h3>
<p><span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半 $1$-范畴</a></span>中的 Hopf 代数是<span class="link local"><a href="./双代数.html" title="双代数 [双代数]">双代数</a></span> $(A,m,\eta,\epsilon,\Delta)$ 带有对径映射 $S\colon A\to A$, 满足
$$
m (\mathrm{id} \otimes S) \Delta = m (S \otimes \mathrm{id}) \Delta = \eta\epsilon,
$$</p>
<p>若 Hopf 代数满足 $S^2=\mathrm{id}$, 则称之为<strong>对合 Hopf 代数</strong> (involutive Hopf algebra). 有时我们默认这个条件成立.</p>
<h2>性质</h2>
<p>Hopf 代数的对偶也是 Hopf 代数.</p>
<h2>例</h2>
<h3>群代数</h3>
<p>对于交换环 $k$ 与群 $G$, 群代数 $k[G]$ 是 Hopf 代数; 其对偶为群 $G$ 上的 $k$-值函数空间 $\operatorname{Hom}(k[G],k)$ 在卷积下构成的代数.</p>
<p>类似地, 对于有限型代数群 $G$, 其上 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>的范畴 $D\text{-}\mathsf{Mod}(G)$ 是 <span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">$\mathsf{DGCat}$</a></span> 中的 Hopf 代数.</p>
<h3>泛包络代数</h3>
<p>Lie 代数 $\mathfrak g$ 的<span class="link local"><a href="./泛包络代数.html" title="泛包络代数 (Lie 代数) [泛包络代数]">泛包络代数</a></span> $\mathcal U\mathfrak g$ 是 Hopf 代数:</p>
<ul>
<li>余乘法 $\Delta\colon \mathcal U\mathfrak g\to\mathcal U\mathfrak g\otimes\mathcal U\mathfrak g\simeq\mathcal U(\mathfrak g\times\mathfrak g)$ 由对角映射 $\mathfrak g\to\mathfrak g\times\mathfrak g$ 诱导, 其在 $X\in\mathfrak g$ 上的作用为 $\Delta(X)= X\otimes 1+1\otimes X$.</li>
<li>对极映射 $S\colon \mathcal U\mathfrak g\to\mathcal U\mathfrak g$ 由 $-\mathrm{id}\colon \mathfrak g\to\mathfrak g$ 诱导.</li>
</ul>
<p><span class="link local"><a href="./仿射代数群.html" title="“仿射代数群” [仿射代数群]">仿射代数群</a></span></p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./Cartier对偶.html" title="“Cartier 对偶” [Cartier对偶]">Cartier 对偶</a></span></p>
<p><span class="link local"><a href="./拟三角Hopf代数.html" title="拟三角 Hopf 代数 [拟三角Hopf代数]">拟三角 Hopf 代数</a></span></p>
<p><span class="link local"><a href="./交换Hopf代数.html" title="交换 Hopf 代数 [交换Hopf代数]">交换 Hopf 代数</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Langlands纲领"><header><h1><span class="taxon">Wiki. </span>“Langlands 纲领” <a class="slug" href="./Langlands纲领.html">[Langlands纲领]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li><li class="meta-item">[]</li></ul></div></header></summary>

<table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><span class="link local"><a href="./椭圆曲线.html" title="“椭圆曲线” [椭圆曲线]">椭圆曲线</a></span></td><td>←</td><td>Ramanujan</td><td>→</td><td><span class="link local"><a href="./自守形式.html" title="“自守形式” [自守形式]">自守形式</a></span></td></tr>
<tr><td>↓</td><td></td><td></td><td></td><td>↓</td></tr>
<tr><td>$\operatorname{Gal}(\overline{F}/F) \to {^LG}$, Frobenius</td><td>←</td><td>原始 <span class="link local"><a href="./Langlands对应.html" title="“Langlands 对应” [Langlands对应]">Langlands 对应</a></span></td><td>→</td><td>$\mathbb G(\mathbb A_F)$ 的<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span>, Hecke</td></tr>
<tr><td>↓</td><td></td><td></td><td></td><td>↓</td></tr>
<tr><td>曲线上的平坦 ${^LG}$-丛</td><td>←</td><td><span class="link local"><a href="./几何Langlands对应.html" title="几何 Langlands 对应 [几何Langlands对应]">几何 Langlands 对应</a></span></td><td>→</td><td><span class="link local"><a href="./主丛的模空间.html" title="“主丛的模空间” [主丛的模空间]">主丛的模空间</a></span> $\mathrm {Bun}_G$ 上的 Hecke 特征层</td></tr>
<tr><td>↓</td><td></td><td></td><td></td><td>↓</td></tr>
<tr><td>$\mathrm {Loc}_{^LG}$ 上的导出范畴</td><td>←</td><td>范畴 Langlands 对应</td><td>→</td><td>$\mathrm {Bun}_G$ 上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>导出范畴</td></tr>
</tbody></table>
<p>故事从 Euler 开始. Euler 用不严格的方法算出了自然数的 $s$ 次方的倒数和 ($s\geq 2$ 为自然数), 这个数后来叫做 <span class="link local"><a href="./Riemannζ-函数.html" title="Riemann ζ-函数 [Riemannζ-函数]">Riemann ζ-函数</a></span> $\zeta(s)$. 除此之外, Euler 还指出 $\zeta(s)$ 可写成所谓 “<strong>Euler 因子</strong>” $1/(1-p^{-s})$ 对素数 $p$ 的乘积, 由此可以推出素数分布的一些信息. Riemann 发现 $\zeta(s)$ 是全纯函数, 从而自然地寻求其解析延拓. 这件事可以用 Euler 的乘积公式以及 $\zeta(s)$ 满足的<strong>函数方程</strong>
$$
\Lambda(1-s)=\Lambda(s),\ \Lambda(s)=\pi^{-s/2}\Gamma(s/2)\zeta(s)
$$
来做到. (奇妙的是, Euler 使用他的发散级数发现了 $\zeta(s)$ 的函数方程.) 这个函数方程中的 $\Gamma$ 项直到 Tate 才获得完全的理解: 它是 $\mathbb{Q}$ 的 Archimedes <span class="link local"><a href="./位.html" title="“位” [位]">位</a></span>的 Euler 因子.</p>
<p>后来, Riemann 建立了一个显式的公式, 将素数和 $\zeta$ 函数的零点关联起来. 由此他猜想 $\zeta$ 的零点的实部为 $1/2$, 这相当于素数分布的一个极好的性质.</p>
<p>Dirichlet 在研究模 $q$ 余 $a$ 素数的分布时用到了所谓 Dirichlet <span class="link local"><a href="./L-函数.html" title="“L-函数” [L-函数]">L-函数</a></span>. 他的方法可理解为 $\mathbb{Z}/q$ 上的调和分析. 设 $\chi\colon (\mathbb{Z}/q)^\times \to\mathbb{C}^\times$ 为 <span class="link local"><a href="./Dirichlet特征.html" title="“Dirichlet 特征” [Dirichlet特征]">Dirichlet 特征</a></span>, 定义
$$
L(\chi,s)=\sum_{n}\chi(n)n^{-s} = \prod_p 1/(1-\chi(p)p^{-s}).
$$</p>
<h2>相关概念</h2>
<p><span class="link local"><a href="./Weil罗塞塔石碑.html" title="“Weil 罗塞塔石碑” [Weil罗塞塔石碑]">Weil 罗塞塔石碑</a></span>, <span class="link local"><a href="./函数域类比.html" title="函数域类比 [函数域类比]">函数域类比</a></span></p>
<p><span class="link local"><a href="./局部几何Langlands对应.html" title="“局部几何 Langlands 对应” [局部几何Langlands对应]">局部几何 Langlands 对应</a></span></p>
<p><span class="link local"><a href="./镜对称.html" title="“镜对称” [镜对称]">镜对称</a></span></p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Riemann--Hilbert对应"><header><h1><span class="taxon">Wiki. </span>“Riemann–Hilbert 对应” <a class="slug" href="./Riemann--Hilbert对应.html">[Riemann--Hilbert对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Riemann–Hilbert 对应是 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>理论的基本定理, 解答了 <span class="link local"><a href="./Hilbert第21问题.html" title="“Hilbert 第 21 问题” [Hilbert第21问题]">Hilbert 第 21 问题</a></span>.</p>
<p>Riemann–Hilbert 对应的最简单版本是: 一个空间上的<span class="link local"><a href="./平坦向量丛.html" title=" [平坦向量丛]">可积联络</a></span>范畴对应<span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span>的范畴.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Weil罗塞塔石碑"><header><h1><span class="taxon">Wiki. </span>“Weil 罗塞塔石碑” <a class="slug" href="./Weil罗塞塔石碑.html">[Weil罗塞塔石碑]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p><span class="link local"><a href="./函数域类比.html" title="函数域类比 [函数域类比]">函数域类比</a></span></p>
<table><thead><tr><th>数域</th><th>有限域</th><th>几何</th><th>量子物理</th></tr></thead><tbody>
<tr><td>数域</td><td>有限域上的曲线</td><td><span class="link local"><a href="./Riemann面.html" title="“Riemann 面” [Riemann面]">Riemann 面</a></span> $X$</td><td></td></tr>
<tr><td>$\mathbb{Q}_p$</td><td>$\mathbb F_q((t))$</td><td></td><td></td></tr>
<tr><td>Galois 表示</td><td></td><td>$X$ 上的平坦 $\mathrm{GL}_n$-丛</td><td></td></tr>
<tr><td>自守表示</td><td></td><td>$X$ 上 $\mathrm{GL}_n$-丛模叠上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span></td><td></td></tr>
<tr><td></td><td></td><td>带联络的全纯 $^LG$-丛</td><td></td></tr>
<tr><td></td><td></td><td><span class="link local"><a href="./主丛的模空间.html" title="“主丛的模空间” [主丛的模空间]">主丛的模空间</a></span> $\mathrm{Bun}_G$ 上的 <span class="link local"><a href="./Hecke特征层.html" title="Hecke 特征层 [Hecke特征层]">Hecke 特征层</a></span></td><td></td></tr>
</tbody></table>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="deRham空间"><header><h1><span class="taxon">Wiki. </span>de Rham 空间 <a class="slug" href="./deRham空间.html">[deRham空间]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>$X$ 的 de Rham 空间是将 $X$ 上 “<span class="link local"><a href="./无穷接近的点.html" title="无穷接近的点 [无穷接近的点]">无穷接近的点</a></span>等同起来” 得到的空间.</p>
<p>de Rham 空间是无穷小道路群胚的逆范畴化, 而带平坦联络的向量丛等同于无穷小道路群胚上的等变向量丛, 这解释了 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>为何是带平坦联络的向量丛的推广.</p>
<h2>定义</h2>
<h3>函子式</h3>
<p>以<span class="link local"><a href="./点函子.html" title="点函子 [点函子]">点函子</a></span>表达, 概形 $X$ 的 <strong>de Rham 空间</strong> 是如下函子 $X_{\mathrm{dR}}\colon \mathsf{Ring} \to \mathsf{Set}$,
$$
X_{\text{dR}}(R) := X(R/I),
$$
其中 $I$ 是 $R$ 的幂零根 (nilpotent radical).</p>
<h3>对角线形式邻域的商</h3>
<p>$X_{\text{dR}}$ 也可表示为 $X$ 的商. 定义 $X_{\text{inf}}\to X\times X$ 为对角线的<span class="link local"><a href="./形式邻域.html" title="形式邻域 [形式邻域]">形式邻域</a></span>, 则
$$
X_{\text{dR}} = \operatorname{coeq}(X_{\text{inf}}\rightrightarrows X).
$$</p>
<h2>性质</h2>
<h3>D-模</h3>
<p>$$
\mathsf {QCoh}(X_{\text{dR}})\simeq D\mathsf {-Mod}(X).
$$</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="几何Langlands对应"><header><h1><span class="taxon">Wiki. </span>几何 Langlands 对应 <a class="slug" href="./几何Langlands对应.html">[几何Langlands对应]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<blockquote>
<p>Recently, in a groundbreaking advance, Kapustin and Witten have linked the geometric Langlands correspondence and the S-duality of 4D supersymmetric gauge theories. This and subsequent works have already led to striking new insights into the geometric Langlands Program, which in particular involve the Homological Mirror Symmetry of the Hitchin moduli spaces of Higgs bundles on algebraic curves associated to two Langlands dual Lie groups.</p>
</blockquote>
<p><span class="link local"><a href="./Hitchin模叠.html" title="“Hitchin 模叠” [Hitchin模叠]">Hitchin 模叠</a></span></p>
<p><span class="link local"><a href="./Galois表示.html" title=" [Galois表示]">Galois 表示</a></span>理解为 <span class="link local"><a href="./l-进局部系统.html" title=" [l-进局部系统]">l-进层</a></span>.</p>
<p>非分歧<span class="link local"><a href="./自守表示.html" title="“自守表示” [自守表示]">自守表示</a></span>给出 $\mathrm{GL}_n(F) \backslash \mathrm{GL}_n(\mathbb A) / \mathrm{GL}_n(\mathcal O)$ 上的函数 $f_\pi$ (差一个常数), 它是 <span class="link local"><a href="./Hecke代数.html" title=" [Hecke代数]">Hecke 代数</a></span> $\mathcal H_x, x\in X$ 的特征函数. 使用 <span class="link local"><a href="./Grothendieck函数–层字典.html" title="“Grothendieck 函数–层字典” [Grothendieck函数–层字典]">Grothendieck 函数–层字典</a></span>,</p>
<h2>范畴式几何 Langlands 对应</h2>
<p>范畴式几何 Langlands 对应的主旨是两个 <span class="link local"><a href="./微分分次范畴.html" title="微分分次范畴 [微分分次范畴]">DG 范畴</a></span>的比较:</p>
<ul>
<li>几何 (“自守”) 侧, 即 $X$ 上 $G$-丛的<span class="link local"><a href="./模叠.html" title=" [模叠]">模空间</a></span>上的 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>;</li>
<li>谱 (“Galois”) 侧, 即 $X$ 上 $\check G$-<span class="link local"><a href="./局部系统.html" title="局部系统 [局部系统]">局部系统</a></span>的叠上的<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>.</li>
</ul>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="微局部"><header><h1><span class="taxon">Wiki. </span>“微局部” <a class="slug" href="./微局部.html">[微局部]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p><span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>不仅是 $X$ 上的层, 而且生活在 $X$ 的<span class="link local"><a href="./余切丛.html" title=" [余切丛]">切丛</a></span>上.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="线性偏微分方程"><header><h1><span class="taxon">Wiki. </span>线性偏微分方程 <a class="slug" href="./线性偏微分方程.html">[线性偏微分方程]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<h3>朴素定义</h3>
<p><strong>线性偏微分方程</strong> (linear PDE) 是如下形式的方程 (组):
$$
\sum_{j=1}^p R_{ij} u_j =0,\quad 1\leq i \leq q,
$$
其中 $R_{ij}$ 为<span class="link local"><a href="./微分算子.html" title=" [微分算子]">线性微分算子</a></span>, $u_j$ 为变量 $x_1,\cdots,x_n$ 的函数. 名称中 “线性” 的意思是, 方程的若干个解的 (常系数) 线性组合仍是一个解.</p>
<h3>抽象定义</h3>
<p>设 $D$ 是某种<span class="link local"><a href="./线性微分算子.html" title="线性微分算子 [线性微分算子]">线性微分算子</a></span>构成的<span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">结合代数</a></span>. 定义<strong>线性偏微分方程组</strong>为左 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">$D$-模</a></span>同态
$$
R\colon D^p \to D^q.
$$
这相当于 $D$ 上的一个矩阵 $(R_{ij})$. 注意在同态 $R$ 中, $R_{ij}$ 是<strong>右乘</strong>在 $D^p$ 的分量上.</p>
<p>对于左 $D$-模 $N$, 定义上述的 $R$ 在 $N$ 中的<strong>解</strong>为左 $D$-模同态 $u\colon D^q\to N$, 满足
$$
u\circ R = 0.
$$
这相当于选取 $N$ 的 $q$ 个元素 $u_i\,(1\leq i\leq q)$ 满足
$$
\sum_{j=1}^p R_{ij} u_j =0,\quad 1\leq i \leq q,
$$
即得到朴素的定义.</p>
<p>换言之, 线性偏微分方程组 $R$ 在 $N$ 中的<strong>解空间</strong>就是
$$
\operatorname{Hom}_{D}(\operatorname{coker}R,N).
$$
这个解空间仅依赖于 $\operatorname{coker}R$ 这个左 $D$-模, 而同态 $R$ 是这个左 $D$-模的表现.
于是我们发现<strong>线性偏微分方程组</strong>就是左 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">$D$-模</a></span>的<span class="link local"><a href="./数学对象的表现.html" title="数学对象的表现 [数学对象的表现]">表现</a></span>.</p>
</details></section><section class="block" data-taxon="notion"><details ><summary id="语法–语义对偶"><header><h1><span class="taxon"><span class="link local"><a href="./notion.html" title="观念 [notion]">notion</a></span></span>语法–语义对偶 <a class="slug" href="./语法–语义对偶.html">[语法–语义对偶]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>常常, 一种数学结构可以表示为一个映射
$$
\text{语法} \to \text{语义},
$$
其中</p>
<ul>
<li>“语法” 是由少量信息<span class="link local"><a href="./数学对象的表现.html" title="数学对象的表现 [数学对象的表现]">表现</a></span>的一个较为抽象的结构, 通常是一个代数或一个范畴 (见<span class="link local"><a href="./语法范畴.html" title="语法范畴 [语法范畴]">语法范畴</a></span>), 其中的元素或对象记录了某种语言 (如某种<span class="link local"><a href="./一阶语言.html" title="一阶语言与一阶逻辑 [一阶语言]">一阶语言</a></span>);</li>
<li>“语义” 是某一类较为具体的, 或在实践中自然出现的代数对象;</li>
<li>这个函子表达的是一个指定的结构相当于<strong>给语法的每个对象赋予一个具体的意义</strong>的过程 (如<span class="link local"><a href="./一阶语言的解释.html" title="一阶语言的解释 [一阶语言的解释]">一阶语言的解释</a></span>); 也称为一个<strong>理论</strong>的<strong>模型</strong>.</li>
</ul>
<h3>代数–几何对偶, 与分类空间的联系</h3>
<p>若将上述的 “语法” 和 “语义” 视为代数对象, 则从<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">对偶</a></span>的几何侧来看, 一个数学结构是一个映射
$$
\text{参数空间} \to \text{分类空间},
$$</p>
<p>其中</p>
<ul>
<li>参数空间是某个在实践中自然出现的几何对象;</li>
<li><strong>参数空间</strong>是<strong>语义</strong>的对偶;</li>
<li><strong></strong><span class="link local"><a href="./分类空间.html" title="分类空间 [分类空间]">分类空间</a></span>是<strong>语法</strong>的对偶;</li>
<li>这个映射表达的是一个指定的结构相当于<strong>对参数空间的每一个点赋予一个结构</strong>的过程.</li>
</ul>
<h2>例</h2>
<h3>代数方程组的解</h3>
<p>多项式方程 $f(x)=0$ 在环 $A$ 中的解可以表示为环同态
$$
\mathbb{Z}[x]/(f) \to A,
$$
其中 $x$ 在 $A$ 中的像即是这个解,</p>
<ul>
<li>$\mathbb{Z}[x]/(f)$ 是记录<strong>语法</strong>的代数对象,</li>
<li>$A$ 是记录<strong>语义</strong>的代数对象.</li>
</ul>
<p>(当然, 本例也可推广到多个变量, 多个方程构成的方程组. 类似地, 微分方程组的解可表示为 <span class="link local"><a href="./D-模.html" title="D-模 [D-模]">D-模</a></span>的同态.)</p>
<p>在<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数–几何对偶</a></span>之下, 环同态 $\mathbb{Z}[x]/(f) \to A$ 对应<span class="link local"><a href="./仿射概形.html" title="仿射概形 [仿射概形]">仿射概形</a></span>的映射
$$
\operatorname{Spec} A \to \operatorname{Spec}\mathbb{Z}[x]/(f) = \{x\in \mathbb A^1 \mid f(x) = 0\}.
$$
其中</p>
<ul>
<li>$\operatorname{Spec}A$ 是<strong>参数空间</strong>,</li>
<li>$\operatorname{Spec}\mathbb{Z}[x]/(f)$ 是方程的解的<strong>分类空间</strong>.</li>
</ul>
<h3>交换半群</h3>
<p>考虑有限集关于无交并构成的<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span> $\mathsf{Fin}^{\sqcup}$,
以及集合关于乘积构成的对称幺半范畴 $\mathsf{Set}^\times$.
那么一个对称幺半函子
$$
	\mathsf{Fin}^{\sqcup} \to \mathsf{Set}^\times
$$
等同于一个交换半群.
具体地, 交换半群 $A$ 给出函子
$$
\{1,\cdots,n\} \mapsto A^n,\quad
\varnothing\mapsto \{*\},
$$
其中映射 $\{1,2\} \to \{1\}$ 对应的映射 $A^2\to A$ 正是 $A$ 上的运算; 映射 $\varnothing\to\{1\}$ 对应的映射 $\{*\}\to A$ 正是其单位元.</p>
<p>在本例中, $\mathsf{Set}^\times$ 可以替换为任何对称幺半范畴 $\mathcal D$, 称对称幺半函子 $\mathsf{Fin}^\sqcup \to \mathcal D$ 为 $\mathcal D$ 中的<span class="link local"><a href="./交换代数.html" title="交换代数 [交换代数]">交换代数</a></span>. 例如交换环 $R$ 上的模关于张量积构成的范畴 $\mathsf{Mod}_R^\otimes$ 中的交换代数就是通常说的交换 $R$-代数.
因此我们借用范畴逻辑学的术语, 称 $\mathsf{Fin}^\sqcup$ 记录了交换代数的<strong>语法</strong> (syntax), 而种种具体的交换代数都是这个范畴到其它对称幺半范畴的函子, 称之为<strong>语义</strong> (semantics).</p>
</details></section></details></section></footer></article></div></body></html>