<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>Brauer 群</title><link rel="icon" href="./assets/favicon.ico" /><template id="inline-section">
  <section class="inline block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || null;
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = taxon ? `${taxon}. ` : "";
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  const THEME_KEY = `kodama-theme`;

  function storeSelectedTheme(name) {
    localStorage.setItem(THEME_KEY, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(THEME_KEY) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }
    }
    applyDynamicColorInvert();
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');

  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const DYNAMIC_STYLE_ID = 'dynamic-color-invert-style';
  const SOLVED_COLOR_KEY = "solved-";

  function memorizedSolvedFilter(color) {
    const colorKey = SOLVED_COLOR_KEY + color;
    const storedFilterOption = localStorage.getItem(colorKey);
    if (storedFilterOption) {
      return storedFilterOption;
    } else {
      const filter = solveColor(color).filter;
      localStorage.setItem(colorKey, filter);
      return filter;
    }
  }

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const filter = memorizedSolvedFilter(rgb);

      const existingStyle = document.getElementById(DYNAMIC_STYLE_ID);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = DYNAMIC_STYLE_ID;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><script>
  (() => {
    const url = "/kodama.json";
    const interval = 1000; // 1 second

    let lastModified = null;

    async function check() {
      try {
        const res = await fetch(url + "?t=" + Date.now(), {
          method: "HEAD",
          cache: "no-store",
        });

        const lm = res.headers.get("last-modified");

        if (lastModified && lm && lm !== lastModified) {
          location.reload();
          return;
        }

        lastModified = lm || lastModified;
      } catch (e) {
        // Ignore
        console.warn("Reload check failed:", e);
      }

      setTimeout(check, interval);
    }

    check();
  })();
</script><!-- Also see: https://katex.org/docs/autorender -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<!-- Also see: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script>
<link rel="stylesheet" href="./main.css"><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style></head><body><header class="header"><nav class="nav"><div class="logo"><span class="cursor-pointer" onclick="window.location.href='./index.html'" title="单纯百科 Simplopedia">« 单纯百科 Simplopedia</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="./"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"></div></nav>

<article><section class="block" data-taxon="Wiki"><details open><summary id="Brauer群"><header><h1><span class="taxon">Wiki. </span>Brauer 群 <a class="slug" href="./Brauer群.html">[Brauer群]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>概形的 <strong>Brauer 群</strong>是其上 <span class="link local"><a href="./Azumaya代数.html" title="Azumaya 代数 [Azumaya代数]">Azumaya 代数</a></span>的相似类在张量积下构成的群; Azumaya 代数 $A$ 在 <span class="link local"><a href="./Morita范畴.html" title="Morita 范畴 [Morita范畴]">Morita 范畴</a></span>中可逆; 因此其上的模范畴 $\mathsf{Mod}(A)$ 是可逆线性范畴.</p>
<p><span class="link local"><a href="./向量丛.html" title="向量丛 [向量丛]">向量丛</a></span>的自同态丛是 Azumaya 代数, 其对应的 Brauer 类平凡.</p>
<blockquote>
<p>Brauer groups and Azumaya algebras play an important role in many areas of mathematics, but especially in arithmetic geometry, algebraic geometry, and applications to mathematical physics. In arithmetic geometry, they are closely related to Tate’s conjecture on l-adic cohomology of schemes over finite fields, and they play a critical role in studying rational points of varieties through, for example, the Brauer Manin obstructions to the Hasse principle. In algebraic geometry, Azumaya algebras arise naturally when studying moduli spaces of vector bundles, and Brauer classes appear when considering certain constructions motivated from physics in homological mirror symmetry. The Brauer group was also used by Artin-Mumford (AM72) to construct one of the first examples of a non-rational unirational complex variety.</p>
</blockquote>
<h2>定义</h2>
<h3>域</h3>
<p>域 $K$ 的 Brauer 群 $\mathrm{Br}(K)$ 是其上的<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>的相似类关于张量积构成的群, 也即上同调
$$
H^2(\operatorname{Gal}(K_{\mathrm{sep}}/K),K^*_{\mathrm{sep}}) = H^2(\operatorname{Spec}K_{\mathrm{et}},\mathbb G_{\mathrm{m}}).
$$</p>
<p>设 $A,B$ 为 $K$ 上的有限维中心单代数, 若存在 $n,m\in\mathbb{Z}_+$ 使得 $M_n(A)\simeq M_m(B)$ (作为 $K$-代数), 则称 $A$ 与 $B$ 相似.</p>
<p>$A$ 与 $B$ 相似当且仅当存在可除代数 $D$ 使得 $A,B$ 均为 $D$ 上的矩阵代数.</p>
<p><strong>例</strong>. $\mathrm{Br}(\mathbb{R})\simeq \{[\mathbb{R}],[\mathbb H]\}$. $\mathbb H\otimes\mathbb H\simeq M_4(\mathbb{R})$.</p>
<p><strong>例</strong>. 有限域的 Brauer 群平凡, 因为有限除环都是域.</p>
<h3>环</h3>
<h4>与模范畴的关系</h4>
<p>设 $R$ 为交换环, 考虑 $2$-范畴 $\mathsf{Alg}_R$, 其对象为 $R$-代数 (即 $R$-模范畴中的幺半群), 态射为双模, 态射的复合为张量积, $2$-态射为双模的同态.</p>
<p>考虑 $\mathsf{Alg}_R$ 的<span class="link local"><a href="./对象的生象.html" title="对象的生象 [对象的生象]">核</a></span> $\mathrm{Core}(\mathsf{Alg}_R)$, 其对象为 $R$-代数, 态射为 Morita 等价, $2$-态射为双模的同构.</p>
<blockquote>
<p>This may be understood as the $2$-groupoid of (generalized) line $2$-bundles over $\operatorname{Spec}R$, inside that of all $2$-vector bundles.</p>
</blockquote>
<ul>
<li>$\pi_0(\mathbf{Br}(R))$ 为 $R$ 的 Brauer 群;</li>
<li>$\pi_1(\mathbf{Br}(R))$ 为 $R$ 的 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>;</li>
<li>$\pi_2(\mathbf{Br}(R))$ 为 $R$ 的乘法可逆元群.</li>
</ul>
<h3>平展上同调的定义</h3>
<p>在一些小的假设下, 概形 $X$ 的 Brauer 群 $\mathrm{Br}(X)$ 同构于<span class="link local"><a href="./平展上同调.html" title="平展上同调 [平展上同调]">平展上同调</a></span> $H^2_{\text{\'et}}(X,\mathbb G_m)$ 的挠部分. 见<span class="link local"><a href="./EC-H1-H2.html" title="平展上同调讨论班 : 非 Abel 上同调, 主齐性空间与 Brauer 群 [EC-H1-H2]">平展上同调讨论班讲义</a></span>.</p>
<h3>“范畴化” 的定义</h3>
<p>Brauer 群某种意义上是 <span class="link local"><a href="./Picard群.html" title="Picard 群 [Picard群]">Picard 群</a></span>的<span class="link local"><a href="./范畴化.html" title="范畴化 [范畴化]">范畴化</a></span>.</p>
<p>对于概形 $X$ 可以谈论 “$X$ 上的拟凝聚<span class="link local"><a href="./叠.html" title="叠 [叠]">叠</a></span>”, 又叫 “$X$-线性<span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 ∞-范畴</a></span>”; 其构成的范畴记为 $\mathsf{Cat}_X$.
一个与 Brauer 群相关的群是所谓 “导出 Brauer 群”, 定义为 $\mathsf{Cat}_X$ 的 Picard 群
$$
\mathrm{Br}^{\mathrm{der}}(X) := \operatorname{Pic}(\mathsf{Cat}_X).
$$</p>
<h2>性质</h2>
<p>代数闭域的 Brauer 群是平凡群.</p>
</details></section><footer><section class="block link-list" id="backlinks"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Wiki"><details ><summary id="Azumaya代数"><header><h1><span class="taxon">Wiki. </span>Azumaya 代数 <a class="slug" href="./Azumaya代数.html">[Azumaya代数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>观念</h2>
<p>环或<span class="link local"><a href="./概形.html" title="概形 [概形]">概形</a></span>上的 <strong>Azumaya 代数</strong><sup class="footnote-reference" id="Azumaya代数_az-back"><a href="#Azumaya代数_az">1</a></sup>是域上的<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>的推广, 是 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>下可逆的代数, 给出 <span class="link local"><a href="./Brauer群.html" title="Brauer 群 [Brauer群]">Brauer 群</a></span>的元素.</p>
<div class="footnote-definition" id="Azumaya代数_az">
  <sup class="footnote-definition-label"><a href="#Azumaya代数_az-back">1</a></sup>
<p><strong>注</strong>. 東屋 五郎, Azumaya Gorō</p>
</div>
<p>Azumaya 代数在<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展</a></span>局部上是矩阵代数.</p>
<h2>定义</h2>
<h3>局部环</h3>
<p>局部环 $R$ 上的 <strong>Azumaya 代数</strong>是满足如下条件的 $R$-代数 $A$:</p>
<ul>
<li>$A$ 是有限维<strong>自由</strong> $R$-模;</li>
<li>映射 $A\otimes_R A^{\mathrm{op}} \to \operatorname{End}_R(A)$, $a\otimes a'\mapsto (x\mapsto axa')$ 为同构.</li>
</ul>
<p>由定义, Azumaya 代数在 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>的意义下可逆.</p>
<p>一种等价的定义是仅对 “纤维” (剩余域) 作要求. 记 $k= R/\mathfrak m$ 为剩余域, 则 $R$-代数 $A$ 是 Azumaya 代数当且仅当</p>
<ul>
<li>$A$ 是有限维自由 $R$-模, 且 $\bar{A} := A\otimes_R k$ 是 $k$ 上的 Azumaya 代数 (由后面证明的性质, 此即域 $k$ 上的<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>).</li>
</ul>
<p><em>证明</em>.
基本上是<span class="link local"><a href="./中山引理.html" title="中山引理 [中山引理]">中山引理</a></span>的直接应用.</p>
<h3>环</h3>
<p>局部环上的 Azumaya 代数可以推广到环上, 区别基本上只是局部环上的自由模推广为环上的<span class="link local"><a href="./投射模.html" title="投射模 [投射模]">投射模</a></span>.</p>
<p><strong>命题-定义</strong>. 设 $R$ 是交换环, $R$ 上的 Azumaya 代数是满足如下等价条件的 $R$-代数 $A$:</p>
<ul>
<li>存在 $R$-代数 $B$ 使得 $A\otimes_R B$ 与 $R$ <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>;</li>
<li>$A\otimes_R A^{\mathrm{op}}$ 与 $R$ <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>;</li>
<li>$A$ 的中心为 $R$, 且 $A$ 是 $R$ 上的<span class="link local"><a href="./可分代数.html" title="可分代数 [可分代数]">可分代数</a></span>;</li>
<li>$A$ 为 $R$-模范畴 $\mathsf{Mod}(R)$ 的<span class="link local"><a href="./紧投射生成元.html" title="紧投射生成元 [紧投射生成元]">有限生成投射生成元</a></span>, 且典范的 $R$-模同态 $A\otimes_R A^{\mathrm{op}} \to \operatorname{End}_R(A)$ 为同构.</li>
</ul>
<p>环上的 Azumaya 的概念可进一步推广为 <span class="link local"><a href="./Azumaya范畴.html" title="Azumaya 范畴 [Azumaya范畴]">Azumaya 范畴</a></span>.</p>
<h3>概形</h3>
<p><strong>定义 1</strong>. 概形 $X$ 上的 Azumaya 代数是满足如下条件的 $\mathcal O_X$-代数 $A$:</p>
<ul>
<li>$A$ 是<span class="link local"><a href="./凝聚层.html" title="凝聚层 [凝聚层]">凝聚</a></span> $\mathcal O_X$-模;</li>
<li>对 $X$ 的闭点 $x$, $A_x$ 是 $\mathcal O_{X,x}$ 上的 Azumaya 代数. 由局部环上 Azumaya 代数的性质, 这个条件可以仅在点处的 “纤维” (剩余域) 上验证.</li>
</ul>
<p>下面是一个等价的定义, 可视为将局部环上 Azumaya 代数的条件用 $X$ 的<span class="link local"><a href="./意象的内语言.html" title="意象的内语言 [意象的内语言]">内语言</a></span>陈述 (在 $X$ 的<span class="link local"><a href="./意象的内语言.html" title="意象的内语言 [意象的内语言]">内语言</a></span>中 $\mathcal O_X$ 为<span class="link local"><a href="./局部环.html" title="“局部环” [局部环]">局部环</a></span>):</p>
<p><strong>定义 2</strong> (“内语言定义”). $A$ 为 $\mathcal O_X$-代数, 且为有限型 “自由” $\mathcal O_X$-模, 且 $A\otimes A^{\mathrm{op}} \to \operatorname{End}_{\mathcal O_X}(A)$ 为同构.</p>
<p><strong>注</strong>. 内语言中的 “自由” 翻译到外部即局部自由.</p>
<p>另一个等价的定义是</p>
<p><strong>定义 3</strong> (“<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展</a></span> / 平坦局部矩阵代数”). $A$ 为 $\mathcal O_X$-代数, 且为有限型 $\mathcal O_X$-模, 且存在<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展</a></span>覆盖 (或平坦覆盖) $(U_i \to X)$, 使得 $A_{U_i}$ 是 $\mathcal O_{U_i}$ 上的矩阵代数.</p>
<p>我们证明后两种定义与定义 1 等价.</p>
<ul>
<li>假设 $A$ 在每个局部环 $\mathcal O_{X,x}$ 上均为 Azumaya 代数, 那么 $(A\otimes A^{\mathrm{op}})_x \simeq A_x\otimes A^{\mathrm{op}}_x$, $\operatorname{End}_{\mathcal O_X}(A)_x \simeq \operatorname{End}_{\mathcal O_{X,x}}(A_x)$, 于是 $A\otimes A^{\mathrm{op}} \to \operatorname{End}_{\mathcal O_X}(A)$ 为同构. 所以 “内语言定义” 与原定义等价.</li>
<li>假设 $A$ 在平展或平坦覆盖 $(U_i \to X)$ 上为矩阵代数. 那么 $U=\bigsqcup U_i$ 在 $X$ 上忠实平坦, 可得 $A$ 平坦从而为 Zariski 局部自由 $\mathcal O_X$-模. 在每一点 $x$ 的纤维 (剩余域) 上, 记 $A(x) := A_x \otimes k(x)$, 那么平坦覆盖 $U$ 上任何一个打到 $x$ 的点都给出 $k(x)$ 的一个域扩张 $k'$, 使得 $A(x) \otimes_{k(x)} k'$ 是 $k'$ 上的矩阵代数. 这推出 $A(x)$ 是 $k$ 上的中心单代数, 即 Azumaya 代数. 所以 “平坦局部矩阵代数” 与原定义等价.</li>
</ul>
<h3>环谱</h3>
<p>设 $R$ 是 $\mathbb E_3$-<span class="link local"><a href="./环谱.html" title="环谱 [环谱]">环谱</a></span>, 那么 $\mathsf{Mod}(R)$ 是 $\mathbb E_2$-幺半范畴, <span class="link local"><a href="./高阶模.html" title="高阶模 [高阶模]">$1\mathsf{Pr}_R=\mathsf{Mod}(\mathsf{Mod}(R))$</a></span> 是 $\mathbb E_1$-幺半范畴. 定义 $R$ 上的 Azumaya 代数为 $1\mathsf{Pr}_R$ 中的可逆对象.</p>
<h2>性质</h2>
<h3>张量积</h3>
<p><strong>命题</strong>. 局部环 $R$ 上的 Azumaya 代数 $A,B$ 的张量积 $A\otimes_R B$ 仍为 Azumaya 代数.</p>
<p><em>证明</em>. 这是如下事实的推论:</p>
<ul>
<li>$R$-代数 $A$ 为 Azumaya 代数当且仅当 $\bar{A}= A\otimes_R k$ 为 $k$ 上的 Azumaya 代数;</li>
<li>域上的 Azumaya 代数等同于<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>;</li>
<li>域上的中心单代数的张量积仍为中心单代数.</li>
</ul>
<h3>函子性</h3>
<p>局部环上 Azumaya 代数的概念有如下的函子性.</p>
<p><strong>命题</strong>. 设 $A$ 是 $R$ 上的 Azumaya 代数, $R'$ 是局部环, 且有环同态 $R\to R'$ (甚至不要求为局部环同态), 则 $A\otimes_R R'$ 构成 $R'$ 上的 Azumaya 代数.</p>
<p><em>证明</em>.
由已知,
$$
A\otimes_R A^{\mathrm{op}}
\simeq
\operatorname{End}_R(A).
$$
作用 $-\otimes_R R'$ 得
$$
A\otimes_R A^{\mathrm{op}}\otimes_R R'
\simeq
\operatorname{End}_R(A)\otimes_R R'.
$$
此即
$$
(A\otimes_R R')\otimes_{R'} (A\otimes_R R')^{\mathrm{op}}
\simeq
\operatorname{End}_{R'}(A\otimes_R R').
$$</p>
<h3>与中心单代数的关系</h3>
<p>下面的结论说明 Azumaya 代数是域上的<span class="link local"><a href="./中心单代数.html" title="中心单代数 [中心单代数]">中心单代数</a></span>的推广.</p>
<p><strong>结论</strong>. 设 $R$ 为局部环, $A$ 是 $R$ 上的 Azumaya 代数, 则</p>
<ul>
<li>$A$ 的<span class="link local"><a href="./中心.html" title="中心 [中心]">中心</a></span>为 $R$,</li>
<li>$A$ 的双边理想一一对应于 $R$ 的理想: 对于 $A$ 的双边理想 $I$, $I=(I\cap R)A$; 对于 $R$ 的理想 $J$, $J=JA\cap R$.</li>
</ul>
<p><em>证明</em>.
由于 $A\otimes_R A^{\mathrm{op}} \simeq \operatorname{End}_R(A)$,
对任意 $\varphi\in \operatorname{End}_R(A)$,
存在 $b_1,b'_1,\cdots,b_k,b'_k\in A$ 使得
$\varphi(a)=b_1ab'_1+\cdots +b_kab'_k$.
这说明</p>
<ul>
<li>对于 $A$ 的中心的元素 $c$, 有 $\varphi(ac)=\varphi(a)c$;</li>
<li>对于 $A$ 的双边理想 $I$, 有 $\varphi(I)\subset I$.</li>
</ul>
<p>设 $a_1=1,\cdots,a_n$ 是 $A$ 的一组 $R$-基.
考虑 $A$ 的 $R$-线性自同态 $\chi_i$, 满足 $\chi_i(a_j)=\delta_{ij}$.
那么 $\chi_i$ 的像包含于 $R$.</p>
<p>对 $A$ 的中心的元素 $c$, 设
$$
    c=\sum r_ia_i\,(r_i\in R),
$$
则 $c=\chi_1(a_1)c=\chi_1(a_1c)=r_1\in R$.</p>
<p>设 $I$ 是 $A$ 的双边理想.
对 $a\in I$, 设
$$
    a=\sum r_ia_i\,(r_i\in R),
$$
那么 $r_i=\chi_i(a)\in I$,
从而 $a\in (I\cap R)A$.</p>
<p>设 $J$ 是 $R$ 的理想.
对 $a\in JA$, 设
$$
    a=\sum r_ia_i\,(r_i\in J),
$$
那么 $a\in R$ 当且仅当 $r_i=0\,(i&gt;1)$.
故 $JA\cap R = J$.</p>
<h3>分类</h3>
<p>由于 Azumaya 代数在平展局部上为矩阵代数, 而矩阵代数的自同构群为 <span class="link local"><a href="./PGLn.html" title="PGLn [PGLn]">$\mathrm{PGL}_n$</a></span>, Azumaya 代数给出<span class="link local"><a href="./非Abel上同调.html" title="非 Abel 上同调 [非Abel上同调]">非 Abel 上同调</a></span> $H^1(X_{\mathrm{\'et}},\mathrm{PGL}_n)$ 的元素.</p>
<p>另一方面, 对<span class="link local"><a href="./平展意象.html" title="平展意象 [平展意象]">平展意象</a></span>中任意映射 $*\to\mathbf{B}\mathrm{PGL}_n$, 群同态 (闭嵌入)
$$
    \mathrm{PGL}_n \to \mathrm{GL}_{n^2}
$$
将其变为映射
$$
  {*} \to \mathbf{B}\mathrm{GL}_{n^2},
$$
由 $\mathrm{GL}_n$ 的 <span class="link local"><a href="./Zar-fl-et.html" title="Zariski 景, 平展景与平坦景的比较 [Zar-fl-et]">Zariski 与平展的比较</a></span>, 它实际上来自于一个秩为 $n^2$ 的 Zariski 局部自由 $\mathcal O_X$-模.</p>
<h3>与向量丛的关系</h3>
<p>考虑群同态 (<span class="link local"><a href="./Zariski意象.html" title="Zariski 意象 [Zariski意象]">Zariski 意象</a></span>中的满射)
$$
\mathrm{GL}_n \to \mathrm{PGL}_n
$$
给出的<span class="link local"><a href="./非Abel上同调.html" title="非 Abel 上同调 [非Abel上同调]">上同调</a></span>的映射
$$
H^1(X_{\mathrm{\'et}},\mathrm{GL}_n) \to H^1(X_{\mathrm{\'et}},\mathrm{PGL}_n).
$$
我们断言它将向量丛 $E$ 映射到 Azumaya 代数 $\operatorname{End}(E)$.</p>
<p><em>证明</em>. 设 $E\colon * \to \mathbf{B}\mathrm{GL}_n$ 在 Zariski 覆盖 $U$ 上有平凡化
$$
\phi \colon \mathcal O_U^n \simeq E|_U.
$$
平凡化 $\phi$ 给出覆盖 $U$ 上实现了 $E$ 的 $\mathrm{GL}_n$-<span class="link local"><a href="./非交换Čech上同调.html" title="非交换 Čech 上同调 [非交换Čech上同调]">Čech 上圈</a></span>
$$
(\phi\mathrm{pr}_2)^{-1}(\phi\mathrm{pr}_1)\colon  U\times U \to \mathrm{GL}_n.
$$
平凡化 $\phi$ 还给出同构
$$
\psi\colon M_n(\mathcal O_U) = \operatorname{End}(\mathcal O_U^n)\simeq \operatorname{End}(E|_U),
$$
其中 $\psi$ 的作用是将下图左边的竖向箭头变为右边的竖向箭头.
$$
\begin{array}
{ccc}
\mathcal O_U^n &amp; \overset{\phi}{\to} &amp; E|_U \\
\downarrow &amp; &amp; \downarrow\\
\mathcal O_U^n &amp; \underset{\phi}{\to} &amp; E|_U
\end{array}
$$
那么实现 $\operatorname{End}(E)$ 的一个 <span class="link local"><a href="./PGLn.html" title="PGLn [PGLn]">$\mathrm{PGL}_n$</a></span>-<span class="link local"><a href="./非交换Čech上同调.html" title="非交换 Čech 上同调 [非交换Čech上同调]">Čech 上圈</a></span>为
$$
(\psi\mathrm{pr}_2)^{-1}(\psi\mathrm{pr}_1)\colon U\times U \to \mathrm{PGL}_n.
$$
注意到 $(\psi\mathrm{pr}_2)^{-1}(\psi\mathrm{pr}_1)$ 的作用是将下图最左边的竖向箭头变为最右边的竖向箭头.
$$
\begin{array}
{ccc}
\mathcal O_{U\times U}^n &amp; \overset{\phi\mathrm{pr}_1}{\to} &amp; E|_{U\times U} &amp; \overset{\phi\mathrm{pr}_2}{\leftarrow} &amp; \mathcal O^n_{U\times U} \\
\downarrow &amp; &amp; \downarrow &amp; &amp; \downarrow\\
\mathcal O_{U\times U}^n &amp; \underset{\phi\mathrm{pr}_1}{\to} &amp; E|_{U\times U} &amp; \underset{\phi\mathrm{pr}_2}{\leftarrow} &amp; \mathcal O^n_{U\times U}
\end{array}
$$
这正是前面实现了 $E$ 的 $\mathrm{GL}_n$-<span class="link local"><a href="./非交换Čech上同调.html" title="非交换 Čech 上同调 [非交换Čech上同调]">Čech 上圈</a></span>
$$
(\phi\mathrm{pr}_2)^{-1}(\phi\mathrm{pr}_1)\colon  U\times U \to \mathrm{GL}_n
$$
在群同态 $\mathrm{GL}_n \to \mathrm{PGL}_n , X\mapsto X(-)X^{-1}$ 下的像 (详见 <span class="link local"><a href="./PGLn.html" title="PGLn [PGLn]">$\mathrm{PGL}_n$</a></span> 页面). $\square$</p>
<h3>Azumaya 代数的相似, Brauer 群</h3>
<p>定义环或概形上 Azumaya 代数的相似关系: $A\sim A'$ 当且仅当存在 Zariski 局部自由模 $E,E'$ 使得 $A\otimes \operatorname{End}(E) \simeq A'\otimes \operatorname{End}(E')$.</p>
<p>注意到 $\operatorname{End}(E)\otimes \operatorname{End}(E') \simeq \operatorname{End}(E\otimes E')$, 故张量积保持相似关系; 全体相似等价类在张量积下构成一个群, 称为环或概形的 <span class="link local"><a href="./Brauer群.html" title="Brauer 群 [Brauer群]">Brauer 群</a></span>.</p>
<p><strong>命题</strong>. 两个 Azumaya 代数相似当且仅当它们作为结合代数 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>.</p>
<p><em>证明</em>. 由于 $\operatorname{End}(E)$ Morita 等价于基环, 且张量积保持 Morita 等价, Azumaya 代数的相似当然推出 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>. 需要费点功夫的是另一个方向.</p>
<p>由 <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>的刻画, $R$-代数 $A$ <span class="link local"><a href="./Morita等价.html" title="Morita 等价 [Morita等价]">Morita 等价</a></span>于 $R$ 当且仅当 $A\simeq\operatorname{End}_R(E)$, $E$ 为有限生成投射 $R$-模. 对于 $R$ 为局部环的情形, $E$ 为自由 $R$-模.</p>
<p>设局部环 $R$ 上 Azumaya 代数 $A,A'$ Morita 等价, 由定义, Azumaya 代数 $A$ 在 Morita 等价意义下的逆为 $A^{\mathrm{op}}$, 故有 $A\otimes_R (A')^{\mathrm{op}}$ Morita 等价于 $R$. 由前述结论, $A\otimes_R (A')^{\mathrm{op}} \simeq\operatorname{End}_R(E)$, $E$ 为自由 $R$-模.
两边以 $-\otimes_R A'$ 作用, 得
$A\otimes_R \operatorname{End}_R(A') \simeq A'\otimes_R\operatorname{End}_R(E')$, 故 $A,A'$ 作为 Azumaya 代数相似.</p>
<h3>与束的关系</h3>
<p>概形 $X$ 上的 Azumaya 代数 $A$ 给出一个<span class="link local"><a href="./束.html" title="束 [束]">束</a></span> (gerbe) $F_A$:
对 $U\in X_{\mathrm{\'et}}$, $F_A(U)$ 是如下资料构成的 $1$-群胚:</p>
<ul>
<li>$U$ 上的向量丛 $E$;</li>
<li><span class="link local"><a href="./结合代数.html" title="结合代数 [结合代数]">代数</a></span>同构 $A_U \simeq \operatorname{End}(E)$.</li>
</ul>
<p>$F_A$ 局部非空是由于 Azumaya 代数<span class="link local"><a href="./平展景.html" title="平展景 [平展景]">平展</a></span>局部同构于矩阵代数. 此<span class="link local"><a href="./束.html" title="束 [束]">束</a></span>由群 $\mathbb G_m$ 控制:
$$
\begin{aligned}
    \operatorname{Aut}_{F_A(U)}(x)&amp;\simeq \operatorname{Aut}_{\operatorname{Aut}(\operatorname{End}(E))}(\mathrm{id})\\
    &amp;\simeq Z(\operatorname{End}(E))\simeq \mathbb G_m(U),
\end{aligned}
$$
(其中 $Z$ 表示代数的<span class="link local"><a href="./中心.html" title="中心 [中心]">中心</a></span>) 从而 (由<span class="link local"><a href="./束.html" title="束 [束]">束</a></span>与<span class="link local"><a href="./上同调.html" title="上同调 [上同调]">上同调</a></span>的关系) 定义了 $H^2(X_{\mathrm{\'et}},\mathbb G_m)$ 的元素; 并且它平凡当且仅当 $F_A$ 有<span class="link local"><a href="./整体截面.html" title="“整体截面” [整体截面]">整体</a></span>元素, 即 $A$ 在整体上同构于一个向量丛的自同态代数.</p>
<h2>例</h2>
<h3>特征 $p$ 的微分算子</h3>
<p>设 $k$ 为特征 $p$ 域, $A = k\langle x,\partial \rangle / ([\partial ,x]-1)$ 为 <span class="link local"><a href="./Weyl代数.html" title="Weyl 代数 [Weyl代数]">Weyl 代数</a></span>. 那么 $A$ 是 $k[x^{p},y^p]$ 上的 Azumaya 代数.</p>
<p>首先, $x^p, \partial^p$ 落在 $A$ 的中心中.</p>
<p>不妨设 $\bar k$ 代数闭; 由 Hilbert 零点定理, $k[x^p,y^p]$ 的极大理想形如 $(x^p-a,y^p-b)$; 设 $\alpha^p = a, \beta^p = b$, 则有同构
$$
A / (x^p - a ,y^p - b) \simeq \operatorname{End}_k(k[x]/x^p),
$$
$$
x\mapsto \text{乘 } (x+\alpha),\,y\mapsto \frac{\partial}{\partial x}+\beta.
$$</p>
<h3>量子环面</h3>
<p>设 $A = \mathbb{C}\langle z^{\pm 1}, t^{\pm 1} \rangle / (zt = qtz)$, $q\in\mathbb{C}^\times$ 为固定的常数. 这称为<strong>量子环面</strong> (quantum tori) 上的 “函数环”. 设 $q$ 为 $n$ 次单位根, 则 $A$ 是 $\mathbb{C}[x^{\pm n}, t^{\pm n}]$ 上的 Azumaya 代数.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="Gestalt"><header><h1><span class="taxon">Wiki. </span>Gestalt <a class="slug" href="./Gestalt.html">[Gestalt]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<p>Gestalt (复数 Gestalten, 在心理学上的译名为 “格式塔”) 是 <span class="link local"><a href="./ScholzeStefanichGestalten.html" title="Geometry and Higher Category Theory [ScholzeStefanichGestalten]">Scholze–Stefanich</a></span> 提出的一种几何概念, 旨在恢复完全的<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数–几何对偶</a></span>: 通过考虑几何对象上的 “线性 $(\infty,n)$-范畴” 取值的层, 即<span class="link local"><a href="./高阶拟凝聚层.html" title="高阶拟凝聚层 [高阶拟凝聚层]">高阶拟凝聚层</a></span>, 使得任何几何对象都具有代数的对应物, 而不再需要对 “仿射” 几何对象进行粘合操作.</p>
<h2>观念</h2>
<ol>
<li>代数几何中的几乎所有几何对象都来自于仿射概形之类的基本对象的 “粘合”. 做这件事的一般框架是<span class="link local"><a href="./景.html" title="景 [景]">景</a></span>和<span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span>的理论. 给仿射概形的范畴配备适当的覆盖结构, 然后取其上的层, 这就相当于取仿射概形的 (形式上的) 余极限, 得到一个包含许多几何对象的<span class="link local"><a href="./意象.html" title="意象 [意象]">意象</a></span>.
而后<span class="link local"><a href="./模空间.html" title="模空间 [模空间]">模空间</a></span>的研究让人们自然地考虑群胚取值的层, 又称<span class="link local"><a href="./叠.html" title="叠 [叠]">叠</a></span>. 群胚取值的层是带有同伦信息的几何对象, 构成一个 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">∞-意象</a></span>.</li>
<li>在<span class="link local"><a href="./代数-几何对偶.html" title="代数–几何对偶 [代数-几何对偶]">代数–几何对偶</a></span>中, 通常不是所有几何对象都有完美的代数侧对偶. 例如在概形中, 只有仿射概形能被其上的整体函数环完全决定. 不仿射的概形如 $\mathbb P^1_k$ ($k$ 为域), 其上没有足够多的整体函数, 以至于仅看整体函数我们无法将它和一个点区分开.</li>
<li>在有非平凡高阶同伦信息的几何对象 (例如群概形 $G$ 的<span class="link local"><a href="./分类空间.html" title="分类空间 [分类空间]">分类空间</a></span> $* / G$) 上, 整体函数更加不可能提供全部的信息. 但 <span class="link local"><a href="./淡中对偶.html" title="淡中对偶 [淡中对偶]">Tannaka</a></span> 指出此时<span class="link local"><a href="./拟凝聚层.html" title="拟凝聚层 [拟凝聚层]">拟凝聚层</a></span>的范畴 $\mathsf{QCoh}(X)$, 直观上即 “线性空间值的整体函数”, 连带着其上的<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半</a></span>结构, 能够忠实地记录这个几何对象. 这里<span class="link local"><a href="./对称幺半范畴.html" title="对称幺半范畴 [对称幺半范畴]">对称幺半范畴</a></span>作为一种代数对象, 可视为环的推广.</li>
<li>事实上, $\mathsf{QCoh}$ 能忠实记录的几何对象就已经包括了所有的 (qcqs) 概形.
不仅如此, 一些叠 (对角线仿射的 qcqs <span class="link local"><a href="./代数叠.html" title="代数叠 [代数叠]">Artin 叠</a></span>) 也能被其拟凝聚层范畴忠实记录, 人们称之为 $1$-仿射 ($1$-affine) 叠.</li>
<li>将 Abel 范畴升级为<span class="link local"><a href="./导出范畴.html" title="导出范畴 [导出范畴]">导出范畴</a></span>, 我们考虑的代数对象变成了<span class="link local"><a href="./可表现范畴.html" title="可表现范畴 [可表现范畴]">可表现</a></span><span class="link local"><a href="./对称幺半∞-范畴.html" title="对称幺半 ∞-范畴 [对称幺半∞-范畴]">对称幺半</a></span><span class="link local"><a href="./稳定无穷范畴.html" title="稳定范畴 [稳定无穷范畴]">稳定 ∞-范畴</a></span>. 通过取导出范畴 $D \colon \mathsf{CAlg}(\mathsf{Sp})\hookrightarrow\mathsf{CAlg}(\mathsf{Pr}_{\mathrm{st}}^{\mathrm{L}})$, 环 (包括环谱) 忠实地嵌入这种代数对象.</li>
<li>但仍旧有几何对象无法被拟凝聚层的 (导出) 范畴记录. 例如 $\mathbf{B}^2\mathbb G_m$ (与 <span class="link local"><a href="./Brauer群.html" title="Brauer 群 [Brauer群]">Brauer 群</a></span>有关) 上就没有足够的拟凝聚层, 以至于仅看拟凝聚层无法将它和一个点区分开. 而 $\mathbf{B}^2\mathbb G_m$ 上能够记录其全部几何信息的是一个 “范畴值” 的拟凝聚层, 事实上是万有的 “范畴值线丛” (正如 $\mathbf{B}\mathbb G_m$ 上有万有线丛一样).</li>
<li>为了记录所有几何对象, 我们需要不断地走向范畴层级更高的代数对象, 即<span class="link local"><a href="./高阶拟凝聚层.html" title="高阶拟凝聚层 [高阶拟凝聚层]">高阶拟凝聚层</a></span>. 这就是 Gestalt 的起源.</li>
</ol>
<h2>定义</h2>
<p>Gestalt 的定义是基于一个称为 <strong>Stefanich 环</strong>的代数对象.</p>
<p>一个 Stefanich 环 $A$ 是如下资料:</p>
<ul>
<li>一个越来越高阶的<span class="link local"><a href="./可表现范畴.html" title="可表现范畴 [可表现范畴]">可表现范畴</a></span>的<span class="link local"><a href="./交换代数.html" title="交换代数 [交换代数]">交换代数</a></span>的塔
$$
      (A_0,A_1,A_2,\cdots),A_n\in \mathsf{CAlg}(n\mathsf{Pr}),
$$</li>
<li>每个部分 $A_n$ 等价于高一阶的部分 $A_{n+1}$ 的 “环路空间”:
$$
      A_n \simeq \operatorname{End}_{A_{n+1}}(1) \in \mathsf{CAlg}(n\mathsf{Pr}).
$$</li>
</ul>
<p>换言之, Stefanich 环构成的 $(\infty,1)$-范畴为
$$
\mathsf{StRing} = \operatorname{lim}_{\operatorname{End}_{-}(1)} \mathsf{CAlg}(n\mathsf{Pr}).
$$
(忽略这些范畴的高阶不可逆态射, 仅考虑其 $(\infty ,1)$-范畴结构.)</p>
<p><strong>注</strong>. 由定义中的第二个条件, Stefanich 环 $A=(A_0,A_1,A_2,\cdots)$ 的每个部分 $A_n$ 的交换代数结构实际上被高一阶的部分 $A_{n+1}$ 决定了. 进一步, 我们可以在定义中仅要求 $A_n\in n\mathsf{Pr}$, 且有等价 $A_n \simeq \operatorname{End}_{A_{n+1}}(*)$ ($A_n$ 的基点为恒等). 这样 (由 <span class="link local"><a href="./Eckmann--Hilton论证.html" title="Eckmann–Hilton 论证 [Eckmann--Hilton论证]">Eckmann–Hilton论证</a></span>) 交换代数的结构就来自于一连串等价
$$
A_n = \operatorname{End}_{A_{n+1}}(*) = \operatorname{End}_{\operatorname{End}_{A_{n+2}}(*)}(*) = \cdots.
$$</p>
<p><strong>定义</strong>. Gestalt 为 Stefanich 环的对偶: $\mathsf{Gest} = \mathsf{StRing}^{\mathrm{op}}$.</p>
<h2>性质</h2>
<p><strong>定理</strong> (<span class="link local"><a href="./ScholzeStefanichGestalten.html" title="Geometry and Higher Category Theory [ScholzeStefanichGestalten]">Scholze–Stefanich</a></span>). $\mathsf{Gest}$ 是一个 <span class="link local"><a href="./∞-意象.html" title="∞-意象 [∞-意象]">$\infty$-意象</a></span>.</p>
<h2>例</h2>
<p>普通的交换环 $A$ 给出一个 Stefanich 环
$$
(A,\mathsf{Mod}(A),1\mathsf{Pr}_A,2\mathsf{Pr}_A,\cdots).
$$</p>
<p>对于仿射概形范畴上适当的 Grothendieck 拓扑, 该构造即延拓至适当的叠.</p>
</details></section><section class="block" data-taxon="Wiki"><details ><summary id="中心单代数"><header><h1><span class="taxon">Wiki. </span>中心单代数 <a class="slug" href="./中心单代数.html">[中心单代数]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="./SimplicialCat.html" title="单纯猫 [SimplicialCat]">SimplicialCat</a></span></li></ul></div></header></summary>
<h2>定义</h2>
<p>域 $k$ 上的中心单代数 $A$ 是满足如下条件的<strong>有限维</strong> $k$-代数:</p>
<ul>
<li>$A$ 为单代数, 即 $A$ 没有非平凡的<strong>双边</strong>理想;</li>
<li>$A$ 的<span class="link local"><a href="./中心.html" title="中心 [中心]">中心</a></span>为 $k$.</li>
</ul>
<p>对于两个中心单代数 $A,B$, 若如下等价条件成立, 则称它们<strong>相似</strong>:</p>
<ol>
<li>存在 $k$ 上的可除代数 $D$ 使得 $A,B$ 都同构于 $D$ 上的某个矩阵代数;</li>
<li>$A$ 上的某个矩阵代数同构于 $B$ 上的某个矩阵代数.</li>
</ol>
<p>域 $k$ 上的中心单代数的相似类关于张量积构成的群称为 $k$ 的 <span class="link local"><a href="./Brauer群.html" title="Brauer 群 [Brauer群]">Brauer 群</a></span> $\mathrm{Br}(k)$.</p>
<h2>例</h2>
<p>矩阵环 $M_n(K)$ 是 $K$ 上的中心单代数.</p>
<p>$\mathbb{H}$ 是 $\mathbb{R}$ 上的中心单代数.</p>
<h2>性质</h2>
<h3>张量积</h3>
<p><strong>命题</strong>. 设 $A,B$ 为域 $k$ 上的中心代数, 则 $A\otimes_k B$ 为中心代数.</p>
<p>证明. 设 $z = \sum_{i=1}^n a_i \otimes b_i$ 是 $A\otimes_k B$ 的中心的元素, 使得 $\{b_i\}$ 在 $k$ 上线性无关. 对任意 $a\in A$,
$$
0 = az-za = \sum_{i=1}^n (aa_i-a_ia)\otimes b_i.
$$
故 $aa_i = a_i a$ 对每个 $i$ 成立, 从而 $a_i\in k$, 进而 $z$ 可以写成 $1\otimes b$, $b\in B$, 而 $b$ 又与 $B$ 的所有元素交换, 故 $b\in k$. 这说明 $A\otimes_k B$ 的中心为 $k$. $\square$</p>
<p><strong>命题</strong>. 设 $A$ 为域 $k$ 上的中心单代数, $B$ 为 $k$ 上的单代数, 则 $A\otimes_k B$ 为 $k$ 上的单代数.</p>
<p>证明. 设 $I$ 为 $A\otimes_k B$ 的双边理想.</p>
<p>注意到 $I$ 的非零元素 $x$ 可以写成 $x=\sum_{i=1}^n a_i\otimes b_i \in I$, 且 $\{b_i\}$ 在 $k$ 上线性无关. 考虑<strong>所有</strong> $x\in I$ 的所有这种表达式中使得 $n$ <strong>最小</strong>者.</p>
<p>由于 $n$ 的最小性, 有 $a_1\neq 0$, 从而 $a_1$ 生成的 $A$ 的双边理想是 $A$ 自身, 故可选取 $x\in I$ 使得 $a_1=1$. 由于 $n$ 的最小性, 对任意 $a\in A$, 有 $ax-xa = 0$, 也即 $a$ 与 $a_2,\cdots,a_n$ 交换. 那么 $a_i\in Z(A)=k$. 这说明 $n=1$, $x = 1\otimes b$, $b\in B$. 由 $B$ 为单代数, $x$ 生成的 $B$ 的双边理想是 $B$ 自身, 故 $x$ 生成的 $A\otimes_k B$ 的双边理想是 $A\otimes_k B$ 自身. $\square$</p>
<p><strong>推论</strong>. 中心单代数的张量积仍是中心单代数.</p>
<p>这也是下述 Wedderburn 定理的推论, 因为 $M_n(D) \otimes_k M_{n'}(D') \simeq M_{nn'}(D\otimes_k D')$, 且中心可除代数的张量积为中心单代数.</p>
<h3>与中心可除代数的关系</h3>
<p><strong>定理</strong> (Wedderburn). 域 $k$ 上的有限维单代数同构于 $k$ 上的某个<strong>中心可除代数</strong> $D$ 的某个矩阵代数 $M_n(D)$.</p>
<p>设域 $k$ 上的中心单代数 $A$ 同构于 $M_n(D)$, $D$ 为 $k$ 上的中心可除代数. 则同构意义下, $A$ 上唯一的单左模是 $D^n$.</p>
<p><strong>定理</strong> (Frobenius). $\mathbb{R}$ 上的有限维可除代数仅有 $\mathbb{R},\mathbb{C},\mathbb{H}$.</p>
<p>因此, $\mathbb{R}$ 上的<strong>中心</strong>可除代数仅有 $\mathbb{R},\mathbb{H}$. 换言之, $\mathbb R$ 的 <span class="link local"><a href="./Brauer群.html" title="Brauer 群 [Brauer群]">Brauer 群</a></span>是由 $\mathbb H$ 生成的二阶群 $\mathbb{Z}/2$.</p>
<h3>自同构</h3>
<p><strong>定理</strong> (<span class="link local"><a href="./Skolem–Noether定理.html" title="Skolem–Noether 定理 [Skolem–Noether定理]">Skolem–Noether</a></span>). 中心单代数的自同构为内自同构.</p>
</details></section></details></section></footer></article></div></body></html>